<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bigpigeon</title>
    <link>https://bigpigeon.org/</link>
    <description>Recent content on bigpigeon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Fri, 23 Jun 2017 15:16:00 +0800</lastBuildDate>
    <atom:link href="https://bigpigeon.org/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>gorm简介[中]</title>
      <link>https://bigpigeon.org/post/gorm-tutorial-second/</link>
      <pubDate>Fri, 23 Jun 2017 15:16:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/gorm-tutorial-second/</guid>
      <description>&lt;p&gt;上篇讲到如何用gorm增删改查，但如果涉及一些复杂的操作又想避免使用字符串就需要借助Scopes模块&lt;/p&gt;

&lt;h3 id=&#34;scopes简介&#34;&gt;scopes简介&lt;/h3&gt;

&lt;p&gt;scopes是需要一个自定义的函数&lt;strong&gt;func(db *gorm.DB) *gorm.DB&lt;/strong&gt;作为参数，这样就可以在不破坏链式语法的情况下自定义操作了&lt;/p&gt;

&lt;p&gt;比如我要查询GreekAlphabet表中LatinName是&amp;rdquo;Alpha&amp;rdquo;或 &amp;ldquo;Omega&amp;rdquo;的条目可以这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;chars := []GreekAlphabet{}
db.Model(&amp;amp;GreekAlphabet{}).Where(&amp;quot;latin_name in (?)&amp;quot;, []string{&amp;quot;Alpha&amp;quot;, &amp;quot;Omega&amp;quot;}).Find(&amp;amp;chars)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为查询多个字段的值只能用 &lt;strong&gt;Where(&amp;ldquo;field in (?)&amp;rdquo;, fields)&lt;/strong&gt; 这种方法，相当于是自己拼接sql语句了，这种方法非常容易出错，所以我们用Scopes封装这部分操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;firstAndLast := func(db *gorm.DB) *gorm.DB {
  return db.Where(&amp;quot;latin_name in (?)&amp;quot;, []string{&amp;quot;Alpha&amp;quot;, &amp;quot;Omega&amp;quot;})
}
chars := []GreekAlphabet{}
db.Model(&amp;amp;GreekAlphabet{}).Scopes(firstAndLast).Find(&amp;amp;chars).Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样只要我们对firstAndLast做充足的单元测试就可以让其他人非常安心的使用了，但这样做还是很不灵活，所以下面我们使用offset来制造一个灵活的socpes查询&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用offset制作一个灵活的where-in查询&#34;&gt;使用offset制作一个灵活的Where in查询&lt;/h3&gt;

&lt;p&gt;首先要构建2个offset的map，用来查询offset对应的字段名(Name)和表字段名(DBName),我把它们放入OffsetSelector变量中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var OffsetSelector = struct {
	NameMap   map[reflect.Type]map[uintptr]string
	DBNameMap map[reflect.Type]map[uintptr]string
}{
	NameMap:   map[reflect.Type]map[uintptr]string{},
	DBNameMap: map[reflect.Type]map[uintptr]string{},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将Product和GreekAlphabet放入FieldSelector变量中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var FieldSelector struct {
	Product       Product
	GreekAlphabet GreekAlphabet
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后构造OffsetSelector中的NameMap和DBNameMap&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 把FieldSelector解析为reflect.Value这样可以用for循环获取其中的字段
fieldSelectVal := reflect.ValueOf(&amp;amp;FieldSelector).Elem()
for i := 0; i &amp;lt; fieldSelectVal.NumField(); i++ {
  fieldVal := fieldSelectVal.Field(i)
  // 通过gorm.scope来解析字段名(Name)和表字段名(DBName)容易很多
  scope := &amp;amp;gorm.Scope{Value: fieldVal.Interface()}
  // 获取表结构体的reflect.Type
  table := scope.GetModelStruct().ModelType
  // 获取表结构体中所有字段（这里的字段是gorm.Field而不是relfect.Field）
  gormFields := scope.Fields()
  OffsetSelector.NameMap[table] = map[uintptr]string{}
  OffsetSelector.DBNameMap[table] = map[uintptr]string{}
  // 循环拿取表结构体中每一个字段然后把对应的offset和字段名/表字段名分别映射到NameMap/DBNameMap对应的table映射中
  for j := 0; j &amp;lt; len(gormFields); j++ {
    subfield := gormFields[j]
    offset := subfield.StructField.Struct.Offset

    OffsetSelector.NameMap[table][offset] = subfield.Name
    OffsetSelector.DBNameMap[table][offset] = subfield.DBName
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们就可以创建一个通过字段的offset来查询Where In函数了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;WhereIn := func(fieldOffset uintptr, set interface{}) func(db *gorm.DB) *gorm.DB {
  return func(db *gorm.DB) *gorm.DB {
    val := db.Value
    structType := reflect.TypeOf(val)
    // 获取非list或指针的reflect.Type
    for structType.Kind() == reflect.Slice || structType.Kind() == reflect.Ptr {
      structType = structType.Elem()
    }
    // Where的查询语句中用的是表字段名
    dbname, ok := OffsetSelector.DBNameMap[structType][fieldOffset]
    if ok == false {
      db.AddError(errors.New(&amp;quot;offset is invalid&amp;quot;))
    }
    query := fmt.Sprintf(&amp;quot;%s in (?)&amp;quot;, dbname)
    return db.Where(query, set)
  }
}
frequentNames := []string{&amp;quot;Alpha&amp;quot;, &amp;quot;Beta&amp;quot;, &amp;quot;Gamma&amp;quot;, &amp;quot;Delta&amp;quot;, &amp;quot;Pi&amp;quot;, &amp;quot;Lambda&amp;quot;}
//获取GreekAlphabet.LatinName的offset,记住Offsetof中的参数是表达式，所以不能传参,比如xx := GreekAlphabet{}.LatinName;unsafe.Offsetof(xx)这样是不行的
latinNameOffset := unsafe.Offsetof(GreekAlphabet{}.LatinName)
db.Model(&amp;amp;GreekAlphabet{}).Scopes(WhereIn(latinNameOffset, frequentNames)).Updates(&amp;amp;GreekAlphabet{IsFrequent: true})

frequents := []GreekAlphabet{}
// 查看所有IsFrequent=true的集合
db.Where(&amp;amp;GreekAlphabet{IsFrequent: true}).Find(&amp;amp;frequents)
t.Logf(&amp;quot;%10s\t%s\t%s\t%s&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;upper&amp;quot;, &amp;quot;lower&amp;quot;, &amp;quot;frequent&amp;quot;)
for _, c := range frequents {
  t.Logf(&amp;quot;%10s\t%c\t%c\t%v&amp;quot;, c.LatinName, c.UpperCode, c.LowerCode, c.IsFrequent)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用offset制作一个灵活的field-preload&#34;&gt;使用Offset制作一个灵活的Field Preload&lt;/h3&gt;

&lt;p&gt;上篇已经讲过利用Preload可以获取嵌套的获取外键关联的字段比如这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
db.Preload(&amp;quot;Origin&amp;quot;).Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是Preload函数需要提供一个字段名字符串作为参数，所以我们这里通过构造一个利用Offset来查询外键关联字段&lt;/p&gt;

&lt;p&gt;使用刚才已经创建的OffsetSelector.NameMap就可以获取offset对应的字段名了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;FieldPreload := func(offset uintptr) func(db *gorm.DB) *gorm.DB {
  return func(db *gorm.DB) *gorm.DB {
    val := db.Value
    structType := reflect.TypeOf(val)
    // 获取非list或指针的reflect.Type
    for structType.Kind() == reflect.Slice || structType.Kind() == reflect.Ptr {
      structType = structType.Elem()
    }
    name, ok := OffsetSelector.NameMap[structType][offset]
    if ok == false {
      db.AddError(errors.New(&amp;quot;offset is invalid&amp;quot;))
    }
    t.Log(OffsetSelector.NameMap[structType])
    return db.Preload(name)
  }
}
var product Product
fieldOffset := unsafe.Offsetof(product.Origin)
originPreload := FieldPreload(fieldOffset)
db.Model(&amp;amp;Product{}).Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).Scopes(originPreload).First(&amp;amp;product)
// 查看查询结构是否正确
t.Logf(&amp;quot;this product name &#39;%s&#39;, the address is &#39;%v&#39;&amp;quot;, product.Name, product.Origin.Address1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;结尾&#34;&gt;&lt;strong&gt;结尾&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;上面举了2个使用Scopes的使用例子，用来帮助大家在使用gorm时如何更好的保持一致性原则&lt;/p&gt;

&lt;p&gt;不过如果有人通过gorm修改了默认表名/默认字符串名创建方式上面的方法就会失效，因为我这边为了易读性就没有用更复杂的写法了&lt;/p&gt;

&lt;p&gt;下篇将会解析gorm下的各个数据结构，可能需要很长时间来整理资料&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>谈谈go的relfect</title>
      <link>https://bigpigeon.org/post/go-reflect-talk/</link>
      <pubDate>Tue, 06 Jun 2017 15:16:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/go-reflect-talk/</guid>
      <description>&lt;p&gt;go的reflect实现了一个运行时反射，它允许程序操纵任意类型的对象&lt;/p&gt;

&lt;p&gt;reflect.TypeOf函数能把对象的类型信息，它返回一个relect.Type&lt;/p&gt;

&lt;p&gt;reflect.Type.Field模块可以获得&lt;strong&gt;struct&lt;/strong&gt;或者&lt;strong&gt;interface&lt;/strong&gt;中的字段名，字段类型，字段的tag等信息&lt;/p&gt;

&lt;p&gt;reflect.ValueOf可以获得一个对象的值信息，比如它是指针还是实体，值的类型和interface类型下的值，它返回一个reflect.Value&lt;/p&gt;

&lt;p&gt;我这里简单谈谈reflect的用法和哪些能做到哪些不能做到&lt;/p&gt;

&lt;p&gt;Ps:以下所有代码都包含在这个&lt;a href=&#34;https://github.com/bigpigeon/Test/tree/master/go/reflect_demo&#34;&gt;测试项目&lt;/a&gt;中&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;reflect库有3个重要的类型，Type,Value和StructField,分别对应对象类型，对象值，字段对象&lt;/p&gt;

&lt;p&gt;Type和Value可以通过TypeOf(obj)和ValueOf(obj)的方法来获取obj的类型属性和值属性&lt;/p&gt;

&lt;p&gt;当Type的类型为Struct时可以通过Field，FieldByIndex，FieldByName模块等到里面的StructField&lt;/p&gt;

&lt;p&gt;而Value下的Field，FieldByIndex，FieldByName只是获取字段对应的Value&lt;/p&gt;

&lt;h3 id=&#34;普通字段的取值&#34;&gt;普通字段的取值&lt;/h3&gt;

&lt;p&gt;int类型，其他比如float,uint和complex都是这种，就不举例了&lt;/p&gt;

&lt;p&gt;t是*testing.T，因为是在Test函数里面跑，所以用t.Logf来打印日志&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a int = 20
aVal := reflect.ValueOf(a)
aType := reflect.TypeOf(a)
t.Logf(&amp;quot;variable a Value is %v&amp;quot;, aVal.Interface())
t.Logf(&amp;quot;variable a Type is %s&amp;quot;, aType.String())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a string = &amp;quot;abcd1234&amp;quot;
aVal := reflect.ValueOf(a)
aType := reflect.TypeOf(a)
t.Logf(&amp;quot;variable a Value is %v&amp;quot;, aVal.Interface())
t.Logf(&amp;quot;variable a Type is %s&amp;quot;, aType.String())
t.Logf(&amp;quot;variable a length is %d, last character is %c&amp;quot;, aVal.Len(), aVal.Index(aVal.Len()-1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a []int = []int{1, 2, 3, 4, 5}
// 当使用append遇到list的空间不足时会重分配n*2的空间，这里只是为了让cap和length不同才这么做
a = append(a, 6)
aVal := reflect.ValueOf(a)
aType := reflect.TypeOf(a)
t.Logf(&amp;quot;variable a Value is %v&amp;quot;, aVal.Interface())
t.Logf(&amp;quot;variable a Type is %s&amp;quot;, aType.String())
t.Logf(&amp;quot;variable a length is %d,cap is %d, last int is %d&amp;quot;, aVal.Len(), aVal.Cap(), aVal.Index(aVal.Len()-1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a map[int]string = map[int]string{1: &amp;quot;a&amp;quot;, 2: &amp;quot;b&amp;quot;, 3: &amp;quot;c&amp;quot;}
aVal := reflect.ValueOf(a)
aType := reflect.TypeOf(a)
OneVal := reflect.ValueOf(1)
t.Logf(&amp;quot;variable a Value is %v&amp;quot;, aVal.Interface())
t.Logf(&amp;quot;variable a Type is %s&amp;quot;, aType.String())
t.Logf(&amp;quot;variable a length is %d,one index value is %s&amp;quot;, aVal.Len(), aVal.MapIndex(OneVal))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改对象的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a int32 = 10
// 要改变reflect的中的值必须是一个指针的Elem()下的reflect.Value
aVal := reflect.ValueOf(a)
aPointVal := reflect.ValueOf(&amp;amp;a)
t.Logf(&amp;quot;variable a set status %v&amp;quot;, aVal.CanSet())
t.Logf(&amp;quot;variable a in point set status %v&amp;quot;, aPointVal.Elem().CanSet())
// 不用担心因为SetInt传入的是一个int64而设置负数会导致不正确，在这个函数中会根据int具体类型而做转换
aPointVal.Elem().SetInt(-20)
t.Logf(&amp;quot;variable a changed value %d&amp;quot;, aPointVal.Elem().Interface())
// Slice中元素都可以修改
var b []int = []int{1, 2, 3, 4}
bVal := reflect.ValueOf(b)
t.Logf(&amp;quot;slice b first element set status %v&amp;quot;, bVal.Index(0).CanSet())
// Map中元素都不能直接修改
var c map[int]int = map[int]int{1: 2, 2: 4, 3: 6}
cVal := reflect.ValueOf(c)
oneValue := reflect.ValueOf(1)
fourValue := reflect.ValueOf(4)

t.Logf(&amp;quot;map c the 1 key l element set status %v&amp;quot;, cVal.MapIndex(oneValue).CanSet())
// 不过可以使用SetMapIndex修改Val的值
cVal.SetMapIndex(oneValue, oneValue)
t.Logf(&amp;quot;map c the value with 1 key is %d&amp;quot;, cVal.MapIndex(oneValue))
// 也可以对不存在的key设值
cVal.SetMapIndex(fourValue, oneValue)
t.Logf(&amp;quot;now map c is %v&amp;quot;, cVal)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;结构体字段的取值&#34;&gt;结构体字段的取值&lt;/h3&gt;

&lt;p&gt;创建几个相关联的结构体和模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Application struct {
	Name        string `json:&amp;quot;name&amp;quot;`
	Description string `json:&amp;quot;description&amp;quot;`
	packageData []byte `json:&amp;quot;-&amp;quot;`
}
type MoneyType int

const (
	MoneyTypeUS = MoneyType(iota)
	MoneyTypeCN
)

type Money struct {
	MoneyType MoneyType `json:&amp;quot;money_type&amp;quot; xml:&amp;quot;MoneyType&amp;quot;`
	Number    float64   `json:&amp;quot;number&amp;quot;`
}

type MacApplication struct {
	Application `json:&amp;quot;application&amp;quot;`
	AppleStore  string `json:&amp;quot;apple_store&amp;quot;`
	Favorite    int    `json:&amp;quot;favorite&amp;quot;`
	Money       Money  `json:&amp;quot;money&amp;quot;`
}

func (app Application) GetData() []byte {
	return app.packageData
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并创建对应的对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;app := MacApplication{
  Application: Application{
    Name:        &amp;quot;sandbox tower defence&amp;quot;,
    Description: &amp;quot;a rpg td game&amp;quot;,
    packageData: []byte{},
  },
  AppleStore: &amp;quot;https://itunes.apple.com/us/app/example&amp;quot;,
  Favorite:   0,
  Money: Money{
    MoneyType: MoneyTypeUS,
    Number:    0,
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;strong&gt;reflect.Type下的Field(i)模块函数&lt;/strong&gt; 来获取结构体的第i个字段的StructField信息&lt;/p&gt;

&lt;p&gt;获得StructField可以获取字段的名字，标签和偏移量和索引信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;structVal := reflect.TypeOf(app)
for i := 0; i &amp;lt; structVal.NumField(); i++ {
			field := structVal.Field(i)
      // 如果是匿名字段,字段名等于类型名
      t.Logf(&amp;quot;%s, this field is a %s and kind is %v&amp;quot;, field.Name, field.Type, field.Type.Kind())

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过StructField.Anonymous判断是否匿名字段，StructField.Type.Kind() == reflect.Struct判断是否结构体，用这种方式来递归读取struct中的结构体信息&lt;/p&gt;

&lt;p&gt;下面这个函数带有一个回调，递归读取structType的字段， 并把它下面的每一个field都交给f去处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var RecursionGetField func(string, reflect.Type, func(field *reflect.StructField))
RecursionGetField = func(prefix string, structType reflect.Type, f func(field *reflect.StructField)) {
  for i := 0; i &amp;lt; structType.NumField(); i++ {
    field := structType.Field(i)
    field.Name = prefix + &amp;quot;.&amp;quot; + field.Name
    f(&amp;amp;field)
    if field.Type.Kind() == reflect.Struct {
      // 匿名结构体字段中的字段当成当前结构体的
      if field.Anonymous == true {
        RecursionGetField(prefix, field.Type, f)
      } else {
        RecursionGetField(field.Name, field.Type, f)
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过StructField.Tag获取标签相关信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;structVal := reflect.TypeOf(app)
for i := 0; i &amp;lt; structVal.NumField(); i++ {
     field := structVal.Field(i)
     t.Logf(&amp;quot;this field %s,tag is &#39;%s&#39; json field &#39;%s&#39;&amp;quot;, field.Name, field.Tag, field.Tag.Get(&amp;quot;json&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;应用实现&#34;&gt;应用实现&lt;/h3&gt;

&lt;p&gt;通过获取Field Name和Type Name来组装创建表的sql语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 这里只是做简单取类型和字段名,不涉及主键和附加属性的处理
// tableFields[table name][field name][field kind name]
tableFields := map[string]map[string]string{}
tables := []string{}
sqlTypeMap := map[reflect.Kind]string{
  reflect.Int:     &amp;quot;integer&amp;quot;,
  reflect.String:  &amp;quot;varchar(255)&amp;quot;,
  reflect.Float64: &amp;quot;real&amp;quot;,
}
structType := reflect.TypeOf(MacApplication{})
var GetTableField func(string, reflect.Type)

GetTableField = func(tName string, structType reflect.Type) {

  if tableFields[tName] == nil {
    tableFields[tName] = map[string]string{}
  }
  for i := 0; i &amp;lt; structType.NumField(); i++ {
    field := structType.Field(i)
    if field.Type.Kind() == reflect.Struct {
      if field.Anonymous == true {
        GetTableField(tName, field.Type)
      } else {
        GetTableField(field.Type.Name(), field.Type)
      }
    } else {
      tableFields[tName][field.Name] = sqlTypeMap[field.Type.Kind()]
    }
  }
}
GetTableField(structType.Name(), structType)
// 通过tableFields表组装sql到tables中
for tName, fields := range tableFields {
  fNameTypeList := []string{}
  for fName, fType := range fields {
    fNameTypeList = append(fNameTypeList, fmt.Sprintf(`&amp;quot;%s&amp;quot; %s`, fName, fType))
  }
  tables = append(tables, fmt.Sprintf(`CREATE TABLE &amp;quot;%s&amp;quot;(%s)`, tName, strings.Join(fNameTypeList, &amp;quot;,&amp;quot;)))
}
for _, tab := range tables {
  t.Log(tab)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据字段值的指针猜字段名，需要提供对象的指针和对象字段的指针，然后通过偏移量计算出StructField&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;structType := reflect.TypeOf(MacApplication{})
offsetmap := map[uintptr]reflect.StructField{}

for i := 0; i &amp;lt; structType.NumField(); i++ {
  field := structType.Field(i)
  offsetmap[field.Offset] = field
}

{
  realFieldName := &amp;quot;Application&amp;quot;
  structVal := reflect.ValueOf(&amp;amp;app)
  ApplicationVal := reflect.ValueOf(&amp;amp;app.Application)
  offset := ApplicationVal.Elem().UnsafeAddr() - structVal.Elem().UnsafeAddr()
  assert.Equal(t, realFieldName, offsetmap[offset].Name)
  t.Logf(&amp;quot;I guess this field is %s, real field is %s&amp;quot;, offsetmap[offset].Name, realFieldName)
}
{
  realFieldName := &amp;quot;AppleStore&amp;quot;
  structVal := reflect.ValueOf(&amp;amp;app)
  AppleStoreVal := reflect.ValueOf(&amp;amp;app.AppleStore)
  offset := AppleStoreVal.Elem().UnsafeAddr() - structVal.Elem().UnsafeAddr()
  assert.Equal(t, realFieldName, offsetmap[offset].Name)
  t.Logf(&amp;quot;I guess this field is %s, real field is %s&amp;quot;, offsetmap[offset].Name, realFieldName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型比对&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;a := MoneyTypeCN
b := 2
aType := reflect.TypeOf(a)
bType := reflect.TypeOf(b)
// 虽然他们的种类一样但类型不一样(kind翻译为种类是为了不和Type混淆)
t.Logf(&amp;quot;a kind is %v, b kind is %v&amp;quot;, aType.Kind(), bType.Kind())
t.Logf(&amp;quot;a Type is %v, b Type is %v&amp;quot;, aType.String(), bType.String())
// 也可以通过转为interface直接比较类型
_, aIsInt := reflect.New(aType).Interface().(int)
t.Logf(&amp;quot;a is int?%v&amp;quot;, aIsInt)
_, bIsMoneyType := reflect.New(bType).Interface().(MoneyType)
t.Logf(&amp;quot;b is MoneyType?%v&amp;quot;, bIsMoneyType)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>gorm简介[前]</title>
      <link>https://bigpigeon.org/post/gorm-tutorial-first/</link>
      <pubDate>Mon, 29 May 2017 15:16:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/gorm-tutorial-first/</guid>
      <description>&lt;p&gt;我们都知道，在正式环境中直接使用sql来查询数据库是很危险的，处理不好就有被注入式攻击的风险&lt;/p&gt;

&lt;p&gt;而且组装sql语句也容易出错和减低代码的可维护性&lt;/p&gt;

&lt;p&gt;所以需要一个工具来管理数据库语句的组装和操作&lt;/p&gt;

&lt;p&gt;gorm是目前比较成熟的go语言数据库管理库,它可以很方便的把go的结构体和数据库表绑定，从而简化获取数据的操作
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所有gorm的内容在它的&lt;a href=&#34;http://jinzhu.me/gorm/&#34;&gt;文档&lt;/a&gt;中已经介绍的很详细，所以我这里写的大部分内容可能只是对原文进行了翻译和个人理解上的补充&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;

&lt;h4 id=&#34;连接数据库&#34;&gt;&lt;strong&gt;连接数据库&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main
import (
	&amp;quot;github.com/jinzhu/gorm&amp;quot;
  //需要连接那个数据库，就import对应的dialect包
	_ &amp;quot;github.com/jinzhu/gorm/dialects/mysql&amp;quot;
	//_ &amp;quot;github.com/jinzhu/gorm/dialects/postgres&amp;quot;
	//_ &amp;quot;github.com/jinzhu/gorm/dialects/sqlite&amp;quot;
  //_ &amp;quot;github.com/jinzhu/gorm/dialects/mssql&amp;quot;
)

func main(){
  db, err := gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;user:password@/dbname?charset=utf8&amp;amp;parseTime=True&amp;amp;loc=Local&amp;quot;)
  defer db.close()
  //db, err := gorm.Open(&amp;quot;postgres&amp;quot;, &amp;quot;host=myhost user=gorm dbname=gorm sslmode=disable password=mypassword&amp;quot;)
  //defer db.Close()
  //db, err := gorm.Open(&amp;quot;sqlite3&amp;quot;, &amp;quot;/tmp/gorm.db&amp;quot;)
  //defer db.Close()
  //db, err = gorm.Open(&amp;quot;mssql&amp;quot;, &amp;quot;sqlserver://username:password@localhost:1433?database=dbname&amp;quot;)
  //defer db.Close()
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建表&#34;&gt;&lt;strong&gt;创建表&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;首先我们来看看如何建立一个和数据库关联的struct&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
type Category struct {
	Name        string `gorm:&amp;quot;primary_key&amp;quot;`
	Description string `gorm:&amp;quot;size:255;default:&#39;nothing in here&#39;&amp;quot;`
}

type Email struct {
	ID         int
	UserId     int
	Email      string `gorm:&amp;quot;type:varchar(100);unique_index&amp;quot;`
	Subscribed bool
}

type Origin struct {
	ID        int
	ProductID uint
	Address1  string `gorm:&amp;quot;not null;unique&amp;quot;`
	Address2  string `gorm:&amp;quot;unique&amp;quot;`
}

type Language struct {
	ID   int
	Name string `gorm:&amp;quot;index:idx_name_code&amp;quot;`
	Code string `gorm:&amp;quot;index:idx_name_code&amp;quot;`
}

type Product struct {
	gorm.Model
	Name string `gorm:&amp;quot;index;size:255&amp;quot;`

	Sid         int        `gorm:&amp;quot;unique_index&amp;quot;`
	Categories  []Category `gorm:&amp;quot;many2many:categories_product;&amp;quot;`
	Emails      []Email    `gorm:&amp;quot;ForeignKey:UserId&amp;quot;`
	Origin      *Origin
	Languages   []Language
	Score       *float64 `gorm:&amp;quot;not null;default:1.0&amp;quot;`
	Description string   `gorm:&amp;quot;size:255;default:&#39;nothing in here&#39;&amp;quot;`
}

type GreekAlphabet struct {
	ID         uint   `gorm:&amp;quot;primary_key&amp;quot;`
	LatinName  string `gorm:&amp;quot;unique_index&amp;quot;`
	UpperCode  rune
	LowerCode  rune
	IsFrequent bool `gorm:&amp;quot;index&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gorm会go的类型自动转成数据库类型，也可以通过type指定数据库类型
以下是默认情况下go类型和数据库类型对照(这里用postgres举例)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;go类型&lt;/th&gt;
&lt;th&gt;数据库类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;uint&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int8-32&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;uint8-32&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;time.Time&lt;/td&gt;
&lt;td&gt;timestamp&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;float32&lt;/td&gt;
&lt;td&gt;numeric&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;float64&lt;/td&gt;
&lt;td&gt;numeric&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;特殊的数组类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用数组类型 默认会当成是一对多模式,可以通过tag修改关系
在一对多模式下，使用数组类型中的类型必须是对应另一个数据表的struct,并且对象struct中要包含名字为&lt;strong&gt;当前表名+ID&lt;/strong&gt;的字段，该字段类型最好对应当前表的primary_key类型&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我们看看Product包含了匿名字段gorm.Model，以下类型都有特殊含义&lt;/p&gt;

&lt;p&gt;gorm会在创建和修改，删除时自动填充CreatedAt和UpdatedAt，DeletedAt时自动填充字段值&lt;/p&gt;

&lt;p&gt;在gorm中匿名struct中的字段中的Field都会被继承，所以&lt;strong&gt;你也可以像gorm.Model这样把常用字段抽象成一个struct&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ID字段也是默认被当成primary_key的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package gorm

...

type Model struct {
	ID        uint `gorm:&amp;quot;primary_key&amp;quot;`
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt *time.Time `sql:&amp;quot;index&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gorm的一大特性就是能用struct的tag来指定栏属性，以下是gorm tag的关键字意义&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;通用&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;索引&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;index:key_name&lt;/td&gt;
&lt;td&gt;自定义索引名，但2个索引名相同时变为组合索引&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unique_index&lt;/td&gt;
&lt;td&gt;唯一索引，组合索引的方法同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;primary_key&lt;/td&gt;
&lt;td&gt;建立主键，组合的方法同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;not null&lt;/td&gt;
&lt;td&gt;指定类型的值不能为空(注意这个not null只是数据库中能否为nil和数据值是否为空没有关系，string一样可以取&amp;rdquo;&amp;ldquo;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;忽略该字段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;数据类型&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;many2many:must_key_name&lt;/td&gt;
&lt;td&gt;建立多对多的关系，需要声明多对多的表名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ForeignKey:must_key_name&lt;/td&gt;
&lt;td&gt;指定外键名(外键名必须是对应struct的所拥有的字段名)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;字符串类型&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;size:255&lt;/td&gt;
&lt;td&gt;指定长度，一般用于字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;type:varchar(100)&lt;/td&gt;
&lt;td&gt;指定类型，不同类型函数的参数不一样&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;整数字段&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AUTO_INCREMENT&lt;/td&gt;
&lt;td&gt;自动增长&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后通过db.CreateTable在数据库中创建对应的数据库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;tables := []interface{}{&amp;amp;Category{}, &amp;amp;Email{}, &amp;amp;Origin{}, &amp;amp;Language{}, &amp;amp;Product{}}
db.DropTableIfExists(tables...)
db.CreateTable(tables...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们可以在数据库看到表的create statement(因为postgres的语法太罗嗦了，所以这里用sqlite举例)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sqlite&#34;&gt;CREATE TABLE &amp;quot;categories&amp;quot; (&amp;quot;name&amp;quot; varchar(255),&amp;quot;description&amp;quot; varchar(255) DEFAULT &#39;nothing in here&#39; , PRIMARY KEY (&amp;quot;name&amp;quot;))
CREATE TABLE &amp;quot;categories_product&amp;quot; (&amp;quot;product_id&amp;quot; integer,&amp;quot;category_name&amp;quot; varchar(255), PRIMARY KEY (&amp;quot;product_id&amp;quot;,&amp;quot;category_name&amp;quot;))
CREATE TABLE &amp;quot;emails&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;user_id&amp;quot; integer,&amp;quot;email&amp;quot; varchar(100),&amp;quot;subscribed&amp;quot; bool )
CREATE TABLE &amp;quot;languages&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;name&amp;quot; varchar(255),&amp;quot;code&amp;quot; varchar(255) )
CREATE TABLE &amp;quot;origins&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;product_id&amp;quot; integer,&amp;quot;address1&amp;quot; varchar(255) NOT NULL UNIQUE,&amp;quot;address2&amp;quot; varchar(255) UNIQUE )
CREATE TABLE &amp;quot;products&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;created_at&amp;quot; datetime,&amp;quot;updated_at&amp;quot; datetime,&amp;quot;deleted_at&amp;quot; datetime,&amp;quot;name&amp;quot; varchar(255),&amp;quot;sid&amp;quot; integer,&amp;quot;score&amp;quot; real NOT NULL  DEFAULT 1.0,&amp;quot;description&amp;quot; varchar(255) DEFAULT &#39;nothing in here&#39; )
CREATE TABLE &amp;quot;greek_alphabets&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;latin_name&amp;quot; varchar(255),&amp;quot;upper_code&amp;quot; integer,&amp;quot;lower_code&amp;quot; integer,&amp;quot;is_frequent&amp;quot; bool )
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建数据&#34;&gt;&lt;strong&gt;创建数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;创建数据比创建表简单多了，我们只需要把数据填入结构体，然后通过db.Create(interface{})来初始化,像这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;categories := []Category{
	Category{&amp;quot;mobile phone&amp;quot;, &amp;quot;a hand-held mobile radiotelephone for use in an area divided into small sections, each with its own short-range transmitter/receiver&amp;quot;},
	Category{&amp;quot;apple&amp;quot;, &amp;quot;&amp;quot;},
}
emails := []Email{Email{Email: &amp;quot;example@domain.com&amp;quot;, Subscribed: false}}
origin := Origin{Address1: &amp;quot;apple company address&amp;quot;, Address2: &amp;quot;test&amp;quot;}
languages := []Language{Language{Name: &amp;quot;中国&amp;quot;, Code: &amp;quot;cn&amp;quot;}, Language{Name: &amp;quot;美国&amp;quot;, Code: &amp;quot;us&amp;quot;}}
score := float32(0.0)
product := Product{
	Name:       &amp;quot;iphone7&amp;quot;,
	Sid:        1211,
	Categories: categories,
	Emails:     emails,
	Origin:     &amp;amp;origin,
	Languages:  languages,
	Score:      &amp;amp;score,
}
err := db.Create(&amp;amp;product).Error
if err != nil {
	t.Error(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信细心的人已经注意到，我在创建Product时Score字段设为指针，这是因为gorm在创建表时会自动把所有为0值的值忽略(0值的定义可以看&lt;a href=&#34;https://golang.org/ref/spec#The_zero_value&#34;&gt;go的介绍&lt;/a&gt;),而Score又设置了默认值为1.0。&lt;/p&gt;

&lt;p&gt;也就是说，&lt;strong&gt;如果Score如果不是指针字段，它将永远没法设置为0值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个规则在下面的查询，插入和更新中也会有，在创建struct时一定要注意这些细节&lt;/p&gt;

&lt;h4 id=&#34;查询数据&#34;&gt;&lt;strong&gt;查询数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;为了方便查询，我们这里增加几条数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;categories := []Category{
	Category{&amp;quot;mobile phone&amp;quot;, &amp;quot;a hand-held mobile radiotelephone for use in an area divided into small sections, each with its own short-range transmitter/receiver&amp;quot;},
	Category{&amp;quot;xiaomi&amp;quot;, &amp;quot;&amp;quot;},
}
emails := []Email{Email{Email: &amp;quot;example2@domain.com&amp;quot;, Subscribed: false}}
origin := Origin{Address1: &amp;quot;xiaomi company address&amp;quot;, Address2: &amp;quot;&amp;quot;}
languages := []Language{Language{Name: &amp;quot;中国&amp;quot;, Code: &amp;quot;cn&amp;quot;}}
score := float32(2.0)
product := Product{
	Name:       &amp;quot;xiaomi6&amp;quot;,
	Sid:        1311,
	Categories: categories,
	Emails:     emails,
	Origin:     &amp;amp;origin,
	Languages:  languages,
	Score:      &amp;amp;score,
}
err := db.Create(&amp;amp;product).Error
if err != nil {
	t.Error(err)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;categories := []Category{
  Category{&amp;quot;food&amp;quot;, &amp;quot; sth solid for eating&amp;quot;},
  Category{&amp;quot;meat&amp;quot;, &amp;quot;&amp;quot;},
}
emails := []Email{Email{Email: &amp;quot;example3@domain.com&amp;quot;, Subscribed: false}}
origin := Origin{Address1: &amp;quot;163 company address&amp;quot;, Address2: &amp;quot;163 company address2&amp;quot;}
languages := []Language{Language{Name: &amp;quot;中国&amp;quot;, Code: &amp;quot;cn&amp;quot;}}
score := float32(3.0)
product := Product{
  Name:       &amp;quot;wild boar meat&amp;quot;,
  Sid:        9999,
  Categories: categories,
  Emails:     emails,
  Origin:     &amp;amp;origin,
  Languages:  languages,
  Score:      &amp;amp;score,
}
err := db.Create(&amp;amp;product).Error
if err != nil {
  t.Error(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Where查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果我想查询Product.Name = &amp;ldquo;xiaomi6&amp;rdquo;，可以这样写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
// 因为我知道xiaomi6只有一个结果，所以直接这样写
db.Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where这里的参数和上面Create中提到的规则一样，为空值的字段不会被当成查询条件，所以想查询比如Score为0，字段必须是指针字段&lt;/p&gt;

&lt;p&gt;First就是获取第一个查询结果，下面会讲到&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First函数就是获取第一个查询的结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
db.First(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对的查询最后一个结果,用Last函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
db.Last(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里说明一点，这里调用Last和First所需要的product指针最好是一个内容为空的对象，因为若product.ID不为空，则只会把对象更新为该ID对应的对象，若其他字段不为空就有可能污染查询到的结果&lt;/p&gt;

&lt;p&gt;查询全部则用Find&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var products []Product
db.Find(&amp;amp;products)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gorm默认不会查询外键对象，如果想把结构体字段的内容也查询出来，可以使用Preload函数预加载这个结构体,像下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
db.Preload(&amp;quot;Origin&amp;quot;).Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然可以查出Origin字段的数据，不过却使用到了字符串，这样也导致人为拼写错误的可能和增加维护成本，我们可以使用go的反射来解决这个问题，这里就不细说了&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;更新数据&#34;&gt;&lt;strong&gt;更新数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Save&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Save更新不会忽略0值，但每次只能更新一条数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var xiaomi Product
db.Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;xiaomi)
xiaomi.Sid = 0
db.Save(&amp;amp;xiaomi)
var product Product
db.Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;product)
//查看product有无更新成功
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用Updates可以进行批量更新，空值依然会被忽略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;db.Model(&amp;amp;Product{}).Updates(&amp;amp;Product{Description: &amp;quot;also nothing here&amp;quot;})
products := []Product{}
db.Find(&amp;amp;products)
for _, p := range products {
	t.Log(p.Name, p.Description)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;删除数据&#34;&gt;&lt;strong&gt;删除数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;删除数据时要保证被删除数据的主键不能为空，不然会吧整个表的数据都删掉&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var meat Product
db.Where(&amp;amp;Product{Name: &amp;quot;wild boar meat&amp;quot;}).First(&amp;amp;meat)

var product Product
db.Where(&amp;amp;Product{Name: &amp;quot;wild boar meat&amp;quot;}).First(&amp;amp;product)
// 这时查到的product应该为空
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为product中包含DeleteAt字段，所以并不会数据并不会真的被删除，只是设置了DeleteAt为当前时间&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;如果数据表没有DeletedAt字段，那么调用Delete会物理删除数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var email Email
db.First(&amp;amp;email)
id := email.ID
db.Delete(&amp;amp;email)
// 打印id
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;支持多种sql数据库&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持struct到数据表的映射&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;知道struct tag的到字段属性的映射&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持Scope自定义操作，以补充该库功能上的不足(以后会讲到)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;受限于go的struct，在gorm的查询无法查询0值，而使用指针会让结构体变的异常丑陋&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;条件查询,嵌套查询等操作还是要借助字符串表达式&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说gorm还是一个不错orm,用来做简单数据的增删改查还是非常方便，在日常请求的逻辑处理基本是够用的&lt;/p&gt;

&lt;h4 id=&#34;链接&#34;&gt;&lt;strong&gt;链接&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://jinzhu.me/gorm/&#34;&gt;gorm官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bigpigeon/Test/tree/master/go/gorm_demo&#34;&gt;测试代码地址&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git错误push与回滚</title>
      <link>https://bigpigeon.org/post/git-push-recover-way/</link>
      <pubDate>Thu, 09 Mar 2017 09:44:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/git-push-recover-way/</guid>
      <description>&lt;p&gt;之前看漏眼把一个zip的文件commit了,然后我又不小心push到远程gitlab上,导致项目直接大了10M。于是我查了下git的资料，发现可以用删除分支来解决这个问题,下面我来讲讲做法&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;本地处理&#34;&gt;本地处理&lt;/h3&gt;

&lt;p&gt;首先需要把checkout到错误分支的前一个分支(假设我的分支名为bate)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout bate^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后checkout到新的分支上,并把正确的文件提交过来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b bate-recover
git checkout bate - file.xx
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后删除bate分支并提交,因为bate分支没合并所以需要强制删除，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch -D bate
git push origin bate --delete
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后把bate-recover分支checkout到bate上再提交，完成！！！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b bate
git push origin bate
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;已pull项目处理&#34;&gt;已pull项目处理&lt;/h3&gt;

&lt;p&gt;如果某个服务器不小心pull了这个带zip文件的分支同样需要删除分支:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 首先checkout到其他分支
git checkout master
# 删除bate分支
git branch -D bate
# 重新pull bate分支
git pull origin bate
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>我的翻墙技术栈</title>
      <link>https://bigpigeon.org/post/my-skip-gfw-stack/</link>
      <pubDate>Tue, 27 Dec 2016 17:07:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/my-skip-gfw-stack/</guid>
      <description>&lt;p&gt;谈到翻墙，很多人第一时间想到的就是shdowsocks，虽然简单的搭建一个shadowsocks服务就可以实现翻墙，不过很快你就会发现代理的速度并不理想，而且有时会发生长时间无法链接的情况。&lt;/p&gt;

&lt;p&gt;这是因为网络有的错误丢包被当成拥塞丢包，所以发送窗口一直没法增大。&lt;/p&gt;

&lt;p&gt;linux kernel 4.9支持BBR拥塞控制算法可以解决这个问题&lt;/p&gt;

&lt;p&gt;也可以通过其他协议工具比如:&lt;a href=&#34;https://github.com/xtaci/kcptun&#34;&gt;kcptun&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;kcptun可以提供双边加速和窗口控制，效果可能比bbr好&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;服务端&#34;&gt;服务端&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;机器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一定要买一台国外的机器(不然翻个毛墙啊),节点推荐日本的(因为地理位置比较近)&lt;/p&gt;

&lt;p&gt;我这里用的是&lt;a href=&#34;https://www.vultr.com/&#34;&gt;vultr&lt;/a&gt;的vps节点是选的日本机房,用这个&lt;a href=&#34;http://www.vultr.com/?ref=7049331-3B&#34;&gt;优惠码&lt;/a&gt;注册可以获取20$抵用现金，推荐&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;操作系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;red hat/centos或者debain/ubuntu 均可&lt;/p&gt;

&lt;p&gt;这是我的操作系统版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /proc/version
Linux version 3.10.0-327.28.3.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.3 20140911 (Red Hat 4.8.3-9) (GCC) ) #1 SMP Thu Aug 18 19:05:49 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装软件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我推荐使用go版本的kcptun和shadowsocks,这样部署和维护都比较方便(如果使用bbr可以忽略kcptun部分,开启bbr可以看&lt;a href=&#34;https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95&#34;&gt;这里&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 下载并解压go的二进制包
wget https://storage.googleapis.com/golang/go1.7.4.linux-amd64.tar.gz
tar -xf go1.7.4.linux-amd64.tar.gz
# 把文件移到库文件夹并创建连接
mv go /usr/local/lib/
ln -s /usr/local/lib/go/bin/* /usr/local/bin/
# 增加go的第三方安装包文件并把go的环境变量加入profile
mkdir /usr/local/lib/go/packages


vim /etc/profile.d/go.sh
# 把一下内容复制进去
export GOROOT=/usr/local/lib/go
export GOPATH=$GOROOT/packages
export PATH=$GOPATH/bin:$PATH

# 加载环境变量
. /etc/profile.d/go.sh

# 安装shadowsocks和kcptun
go get github.com/xtaci/kcptun/server
go get github.com/shadowsocks/shadowsocks-go

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置shadowsocks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;shadowsocks配置文件格式是json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/shadowsocks.json
# 把下面的json数据复制进去
{
  &amp;quot;server&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;method&amp;quot;: &amp;quot;aes-256-cfb&amp;quot;,
  &amp;quot;port_password&amp;quot;: {
    &amp;quot;5501&amp;quot;: &amp;quot;your password&amp;quot;
  },
  &amp;quot;timeout&amp;quot;: 300
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://shadowsocks.org/en/config/advanced.html&#34;&gt;可以通过修改服务端内核参数提升shadowsocks的发包效率&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用supervisor管理进程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安装supervisor(没有pip自行想办法)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置supervisor.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/supervisor.conf
# 把以下内容复制进去
; supervisor config file

[unix_http_server]
file=/var/run/supervisor.sock   ; (the path to the socket file)
chmod=0700                       ; sockef file mode (default 0700)

[supervisord]
logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)
pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)
childlogdir=/var/log/supervisor            ; (&#39;AUTO&#39; child log dir, default $TEMP)

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket

; The [include] section can just contain the &amp;quot;files&amp;quot; setting.  This
; setting can list multiple files (separated by whitespace or
; newlines).  It can also contain wildcards.  The filenames are
; interpreted as relative to this file.  Included files *cannot*
; include files themselves.

[include]
files = /etc/supervisor.d/*.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置kcptun和shadowsocks&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 如果没有创建该文件夹
mkdir /etc/supervisor.d

vim /etc/supervisor.d/proxy.ini
# 把以下内容复制进去
[program:shadowsocks]
directory=/usr/lib/go/packages/bin
command=/usr/lib/go/packages/bin/shadowsocks-server -c /etc/shadowsocks.json
user=root
process_name=%(program_name)s
numprocs=1
autostart=true
autorestart=true
stdout_logfile=/var/log/shadowsocks.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=2
redirect_stderr=true

[program:kcptun]
directory=/usr/lib/go/packages/bin
command=/usr/lib/go/packages/bin/server -t &amp;quot;127.0.0.1:5501&amp;quot; -l &amp;quot;:5501&amp;quot; -mode fast2 --crypt aes-128
user=root
process_name=%(program_name)s
numprocs=1
autostart=true
autorestart=true
stdout_logfile=/var/log/kcptun.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=2
redirect_stderr=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动supervisor&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;supervisord -c /etc/supervisor.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;iptables的filter表配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你的服务器有配iptables，那可能要增加一下规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -I INPUT -p udp -m udp --dport 5501 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把新的配置加入开机启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables-save &amp;gt; /etc/iptables.rule

vim /etc/rc.local
# 在新的一行中添加以下内容
/sbin/iptables-restore &amp;lt; /etc/iptables.rule

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;客户端配置&#34;&gt;客户端配置&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;kcptun客户端&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用bbr可以忽略这部分&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://github.com/xtaci/kcptun/releases/tag/v20161222&#34;&gt;https://github.com/xtaci/kcptun/releases/tag/v20161222&lt;/a&gt; 中下载对应的版本&lt;/p&gt;

&lt;p&gt;启动客户端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;client_darwin_amd64 -r &amp;quot;服务器IP地址:5501&amp;quot; -l &amp;quot;:8388&amp;quot; -mode fast2 --crypt aes-128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;shadowsocks客户端&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;windows的&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-windows/releases&#34;&gt;下载页面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mac OS X的&lt;a href=&#34;https://github.com/shadowsocks/ShadowsocksX-NG/releases&#34;&gt;下载页面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;linux桌面版本的&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation&#34;&gt;下载页面&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;编辑config.json,把以下内容复制进去保存,并把这个文件导入shadowsocks(使用bbr时server和server_port填服务器地址和端口号)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;configs&amp;quot;: [
        {
            &amp;quot;method&amp;quot;: &amp;quot;aes-256-cfb&amp;quot;,
            &amp;quot;password&amp;quot;: &amp;quot;your password&amp;quot;,
            &amp;quot;remarks&amp;quot;: &amp;quot;public_vultr&amp;quot;,
            &amp;quot;server&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
            &amp;quot;server_port&amp;quot;: 8388
        }
    ],
    &amp;quot;localPort&amp;quot;: 1080,
    &amp;quot;shareOverLan&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用SwitchyOmega为chrome代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在chrome商店或者&lt;a href=&#34;https://github.com/FelisCatus/SwitchyOmega/releases&#34;&gt;这里&lt;/a&gt;下载SwitchyOmega&lt;/p&gt;

&lt;p&gt;下载的插件拖入chorme即可安装&lt;/p&gt;

&lt;p&gt;在下载SwitchyOmega设置中增加一个pac profile,并在pac script中加入以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var domains = [
    &amp;quot;google.com&amp;quot;,
    &amp;quot;facebook.com&amp;quot;,
    &amp;quot;twitter.com&amp;quot;,
    &amp;quot;google.co.jp&amp;quot;,
    &amp;quot;gmail.com&amp;quot;,
    &amp;quot;golang.org&amp;quot;,
    &amp;quot;github.com&amp;quot;,
    &amp;quot;s3.amazonaws.com&amp;quot;,
    &amp;quot;twimg.com&amp;quot;,
    &amp;quot;wikipedia.org&amp;quot;,
    &amp;quot;youtube.com&amp;quot;,
    &amp;quot;gstatic.com&amp;quot;,
    &amp;quot;stackoverflow.com&amp;quot;,
    &amp;quot;shadowsocks.org&amp;quot;

];
var domain_dict = {};
for(var i = 0; i &amp;lt; domains.length; i++){
    if(domains[i].endsWith(&amp;quot;.&amp;quot;)){
        domains[i] = domains[i].slice(0, -1)
    }
    var url_list = domains[i].split(&#39;.&#39;);

    var domain_node = domain_dict;
    for(var j = url_list.length; j &amp;gt; 0; j--){
        var node_name = url_list[j-1];
        if (!domain_node.hasOwnProperty(node_name)){
            if (j === 1){
                domain_node[node_name] = true;
                break;
            } else {
                domain_node[node_name] = {};
            }
        } else if(domain_node[node_name] === true) {
            break;
        }
        domain_node = domain_node[node_name];
    }
}

var proxy = &amp;quot;SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT&amp;quot;;

var direct = &#39;DIRECT;&#39;;

function FindProxyForURL(url, host) {
    if( host == &amp;quot;localhost&amp;quot; ||
        host == &amp;quot;127.0.0.1&amp;quot;) {
        return direct;
    }
    var host_list = host.split(&#39;.&#39;)
    var domain_node = domain_dict
    for(var i = host_list.length; i &amp;gt; 0; i--){
        var node_name = host_list[i-1]
        if (domain_node.hasOwnProperty(node_name)){
            if(domain_node[node_name] === true){
                return proxy;
            } else {
                domain_node = domain_node[node_name]
            }

        }
        else {
            return direct;
        }
    }
    return direct;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pac用的是javascript语法，需要代理的域名只要加入domains即可&lt;/p&gt;

&lt;p&gt;父域名会自动匹配所有子域名,比如domains中加入google.com 那www.google.com map.google.com的内容都会被代理&lt;/p&gt;

&lt;p&gt;关于这份pac的更多内容可以看&lt;a href=&#34;https://bigpigeon.org/post/switchy-proxy-pac-optimization&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>从jekyll到hugo，搬运经验总结</title>
      <link>https://bigpigeon.org/post/jekyll-to-hugo/</link>
      <pubDate>Wed, 12 Oct 2016 11:43:37 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/jekyll-to-hugo/</guid>
      <description>&lt;p&gt;因为我对新技术的热爱和向往，我选择博客从jekyll换成hugo了，本来是想记录一下他们之间区别，搬运完才发现它们在功能上竟然是如此的相识,所以我只能讲jekyll如何搬运到hugo.&lt;/p&gt;

&lt;p&gt;hugo和jekyll一样也是静态页面框架，有着和jekyll相似文件结构和配置方法，不过hugo有着更快的生成速度和更好的markdown引擎，支持toml,yaml,json配置文件格式，hugo又从hexo中借鉴了不少特性,比如live reload。而且hugo是go开发的，模板语法中能找到go语言的影子，这也是我使用它的主要原因。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;如何安装&#34;&gt;如何安装&lt;/h3&gt;

&lt;p&gt;先下载&lt;a href=&#34;https://golang.org/dl/&#34;&gt;go&lt;/a&gt;，然后配置GOPATH环境变量，通过&lt;strong&gt;go get&lt;/strong&gt;命令下载的包都会放到GOPATH中，在GOPATH中的包也可以被其他包import&lt;/p&gt;

&lt;p&gt;然后配置PATH,这样通过go安装的命令可以被直接执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=$GOPATH/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装&lt;a href=&#34;https://github.com/spf13/hugo&#34;&gt;hugo&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果下载超时可以尝试挂代理，设置http_proxy和https_proxy就可以使用http(s)代理,如果是socket代理，建议用&lt;a href=&#34;http://www.delegate.org/delegate/&#34;&gt;delegate&lt;/a&gt;转成http(s)代理&lt;/p&gt;

&lt;h3 id=&#34;创建第一个博客&#34;&gt;创建第一个博客&lt;/h3&gt;

&lt;p&gt;hugo可以通过下面的命令快速构建一个hugo的文件结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new site firstblog
Congratulations! Your new Hugo site is created in &amp;quot;/data/work/firstblog&amp;quot;.

Just a few more steps and you’re ready to go:

1. Download a theme into the same-named folder.
   Choose a theme from https://themes.gohugo.io/, or
   create your own with the &amp;quot;hugo new theme &amp;lt;THEMENAME&amp;gt;&amp;quot; command.
2. Perhaps you want to add some content. You can add single files
   with &amp;quot;hugo new &amp;lt;SECTIONNAME&amp;gt;/&amp;lt;FILENAME&amp;gt;.&amp;lt;FORMAT&amp;gt;&amp;quot;.
3. Start the built-in live server via &amp;quot;hugo server&amp;quot;.

Visit https://gohugo.io/ for quickstart guide and full documentation.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看文件结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tree firstblog
firstblog/
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes

6 directories, 1 file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看看各个文件夹的作用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;archetypes&lt;/strong&gt;: 允许自定义post front matter(就是见面开头+++那部分)，并且会在hugo new 时给默认值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;config.toml&lt;/strong&gt;: 主配置文件，hugo也支持也可以使用yaml和json格式，不过默认以config.toml为主配置文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;content&lt;/strong&gt;: 博客的文章，关于，demo等内容都放在这个目录下，使用&lt;strong&gt;hugo new&lt;/strong&gt;命令创建的文件会存放在这个目录下，你可以定义不同的子目录作为sections,文章的默认sections是post&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;data&lt;/strong&gt;: 这个目录存放一个用于生成网站的数据，你可以使用YAML,JSON或者TOML格式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;layouts&lt;/strong&gt;: 用来存放html模板，这些模板将决定你网页的布局，更详细的内容可以查看&lt;a href=&#34;https://gohugo.io/templates/overview/&#34;&gt;templates&lt;/a&gt;章节&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;static&lt;/strong&gt;: 存放网站静态文件的目录，在网站生成后会将该目录的文件放到网站的根目录下，不要和content下的文件有重名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;themes&lt;/strong&gt;: 存放主题，建议用主题来决定网站的风格样式，网站只存放内容&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后按照提示我们去&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;https://themes.gohugo.io/&lt;/a&gt; 找一个主题，并把它下载到
themes目录中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd firstblog/themes
$ git clone https://github.com/fredrikloch/hugo-uno.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改config.toml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;$ cd firstblog
firstblog/$ cat config.toml
baseurl = &amp;quot;http://replace-this-with-your-hugo-site.com/&amp;quot;
title = &amp;quot;My blog&amp;quot;
languageCode = &amp;quot;en-us&amp;quot;
theme = &amp;quot;hugo-uno&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一篇新的文章&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd firstblog
$ hugo new post/start.md
/data/work/firstblog/content/post/start.md created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在content文件夹中找到你刚刚创建的markdown文件然后编辑，编辑好后就可以通过&lt;strong&gt;hugo server&lt;/strong&gt;运行了，然后在本地访问&lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; 就可以看到你的网站了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd firstblog
$ hugo server
Started building sites ...
Built site for language en:
0 draft content
0 future content
0 expired content
1 pages created
0 non-page files copied
0 paginator pages created
2 categories created
2 tags created
total in 34 ms
Watching for changes in /data/work/firstblog/{data,content,layouts,static,themes}
Serving pages from memory
Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)
Press Ctrl+C to stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常见问题&#34;&gt;常见问题&lt;/h3&gt;

&lt;h4 id=&#34;分页问题&#34;&gt;&lt;strong&gt;分页问题&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在模板中使用.Paginate，该页面就会被自动分页
比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;!--拿到当前分页--&amp;gt;
    {{ $paginator := .Paginate (where .Data.Pages &amp;quot;Section&amp;quot; &amp;quot;post&amp;quot;) }}
    ...
    &amp;lt;!--读取分页内容--&amp;gt;
    {{ range $paginator.Pages }}

        {{ .Render &amp;quot;summary&amp;quot;}}
    ...
    {{ end }}
    ...
    &amp;lt;!--增加翻页按钮--&amp;gt;
    {{ if $paginator.HasPrev}}
    &amp;lt;a href=&amp;quot;{{ $paginator.Prev.URL }}&amp;quot;&amp;gt;上一页&amp;lt;/a&amp;gt;
    {{ else }}
    &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
    {{ end }}
    &amp;lt;a href=&amp;quot;{{ .Site.BaseURL }}/post/&amp;quot;&amp;gt;归档&amp;lt;/a&amp;gt;
    {{ if $paginator.HasNext }}
    &amp;lt;a href=&amp;quot;{{ $paginator.Next.URL }}&amp;quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
    {{ else }}
    &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
    {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认分页的对象数是10，可以通过在config中定义Paginate去改变分页数&lt;/p&gt;

&lt;h4 id=&#34;额外的页面&#34;&gt;&lt;strong&gt;额外的页面&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;为了让我的demo页面和文章页面分离开来，需要用到section这个功能，在上面的模板可以看到&lt;strong&gt;where .Data.Pages &amp;ldquo;Section&amp;rdquo; &amp;ldquo;post&amp;rdquo;&lt;/strong&gt;，这个语句就是取所有页面中section位post的页面，那么问题来了:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何判断这个页面是属于那个section&lt;/li&gt;
&lt;li&gt;如何为section添加展示页&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如何判断这个页面是属于那个section&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如我们一开始的是用&lt;strong&gt;hugo new post/start.md&lt;/strong&gt;创建页面的section就是post&lt;/p&gt;

&lt;p&gt;也就是在content中的子文件夹名就是section名，比如我要在网站增加一个名为demo的section&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new demo/first.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时访问&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/demo/first&#34;&gt;http://localhost:1313/demo/first&lt;/a&gt;&lt;/strong&gt;就可以看到该页面了，这个页面是由layouts/_default/single.html模板渲染的，如果你想自定义渲染的模板可以新增layouts/demo/single.html作为demo单页的渲染模板&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何为section添加展示页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在layouts/section/中添加一个html模板，模板名必须和section名一致,比如我们为demo添加一个展示页&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat &amp;gt;&amp;gt; layouts/section/demo.html &amp;lt;&amp;lt;EOF
{{ partial &amp;quot;head.html&amp;quot; . }}
    &amp;lt;!--拿到当前分页--&amp;gt;
    {{ $paginator := .Paginate (where .Data.Pages &amp;quot;Section&amp;quot; &amp;quot;demo&amp;quot;) }}
    ...
    &amp;lt;!--读取分页内容--&amp;gt;
    {{ range $paginator.Pages }}

        {{ .Render &amp;quot;summary&amp;quot;}}
    ...
    {{ end }}
    ...
    &amp;lt;!--增加翻页按钮--&amp;gt;
    {{ if $paginator.HasPrev}}
    &amp;lt;a href=&amp;quot;{{ $paginator.Prev.URL }}&amp;quot;&amp;gt;上一页&amp;lt;/a&amp;gt;
    {{ else }}
    &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
    {{ end }}
    &amp;lt;a href=&amp;quot;{{ .Site.BaseURL }}/post/&amp;quot;&amp;gt;归档&amp;lt;/a&amp;gt;
    {{ if $paginator.HasNext }}
    &amp;lt;a href=&amp;quot;{{ $paginator.Next.URL }}&amp;quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
    {{ else }}
    &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
    {{ end }}
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样访问&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/demo&#34;&gt;http://localhost:1313/demo&lt;/a&gt;&lt;/strong&gt;  就可以看到展示页了&lt;/p&gt;

&lt;p&gt;hugo还有一个summary的功能，可以让你把单页的部分内容放入展示页渲染，添加一个layouts/模板名/summary.html的模板，然后像上面的例子中那样使用&lt;strong&gt;{{ .Render &amp;ldquo;summary&amp;rdquo;}}&lt;/strong&gt;就可以把容内渲染进展示页中&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于template的使用可以翻阅&lt;a href=&#34;https://gohugo.io/templates/overview/&#34;&gt;官方文档&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Iptables学习笔记</title>
      <link>https://bigpigeon.org/post/iptables-study/</link>
      <pubDate>Tue, 28 Jun 2016 16:00:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/iptables-study/</guid>
      <description>&lt;p&gt;以前我也很抵触去配置iptables，当时我觉得iptables这种工具实在是太复杂了，配置的命令超级长，而且只有命令行没有图形化工具，而大多数云服务器都有自己的一套防火墙，比如aws的EC2就有自己的安全组，简单易用并且可以直接在网页上直接配置，非常的方便。&lt;/p&gt;

&lt;h2 id=&#34;hugomore42&#34;&gt;&lt;/h2&gt;

&lt;p&gt;但后来我接触linux运维越来越多才发现，iptables虽然缺点一大堆，但它胜在功能非常强大，并且可以满足大多数网络管理上的需求，在没有更好的代替品出现前iptables绝对是必不可少的工具。&lt;/p&gt;

&lt;p&gt;下面我就简单总结一下iptables的用途&lt;/p&gt;

&lt;h3 id=&#34;什么是iptables&#34;&gt;什么是iptables&lt;/h3&gt;

&lt;p&gt;一提到iptables大部分人想到的估计就是防火墙，但其实防火墙只是iptables的filter表部分,iptables本身还可以做NAT（NAT表）和mangle（mangle表）&lt;/p&gt;

&lt;h3 id=&#34;为什么需要iptables&#34;&gt;为什么需要iptables&lt;/h3&gt;

&lt;p&gt;iptables可以翻译成ip表，可以理解为对ip做一些处理的工具，因为iptables的这些模块，所以这个问题应该为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;为什么需要
  filter
  nat
  mangle
  raw
  security


filter很好理解，因为要防止外网非法访问

SNAT在局域网访问外网的必要工具，而DNAT则是为了把局域网的服务接出去，比如如何让docker的服务端口暴露到本机上

而mangle,raw,secrurity因为我没有接触过，所以不予评价
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;如何查看配置项&#34;&gt;如何查看配置项&lt;/h3&gt;

&lt;p&gt;查看iptables的配置可以用iptables-save [-t table]来查看完整的配置&lt;/p&gt;

&lt;p&gt;有人说可以直接用&lt;strong&gt;iptables -L&lt;/strong&gt;查看，但不建议这样做，因为&lt;strong&gt;iptables -L&lt;/strong&gt;为了格式化输出会忽略掉一些信息比如filter表中的接口信息就无法查看。&lt;/p&gt;

&lt;h3 id=&#34;如何配置表&#34;&gt;如何配置表&lt;/h3&gt;

&lt;h3 id=&#34;filter&#34;&gt;filter&lt;/h3&gt;

&lt;p&gt;filter是iptables中最常用的表,而filter默认有3个链&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;INPUT: 进入linux本机时过滤
OUTPUT: 本机送出时过滤
FORWARD: 这个是访问本机转换的封包时过滤，比如你在本机配置了DNAT或者SNAT，那些被转换后并且目的地不在本地的包不会被INPUT/OUTPUT过滤器过滤，而是就由这个规则过滤
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中最常用的就是INPUT 链，这里我用INPUT 的链做说明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -A INPUT -i eth0 -d 50.24.131.30/32 -p tcp --dport 27017 -J DROP
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-A表示append，就是把规则加到末尾，如果想加到表头可以使用-I

INPUT就是配置到INPUT这个chain

-i 就是包进入的网卡，只能在INPUT链中使用,反之-o就是包出去的网卡，只能在OUTPUT链中使用

-d表示destination,就是**目标网络ip/网域**，如果想匹配**来源Ip/网域**就用-s,但作为服务一般很少限制来源ip

-d/-s 设定支持一下几种格式:
IP : 192.168.0.1
网域: 192.168.0.0/24
xx之外可以使用 ！表示比如
-s ! 192.168.0.1表示匹配除192.168.0.1之外的ip

-p 表示协议，可选的就4种tcp,udp,icmp和all，默认就是all，只有-p等于tcp或udp时才可以使用--dport和--sport

--dport表示destination port,就是目标端口 很好理解，同理还有--sport

-J 表示操作，主要有DROP(丢弃),ACCEPT(接受),REJECT(拒绝)和LOG(记录)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DROP和REJECT的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;REJECT就是你请求过来时会告诉你拒绝消息，而DROP就是你请求过来时直接把包删掉&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预设策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当封包没有被链中的规则匹配时就会被预设策略匹配&lt;/p&gt;

&lt;p&gt;预设策略有3种，分别对应3条链,我的服务器的预设策略是这样配置的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -P INPUT   DROP
iptables -P OUTPUT  ACCEPT
iptables -P FORWARD ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;nat表也有预设策略但用的很少就不说明了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结一下iptables filter的用法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables [-A|-I INPUT|FILTER|OUTPUT ] [-i|-o 网络接口 ] [-s 源ip或网域] [-p tcp|udp [--sport 端口号或端口范围] [--dport 端口号或端口范围] all|icmp] [-d 目标ip或网域] &amp;lt;-j ACCEPT|DROP|REJECT|LOG &amp;gt;

# 预设策略的配置
iptables -P &amp;lt;INPUT|OUTPUT|FORWARD&amp;gt; &amp;lt;ACCEPT|DROP&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PS:filter中还有[-m 外挂模组]对包的内容做进一步匹配和筛选&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;nat&#34;&gt;nat&lt;/h3&gt;

&lt;p&gt;先介绍一下nat表的三个链表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)
POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)
OUTPUT：與發送出去的封包有關
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说道nat大家应该不会陌生，比如路由器的内网转外网用到的就是SNAT，而docker容器的端口转换用的就是DNAT&lt;/p&gt;

&lt;p&gt;iptables的nat表除了SNAT和DNAT外还可以进行路由，ip选择&lt;/p&gt;

&lt;p&gt;下面会介绍几种常用的配置方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SNAT&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -t nat -A POSTROUTING -s 172.19.0.0/16 ! -o docker0 -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令就是把所有源地址属于172.17.0.0/16网段, 目标接口不是docker0的数据包进行伪装&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;docker启动后会为所有network网段增加SNAT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SNAT+ip选择&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设你有好几个ip，你想选择192.168.1.210作为172.19.0.0/16网段的出口ip可以这样写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -t nat -A POSTROUTING -s 172.19.0.0/16 ! -o docker0 -j MASQUERADE --to-source 192.168.1.210

# --to-source也可以指定一定范围内的ip比如192.168.1.210-192.168.1.211
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DNAT&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-A PREROUTING ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.3:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令就是把本地的80端口和172.17.0.3的80端口进行绑定，所有源接口不是docker0的数据包都会进行DNAT然后传给172.19.0.3:80&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在docker run中用-p绑定了本地端口后，会自动增加上面一项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结一下NAT的用法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -t nat [-A|-I POSTROUTING] [--to-source ip或网域]  &amp;lt;-j MASQUERADE&amp;gt;

iptables -t nat [-A|-I PREROUTING] [--to-destination ip或网域]  &amp;lt;-j MASQUERADE&amp;gt;

# filter和nat通用参数:
[-i|-o 网络接口 ] [-s 源ip或网域] [-p tcp|udp [--sport 端口号或端口范围] [--dport 端口号或端口范围] all|icmp] [-d 目标ip或网域]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.vbird.org/linux_server/0250simple_firewall.php&#34;&gt;鳥哥私房菜 第九章 防火牆與 NAT 伺服器&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>react学习笔记</title>
      <link>https://bigpigeon.org/post/react-study/</link>
      <pubDate>Thu, 21 Apr 2016 10:43:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/react-study/</guid>
      <description>&lt;h3 id=&#34;jsx&#34;&gt;JSX&lt;/h3&gt;

&lt;p&gt;React可以使用的是独有的JSX语法,包围它的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签type值为text/babel&lt;/p&gt;

&lt;p&gt;那什么是JSX呢，JSX其实就是JS+XML,在JSX中JS和XML可以同时存在,举个简单例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = &amp;lt;div class=&amp;quot;green&amp;quot;&amp;gt;my color is green&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在JSX中这样的写法是完全合法的,这个a可以当成是一个html的element使用&lt;/p&gt;

&lt;p&gt;也可以使用react.createElement创建element&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var app = React.createElement(
    &amp;quot;div&amp;quot;, //标签名或组件对象
    {class:&amp;quot;green&amp;quot;}, //元素属性集
    &amp;quot;my color is green&amp;quot; //子元素
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;createElement的更多信息&lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html#react.createelement&#34;&gt;看这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hugomore42&#34;&gt;&lt;/h2&gt;

&lt;p&gt;于是乎，我们可以自由组合js和xml了，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var names = [&#39;Alice&#39;, &#39;Emily&#39;, &#39;Kate&#39;];
&amp;lt;div&amp;gt;
  {
    names.map(function (name) {
      return React.createElement(
         &amp;quot;div&amp;quot;, {key: names.id + name},
         &amp;quot;hello &amp;quot; + name
      )
    })
  }
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当React遇到&amp;lt;时就会用xml解析,遇到{时就用js解析&lt;/p&gt;

&lt;h3 id=&#34;render&#34;&gt;render&lt;/h3&gt;

&lt;p&gt;刚才创建的element怎么运用到html中呢,这里就需要用到react的ReactDOM.render函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;把a元素加入到id为example的元素中&lt;/li&gt;
&lt;li&gt;a可以是一个html标签，也可以是组件对象&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;ReactDOM.render(
	a, //标签名或组件对象
	document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;组件&#34;&gt;组件&lt;/h3&gt;

&lt;p&gt;组件就像是一个会动的element,它有自己的方法和状态,并且可以通过一些内置函数控制element的行为.&lt;/p&gt;

&lt;p&gt;可以拿它和c++的类做类比, 赋予的值就是类名,this.props中的就是类的初始化参数,&lt;Message name=&#34;pigeon&#34;/&gt;就是实例化一个类&lt;/p&gt;

&lt;p&gt;先来看看如何创建和使用一个组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Message = React.createClass({
  render: function() {
    return &amp;lt;div&amp;gt;Hello {this.props.name}&amp;lt;/div&amp;gt;;
  }
});

ReactDom.render(
  &amp;lt;Message name=&amp;quot;pigeon&amp;quot;/&amp;gt;,
  document.getElementById(&#39;example&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;propTypes方法可以强制指定属性类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面该例子将会在浏览器画一个矩形,并且指定x和y属性的类型必须为数字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Box = React.createClass({
    propTypes: {
      x: React.PropTypes.number.isRequired,
      y: React.PropTypes.number.isRequired,
    },
    render: function() {
      return &amp;lt;svg&amp;gt;&amp;lt;rect width={this.props.x} height={this.props.y} /&amp;gt;&amp;lt;/svg&amp;gt;
    }
});
ReactDOM.render(
    &amp;lt;Box x={100} y={100}/&amp;gt;,
    document.body
)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;getDefaultProps可以为属性设置默认值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面圆形中的边会变成为绿色&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Circle = React.createClass({
    getDefaultProps : function() {
        return {
            stroke: &amp;quot;green&amp;quot;,
            fill: &amp;quot;yellow&amp;quot;
        }
    },
    render: function() {
        return (
        &amp;lt;svg&amp;gt;
        &amp;lt;circle cx=&amp;quot;50&amp;quot; cy=&amp;quot;50&amp;quot; r={this.props.r} stroke={this.props.stroke} strokeWidth=&amp;quot;4&amp;quot; fill={this.props.fill} /&amp;gt;
        &amp;lt;/svg&amp;gt;);
    }

});
ReactDOM.render(
    &amp;lt;Circle r={50} fill=&amp;quot;red&amp;quot;/&amp;gt;,
    document.getElementById(&amp;quot;example&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;获取真实的DOM节点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;组件并不是真实的DOM,
有时候需要获取真实DOM就必须用到ref属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var MyComponent = React.createClass({
  handleClick: function() {
    this.refs.myTextInput.focus();
  },
  render: function() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; ref=&amp;quot;myTextInput&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Focus the text input&amp;quot; onClick={this.handleClick} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});

ReactDOM.render(
  &amp;lt;MyComponent /&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;组件拥有状态，状态和属性的区别在于，属性表示那些不变的值，而状态会和用户交互&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Circle = React.createClass({
    getInitialState: function() {
        return {fill: &amp;quot;pink&amp;quot;}
    },
    handleClick: function(event) {
        if(this.state.fill === &amp;quot;pink&amp;quot;) {
            this.setState({fill: &amp;quot;blue&amp;quot;});
        } else {
            this.setState({fill: &amp;quot;pink&amp;quot;});
        }
    },
    getDefaultProps : function() {
        return {
            stroke: &amp;quot;green&amp;quot;,
        }
    },
    render: function() {
        return (
            &amp;lt;svg&amp;gt;
                &amp;lt;circle cx=&amp;quot;50&amp;quot; cy=&amp;quot;50&amp;quot; r={this.props.r} stroke={this.props.stroke} fill={this.state.fill} strokeWidth=&amp;quot;4&amp;quot;  onClick={this.handleClick} /&amp;gt;
            &amp;lt;/svg&amp;gt;
        );
    }
});
ReactDOM.render(
    &amp;lt;Circle r={50} /&amp;gt;,
    document.getElementById(&amp;quot;example&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;表单&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用户填入表单的数据react的组件是无法通过this.props读取的，必须通过onChange回调函数等方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var MySelect = React.createClass({
    getInitialState: function(){
      return {
          select: &amp;quot;KFC&amp;quot;
      }
    },
    change: function (event) {
        console.log(&amp;quot;chang once &amp;quot;+ event.target.value);
        this.setState({select: event.target.value});

    },
    render: function() {
        var select_value = this.state.select;
        return (
        &amp;lt;div&amp;gt;
          &amp;lt;select id=&amp;quot;lang&amp;quot; onChange={this.change} defaultValue={select_value}&amp;gt;
            &amp;lt;option value=&amp;quot;KFC&amp;quot;&amp;gt;KFC&amp;lt;/option&amp;gt;
            &amp;lt;option value=&amp;quot;mcdonald&amp;quot;&amp;gt;mcdonald&amp;lt;/option&amp;gt;
          &amp;lt;/select&amp;gt;
          &amp;lt;p&amp;gt;supper: {select_value}&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    )}
});
ReactDOM.render(
    &amp;lt;MySelect /&amp;gt;,
    document.getElementById(&amp;quot;example&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;组件有个生命周期的概念，生命周期分为3部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mounting：已插入真实 DOM
Updating：正在被重新渲染
Unmounting：已移出真实 DOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与之对应的N个函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getInitialState() 初始化state函数
componentWillMount() 当组件将被挂载
componentDidMount() 当组件挂载之后
componentWillReceiveProps(object nextProps) 当挂载的组件接收新的属性时
shouldComponentUpdate(object nextProps, object nextState): boolean  组件是否更新的callback,返回false表示不更新
componentWillUpdate(object nextProps, object nextState) 组件更新之前
componentDidUpdate(object prevProps, object prevState) 组件更新之后
componentWillUnmount() 组件卸载之前
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;一个异步请求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在请求未收到前页面会一直处于loading状态,我们通过让组件挂载后调用componentDidMount方法来异步获取github api上的数据&lt;/p&gt;

&lt;p&gt;在ajax请求完成前一直显示等待信息,ajax请求到达后通过this.setState去触发页面的重新渲染&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var MyList = React.createClass({
    getInitialState: function() {
        return {
            loading: true,
            data: null,
            error: null
        }
    },
    componentDidMount: function(){
        this.props.promise.done(
            msg =&amp;gt; {this.setState({loading: false, data:msg});}
        ).fail(
            (jqXHR, textStatus) =&amp;gt; {this.setState({loading: false, error: textStatus });}
        )
    },
    render: function () {
        if (this.state.loading) {
            return &amp;lt;span&amp;gt;loading...&amp;lt;/span&amp;gt;;
        }
        else if (this.state.error !== null) {
            return &amp;lt;span&amp;gt;Error: {this.state.error}&amp;lt;/span&amp;gt;;
        }
        else {
            var repos = this.state.data.items;
            var repoList = repos.map(function (repo){
                return (
                    &amp;lt;li&amp;gt;
                        &amp;lt;a href={repo.html_url}&amp;gt;{repo.name}&amp;lt;/a&amp;gt;
                        ({repo.stargazers_count} stars)
                        &amp;lt;br/&amp;gt;
                        {repo.description}
                    &amp;lt;/li&amp;gt;
                )
            });
            return (
                &amp;lt;main&amp;gt;
                    &amp;lt;h1&amp;gt;Most Popular JavaScript Projects in Github&amp;lt;/h1&amp;gt;
                    &amp;lt;ol&amp;gt;{repoList}&amp;lt;/ol&amp;gt;
                &amp;lt;/main&amp;gt;
            );
        }
    }
});
ReactDOM.render(
    &amp;lt;MyList promise={$.getJSON(&amp;quot;https://api.github.com/search/repositories?q=golang&amp;amp;sort=stars&amp;quot;)}/&amp;gt;,
    document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;好了-总结一下&#34;&gt;好了,总结一下&lt;/h3&gt;

&lt;p&gt;react想要把元素挂载到真实DOM上必须用&lt;strong&gt;ReactDOM.render&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该函数第一参数是想要挂载的组件或html标签&lt;/p&gt;

&lt;p&gt;第二参数则是被挂载的html标签对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;react的基本函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;createElement 创建一个html的标签
createClass 创建一个React的组件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React的组件和html标签可以互相任意嵌套&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;creactClass中有各种各样的内置函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;render 在组件被挂载或者更新时调用
getDefaultProps 设置组件默认属性值
getInitialState 设置组件默认状态值
组件生命周期 Mounting, Updating, Unmounting 发生变化前后回调的一些函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React的组件无法获取用户的交互信息,必须通过回调函数来通知组件.&lt;/p&gt;

&lt;p&gt;比如按钮点击,表单信息的修改,&lt;/p&gt;

&lt;p&gt;如果React的组件也想触发事件必须先通过this.ref获取真实的DOM,虚拟DOM是无法触发事件的&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>postgresql类型</title>
      <link>https://bigpigeon.org/post/postgresql-type/</link>
      <pubDate>Sun, 13 Mar 2016 10:30:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/postgresql-type/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;postgresql支持的类型相当的多,配合postgresql的函数就已经可以满足很多业务的需求了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;但是繁多的类型也导致了postgresql的学习成本和复杂度的问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这里我来做个笔记简单讲讲postgresql的数据类型有哪些和如何用好这些类型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PS:以下内容都基于postgresql 9.3&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TODO:有些类型的例子和介绍还没写完，以后再补上&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本类型&#34;&gt;基本类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;尺寸&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;smallint&lt;/td&gt;
&lt;td&gt;2bytes&lt;/td&gt;
&lt;td&gt;小范围的整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;td&gt;4bytes&lt;/td&gt;
&lt;td&gt;典型整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;td&gt;8bytes&lt;/td&gt;
&lt;td&gt;大范围的整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;decimal&lt;/td&gt;
&lt;td&gt;可变&lt;/td&gt;
&lt;td&gt;用户指定空间,精确分数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;numeric&lt;/td&gt;
&lt;td&gt;可变&lt;/td&gt;
&lt;td&gt;用户指定空间的精确分数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;real&lt;/td&gt;
&lt;td&gt;4bytes&lt;/td&gt;
&lt;td&gt;不精确浮点数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;double-precision&lt;/td&gt;
&lt;td&gt;8bytes&lt;/td&gt;
&lt;td&gt;不精确浮点数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;smallserial&lt;/td&gt;
&lt;td&gt;2bytes&lt;/td&gt;
&lt;td&gt;小范围自增整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;serial&lt;/td&gt;
&lt;td&gt;4bytes&lt;/td&gt;
&lt;td&gt;普通范围自增整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bigserial&lt;/td&gt;
&lt;td&gt;8bytes&lt;/td&gt;
&lt;td&gt;大范围自增整数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;金融类型&#34;&gt;金融类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;money&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8bytes&lt;/td&gt;
&lt;td&gt;货币类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;字符类型&#34;&gt;字符类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;character varying(n), varchar(n)&lt;/td&gt;
&lt;td&gt;限制内的可变长度类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;character(n), char(n)&lt;/td&gt;
&lt;td&gt;固定长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;可变长度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;二进制类型&#34;&gt;二进制类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;binary&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1-4bytes&lt;/td&gt;
&lt;td&gt;可变长度的二进制字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;时间类型&#34;&gt;时间类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;timestamp[p] [ without time zone ]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8bytes&lt;/td&gt;
&lt;td&gt;包含时间和日期但没时区&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;timestamp[p] with time zone&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8bytes&lt;/td&gt;
&lt;td&gt;包含时间日期和时区&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;date&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4bytes&lt;/td&gt;
&lt;td&gt;日期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;time [ without time zone ]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8bytes&lt;/td&gt;
&lt;td&gt;不包括日期的时间，无时区&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;time with time zone&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12bytes&lt;/td&gt;
&lt;td&gt;不包含日期的时间，有时区&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;interval&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16bytes&lt;/td&gt;
&lt;td&gt;时间区间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;布尔类型&#34;&gt;布尔类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;枚举类型&#34;&gt;枚举类型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 创建一个枚举类型并作为person表的current_mood字段
CREATE TYPE mood AS ENUM (&#39;sad&#39;, &#39;ok&#39;, &#39;happy&#39;);
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES (&#39;Moe&#39;, &#39;happy&#39;);
SELECT * FROM person WHERE current_mood = &#39;happy&#39;;
 name | current_mood
------+--------------
 Moe  | happy
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;几何学图形类型&#34;&gt;几何学图形类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;point&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;平面坐标 (x, y)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;line&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;直线 ((x1,y1), (x2,y2))&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lseg&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;线段 ((x1,y1), (x2,y2))&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;box&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一个方形盒子 ((x1,y1), (x2,y2))&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;path&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16+16n bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;闭合路径(类似于多边形) ((x1,y1),&amp;hellip;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;path&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16+16n bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;开放路径 [(x1,y1),&amp;hellip;]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;polygon&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;40+16n bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;多边形（类似于闭合路径） ((x1,y1),&amp;hellip;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;circle&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;24 bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;圆 &amp;lt;(x,y),r&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;网络地址类型&#34;&gt;网络地址类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cidr&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7 or 19 bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;ipv4或ipv6网络&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;inet&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7 or 19 bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;ipv4或ipv6地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;macaddr&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;MAC地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;比特类型&#34;&gt;比特类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;只接受2进制数&lt;/li&gt;
&lt;li&gt;有2种模式 BIT(n) 和BIT VARYING(n)
官方例子:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B&#39;101&#39;, B&#39;00&#39;);
INSERT INTO test VALUES (B&#39;10&#39;, B&#39;101&#39;);
ERROR:  bit string length 2 does not match type bit(3)
INSERT INTO test VALUES (B&#39;10&#39;::bit(3), B&#39;101&#39;);
SELECT * FROM test;
  a  |  b
-----+-----
 101 | 00
 100 | 101
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文本查询类型&#34;&gt;文本查询类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;tsvector&lt;/li&gt;
&lt;li&gt;tsquery&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;uuid-类型&#34;&gt;UUID 类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;UUID 可用来作为唯一标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;xml-类型&#34;&gt;XML 类型&lt;/h3&gt;

&lt;p&gt;xml data是用来存储xml格式的数据的，用text领域来存xml数据，想要使用该数据类型需要在安装时 configure &amp;ndash;with-libxml
- xml用text领域来存xml数据&lt;/p&gt;

&lt;h3 id=&#34;json格式&#34;&gt;json格式&lt;/h3&gt;

&lt;p&gt;json 也是用text来存储, 但json数据类型的好处在存储时会进行检测，保证每一个值都是一个有效的json值，它还能相对的支持一些函数
在用json时最好保证数据的编码和postgresql的一致&lt;/p&gt;

&lt;h3 id=&#34;数组类型&#34;&gt;数组类型&lt;/h3&gt;

&lt;p&gt;演示创建一个带数组类型的表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO sal_emp
    VALUES (&#39;Bill&#39;,
    &#39;{10000, 10000, 10000, 10000}&#39;,
    &#39;\{\{&amp;quot;meeting&amp;quot;, &amp;quot;lunch&amp;quot;\}, \{&amp;quot;training&amp;quot;, &amp;quot;presentation&amp;quot;\}\}&#39;);

INSERT INTO sal_emp
    VALUES (&#39;Carol&#39;,
    &#39;{20000, 25000, 25000, 25000}&#39;,
    &#39;\{\{&amp;quot;breakfast&amp;quot;, &amp;quot;consulting&amp;quot;\}, {&amp;quot;meeting&amp;quot;, &amp;quot;lunch&amp;quot;\}\}&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM sal_emp;
 name  |      pay_by_quarter       |                 schedule
-------+---------------------------+-------------------------------------------
 Bill  | {10000,10000,10000,10000} | \{\{meeting,lunch\},\{training,presentation\}\}
 Carol | {20000,25000,25000,25000} | \{\{breakfast,consulting\},\{meeting,lunch\}\}
(2 rows)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多重数据的尺寸必须是相同的，一个错误的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO sal_emp
    VALUES (&#39;Bill&#39;,
    &#39;{10000, 10000, 10000, 10000}&#39;,
    &#39;\{\{&amp;quot;meeting&amp;quot;, &amp;quot;lunch&amp;quot;\}, \{&amp;quot;meeting&amp;quot;\}\}&#39;);
ERROR:  multidimensional arrays must have array expressions with matching dimensions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用 ARRAY构造语法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO sal_emp
    VALUES (&#39;Bill&#39;,
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[[&#39;meeting&#39;, &#39;lunch&#39;], [&#39;training&#39;, &#39;presentation&#39;]]);

INSERT INTO sal_emp
    VALUES (&#39;Carol&#39;,
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[[&#39;breakfast&#39;, &#39;consulting&#39;], [&#39;meeting&#39;, &#39;lunch&#39;]]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询pay_by_quarter的第一个值和第二个值不相等的条目的名字&lt;/p&gt;

&lt;p&gt;这里要注意 array的索引是从1开始的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT name FROM sal_emp WHERE pay_by_quarter[1] &amp;lt;&amp;gt; pay_by_quarter[2];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询pay_by_quarter的第三个值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT pay_by_quarter[3] FROM sal_emp;
 pay_by_quarter
----------------
          10000
          25000
(2 rows)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询schedule的多个值
&amp;gt; 这里注意postgresql的array中的切片和其他语言的也是不同的，它会返回[n:m]中的值并包括m的值
&amp;gt; 多重数组切片要全是切片不能[2][1:2]这种写法，而[1:2][2]这种写法会自动转成[1:2][1:2]&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = &#39;Bill&#39;;
        schedule
-------------------------
 \{\{breakfast\},\{meeting\}\}
(1 row)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用postgresql的内置函数查看某条数据的数组的长度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT array_dims(schedule) FROM sal_emp WHERE name = &#39;Carol&#39;;
 array_dims
------------
 [1:2][1:2]
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用array_upper和array_lower查看数组索引的最大值和最小值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = &#39;Carol&#39;;

 array_upper
-------------
           2
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;array_length函数则是查看数组长度和上面那几类函数的使用方法一样&lt;/p&gt;

&lt;p&gt;array_prepend/array_append 在数组前/后面加入元素&lt;/p&gt;

&lt;h3 id=&#34;array-cat&#34;&gt;&lt;strong&gt;array_cat:&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;|| 或修饰符 也能用于SELECT ，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT pay_by_quarter[1:2] || pay_by_quarter[4],name FROM sal_emp
      ?column?       |   name
---------------------+----------
 {10000,10000,10000} | Bill
 {27000,27000,25000} | Carol
(2 rows)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;修改数组&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;语法和SELECT中的差不多&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 在数组第1和第2元素之间插入数据
# 和查询一样，array的索引是从1开始的
UPDATE sal_emp SET pay_by_quarter[1:2] = &#39;{27000,27000}&#39;
    WHERE name = &#39;Carol&#39;;
UPDATE 1
SELECT pay_by_quarter FROM sal_emp WHERE name = &#39;Carol&#39;;
      pay_by_quarter
---------------------------
 {27000,27000,25000,25000}
(1 row)


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ANY 和 ALL 语法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;//先加一条数据
INSERT INTO sal_emp VALUES(&#39;bigpigeo&#39;, ARRAY[10000,20000,30000,40000], ARRAY[[&#39;cookie&#39;, &#39;html&#39;, &#39;head&#39;], [&#39;jia&#39;, &#39;the&#39;, &#39;nine&#39;]]);
INSERT 0 1
SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);
   name   |      pay_by_quarter       |                 schedule
----------+---------------------------+------------------------------------------
 Bill     | {10000,10000,10000,10000} | \{\{breakfast,consulting},\{meeting,lunch\}\}
 bigpigeo | {10000,20000,30000,40000} | \{\{cookie,html,head\},\{jia,the,nine\}\}

SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);
 name |      pay_by_quarter       |                 schedule
------+---------------------------+------------------------------------------
 Bill | {10000,10000,10000,10000} | \{\{breakfast,consulting\},\{meeting,lunch\}\}
(1 row)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;组合类型&#34;&gt;组合类型&lt;/h3&gt;

&lt;p&gt;postgresql 还支持组合类型个人感觉这种比JSON类型好，因为JSON相当于是弱类型的数据，不能很好的对数据做类型检查，使用时容易出问题&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先是创建复合类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TYPE complex AS (
    r       double precision,
    i       double precision
);

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是包含复合类型的表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE on_hand (
    item      inventory_item,
    count     integer
);

INSERT INTO on_hand VALUES (ROW(&#39;fuzzy dice&#39;, 42, 1.99), 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;当你创建一个表的同时也会创建一个和表名一样的复合类型&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;写入复合类型表达式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有2种写入方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;(val1, val2, ...)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或ROW语法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ROW(val1, val2, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;访问复合类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;访问复合类型的成员必须带括号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 查询价格大于9.99的数据
SELECT (item).name FROM on_hand WHERE (item).price &amp;gt; 9.99;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用函数访问也一样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;SELECT (my_func(...)).field FROM ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;修改复合类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Insert一个复合类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO on_hand (item) VALUES((&#39;fat pigeon&#39;, 43, 2.1));
INSERT 0 1
SELECT * FROM on_hand WHERE (item).name = &#39;fat pigeon&#39;;
         item          | count
-----------------------+-------
 (&amp;quot;fat pigeon&amp;quot;,43,2.1) |
(1 row)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update一个复合类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE on_hand SET item = ROW(&#39;fuzzy dice&#39;, 42, 2.99) WHERE (item).name = &#39;fuzzy dice&#39;;
UPDATE 1
SELECT * FROM on_hand WHERE (item).name = &#39;fuzzy dice&#39;;
          item          | count
------------------------+-------
 (&amp;quot;fuzzy dice&amp;quot;,42,2.99) |  1000
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update复合类型中子域的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE on_hand SET item.price = 2.5 WHERE (item).name = &#39;fuzzy dice&#39;;
UPDATE 1
SELECT * FROM on_hand WHERE item.name = &#39;fuzzy dice&#39;;
                                    ^
postgres=# SELECT * FROM on_hand WHERE (item).name = &#39;fuzzy dice&#39;;
         item          | count
-----------------------+-------
 (&amp;quot;fuzzy dice&amp;quot;,42,2.5) |  1000
(1 row)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;range类型&#34;&gt;Range类型&lt;/h3&gt;

&lt;p&gt;range类型可以表示一个值的范围，比如tsrange 可以表示timestamp 的范围&lt;/p&gt;

&lt;p&gt;以下是postgresSQL内置的range类型，你也可以&lt;a href=&#34;http://www.postgresql.org/docs/9.3/static/sql-createtype.html&#34;&gt;自定义&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int4range&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示整数的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int8range&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示大整数的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;numrange&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示numeric的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tsrange&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示为没有时区的timestamp的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tstzrange&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示为有时区的timestamp的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;daterange&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示日期的范围&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;@&amp;gt;和*的注解可以查&lt;a href=&#34;http://www.postgresql.org/docs/9.3/static/functions-range.html#RANGE-OPERATORS-TABLE&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
    (1108, &#39;[2010-01-01 14:30, 2010-01-01 15:30)&#39;);


SELECT * FROM reservation WHERE during @&amp;gt; &#39;2010-01-01 14:50&#39;::timestamp;
 room |                    during
------+-----------------------------------------------
 1108 | [&amp;quot;2010-01-01 14:30:00&amp;quot;,&amp;quot;2010-01-01 15:30:00&amp;quot;)
(1 row)

--下面就是一些官方例子，自己也可以发挥想象力去尝试一下

-- Overlaps
SELECT numrange(11.1, 22.2) &amp;amp;&amp;amp; numrange(20.0, 30.0);

-- Extract the upper bound
SELECT upper(int8range(15, 25));

-- Compute the intersection
SELECT int4range(10, 20) * int4range(15, 25);

-- Is the range empty?
SELECT isempty(numrange(1, 5));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造一个range类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先range类型有2种表示范围的符号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[]表示包含范围符
()表示不包含范围符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是range类型也可其他类型一下可以字符串构造&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;SELECT &#39;[3,7)&#39;::int4range;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是构造函数构造&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT numrange(1.0, 14.0, &#39;(]&#39;);
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>在python上操作postgresql</title>
      <link>https://bigpigeon.org/post/python-and-postgresql/</link>
      <pubDate>Mon, 07 Mar 2016 10:30:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/python-and-postgresql/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本文使用的是postgresql 9.3 基于docker ubuntu&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首先postgresql的安装,这里我使用了自己build一个Dockerfile&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的Dockerfile:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM ubuntu:latest
MAINTAINER bigpigeon &amp;lt;3283273530@qq.com&amp;gt;

RUN apt-get -yqq update
RUN apt-get install -y postgresql-9.3

USER postgres
RUN touch /var/lib/postgresql/.psql_history
RUN /etc/init.d/postgresql start &amp;amp;&amp;amp;\
    psql --command &amp;quot;ALTER USER postgres WITH SUPERUSER PASSWORD &#39;123456&#39;;&amp;quot; &amp;amp;&amp;amp;\
    createdb -O postgres postgres
RUN echo &amp;quot;host all  all    0.0.0.0/0  md5&amp;quot; &amp;gt;&amp;gt; /etc/postgresql/9.3/main/pg_hba.conf
RUN echo &amp;quot;listen_addresses=&#39;*&#39;&amp;quot; &amp;gt;&amp;gt; /etc/postgresql/9.3/main/postgresql.conf

VOLUME  [&amp;quot;/etc/postgresql&amp;quot;, &amp;quot;/var/log/postgresql&amp;quot;, &amp;quot;/var/lib/postgresql&amp;quot;]
CMD [&amp;quot;/usr/lib/postgresql/9.3/bin/postgres&amp;quot;, &amp;quot;-D&amp;quot;, &amp;quot;/var/lib/postgresql/9.3/main&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;config_file=/etc/postgresql/9.3/main/postgresql.conf&amp;quot;]

EXPOSE 5432
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为postgresql不能用root启动，所以我们要改用postgres帐户，该帐户是在postgresql安装时自动创建的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;build docker&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t postgres:own .
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;跑一个docker 进程&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --name postgres -d -p 15432:5432 postgres:own
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入该进程&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -i -t postgres /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;之后来查看一下postgres启动的进程和端口&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//在docker中比较环境干净，所以没必要用grep筛选
# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
postgres     1  0.0  2.0 244920 20576 ?        Ss   06:05   0:00 /usr/lib/postgresql/9.3/bin/postgres -D /var/lib/pos
postgres     9  0.0  0.3 244920  3456 ?        Ss   06:05   0:00 postgres: checkpointer process
postgres    10  0.0  0.4 244920  4608 ?        Ss   06:05   0:00 postgres: writer process
postgres    11  0.0  0.3 244920  3456 ?        Ss   06:05   0:00 postgres: wal writer process
postgres    12  0.0  0.5 245672  5904 ?        Ss   06:05   0:00 postgres: autovacuum launcher process
postgres    13  0.0  0.3 100596  3396 ?        Ss   06:05   0:00 postgres: stats collector process
postgres    14  0.0  0.3  18228  3228 ?        Ss   06:09   0:00 /bin/bash
postgres    22  0.0  0.2  15572  2084 ?        R+   06:14   0:00 ps aux
# netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 127.0.0.1:5432          0.0.0.0:*               LISTEN
tcp6       0      0 ::1:5432                :::*                    LISTEN
udp6       0      0 ::1:59218               ::1:59218               ESTABLISHED
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ACC ]     STREAM     LISTENING     26950    /var/run/postgresql/.s.PGSQL.5432
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;连接控制台&#34;&gt;连接控制台&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用psql来连接postgresql服务端(记得第一时间改密码)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ psql -U postgres -h 127.0.0.1 -p 15432
=# \password postgres
=# \q
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;-U 指定登录用户 -d 指定数据库 -h -p 指定登录的主机和端口，更详细的参数可用&amp;ndash;help查询&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;通过postgresql控制台创建用户&#34;&gt;通过postgresql控制台创建用户&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ psql -U postgres -h 127.0.0.1 -p 15432
=# \password postgres
=# CREATE USER dbuser WITH PASSWORD &#39;password&#39;;
=# CREATE DATABASE exampledb OWNER dbuser;
=# GRANT ALL PRIVILEGES ON DATABASE exampledb to dbuser;
=# \q
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据库命令&#34;&gt;数据库命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# psql -U dbuser -d exampledb -h 127.0.0.1 -p 15432
// \password [username]: 修改[某用户]密码,只有超级用户才可以改其他人的密码
=&amp;gt; \password
Enter new password:
Enter it again:

// \encoding [ENCODING]: 显示[修改]客户端的编码
=&amp;gt; \encoding
UTF8

// \h [NAME]: 查看 所有[某条] SQL命令的解释，比如\h select。
=&amp;gt; \h select
Command:     SELECT
Description: retrieve rows from a table or view
Syntax:
[ WITH [ RECURSIVE ] with_query [, ...] ]
...
// \l [PATTERN]: 列出所有[某条] 数据库
=&amp;gt; \l
                             List of databases
   Name    |  Owner   | Encoding  | Collate | Ctype |   Access privileges
-----------+----------+-----------+---------+-------+-----------------------
 exampledb | dbuser   | SQL_ASCII | C       | C     | =Tc/dbuser           +
           |          |           |         |       | dbuser=CTc/dbuser
 postgres  | postgres | SQL_ASCII | C       | C     |
 template0 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
 template1 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
(4 rows)

// \c [database_name]：连接其他数据库。
=&amp;gt; \c postgres
SSL connection (cipher: DHE-RSA-AES256-GCM-SHA384, bits: 256)
You are now connected to database &amp;quot;postgres&amp;quot; as user &amp;quot;dbuser&amp;quot;.

// \d [table_name]：列出所有[某一张]表格的结构。
// 因为目前还没建表，所以只有一句告警
=&amp;gt; \d
No relations found.
// \du[+] [PATTERN]：列出所有[某]用户。
=&amp;gt; \du
                             List of roles
 Role name |                   Attributes                   | Member of
-----------+------------------------------------------------+-----------
 dbuser    |                                                | {}
 postgres  | Superuser, Create role, Create DB, Replication | {}

// \conninfo：列出当前数据库和连接的信息。
=&amp;gt; \conninfo
You are connected to database &amp;quot;postgres&amp;quot; as user &amp;quot;dbuser&amp;quot; on host &amp;quot;127.0.0.1&amp;quot; at port &amp;quot;15432&amp;quot;.
SSL connection (cipher: DHE-RSA-AES256-GCM-SHA384, bits: 256)

// 更多命令可以通过\?查看
=&amp;gt; \?
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据库操作&#34;&gt;数据库操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法和mysql相似,可通过\h去查看&lt;/li&gt;
&lt;li&gt;下面我将操作数据库语法去建表，插数据等操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; CREATE TABLE user_person(name VARCHAR(20), entry DATE);
CREATE TABLE
=&amp;gt; INSERT INTO user_person(name, entry) VALUES(&#39;jia&#39;, &#39;2016-2-28&#39;);
INSERT 0 1
=&amp;gt; ALTER TABLE user_person ADD job VARCHAR(100);
ALTER TABLE
=&amp;gt; INSERT INTO user_person(name, entry) VALUES(&#39;jib&#39;, &#39;2016-2-29&#39;);
INSERT 0 1
=&amp;gt; UPDATE user_person set job = &#39;backend develop&#39; WHERE name = &#39;jia&#39;;
UPDATE 1
=&amp;gt; UPDATE user_person set job = &#39;frontend develop&#39; WHERE name = &#39;jib&#39;;
UPDATE 1
=&amp;gt; ALTER TABLE user_person ALTER COLUMN job SET NOT NULL ;
ALTER TABLE
=&amp;gt; INSERT INTO user_person(name, entry) VALUES(&#39;jic&#39;, &#39;2016-3-1&#39;);
ERROR:  null value in column &amp;quot;job&amp;quot; violates not-null constraint
DETAIL:  Failing row contains (jic, 2016-03-01, null).
=&amp;gt; SELECT * FROM user_person;
 name |   entry    |       job
------+------------+------------------
 jia  | 2016-02-28 | backend develop
 jib  | 2016-02-29 | frontend develop
(2 rows)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;如何在python上操作postgresql&#34;&gt;如何在python上操作postgresql&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.postgresql.org/wiki/Python&#34;&gt;官网wiki&lt;/a&gt; 给出了6种python 版本的客户端&lt;/li&gt;
&lt;li&gt;我这里用的是&lt;a href=&#34;http://initd.org/psycopg/docs/&#34;&gt;Psycopg2&lt;/a&gt;因为它是这6个客户端中唯二使用LGPL许可证的，并且最近还有更新维护&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;第一部分-安装&#34;&gt;第一部分 安装&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;ubuntu:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只需要apt-get install python-psycopg2就ok&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;windows:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pip install psycopg2&lt;/p&gt;

&lt;p&gt;官网建议用easy_install 但这种安装方法在import是会提示缺少DLL&lt;/p&gt;

&lt;h4 id=&#34;第二部分-操作数据库&#34;&gt;第二部分 操作数据库&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import psycopg2
&amp;gt;&amp;gt;&amp;gt; import datetime

# 连接数据库
&amp;gt;&amp;gt;&amp;gt; conn = psycopg2.connect(
    host=&amp;quot;192.168.56.102&amp;quot;,
    port=&amp;quot;15432&amp;quot;,
    password=&#39;passwd&#39;,
    dbname=&amp;quot;exampledb&amp;quot;,
    user=&amp;quot;dbuser&amp;quot;
)
# 创建一个游标去执行数据库操作
&amp;gt;&amp;gt;&amp;gt; cur = conn.cursor()

# 插入一条数据到user_person表
&amp;gt;&amp;gt;&amp;gt; cur.execute(
    &amp;quot;INSERT INTO user_person(name, entry, job) VALUES (%s, %s, %s)&amp;quot;,
    (&amp;quot;jic&amp;quot;, datetime.date(2016, 3, 1), &amp;quot;full-stack develop&amp;quot;)
)

# 执行查询语句
&amp;gt;&amp;gt;&amp;gt; cur.execute(&amp;quot;SELECT * FROM user_person;&amp;quot;)

# 把查询的结果取出来
&amp;gt;&amp;gt;&amp;gt; cur.fetchall()
[(&#39;jia&#39;, datetime.date(2016, 2, 28), &#39;backend develop&#39;), (&#39;jib&#39;, datetime.date(2016, 2, 29), &#39;frontend develop&#39;), (&#39;jic&#39;, datetime.date(2016, 3, 1), &#39;full-stack develop&#39;)]

# 确保所有命令执行完成
&amp;gt;&amp;gt;&amp;gt; conn.commit()

# 关闭游标和数据库连接
&amp;gt;&amp;gt;&amp;gt; cur.close()
&amp;gt;&amp;gt;&amp;gt; conn.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;上面就是一次完整的数据库操作流程,这里有几点需要注意:

&lt;ul&gt;
&lt;li&gt;execute的 VALUES 后面必须使用(%s,&amp;hellip;)的格式&lt;/li&gt;
&lt;li&gt;VALUES后面的占位符支持 (%(name)s,&amp;hellip;) 参数则为{&amp;lsquo;name&amp;rsquo;: value,&amp;hellip;}这种格式,这样可以保证不用在输入重复的参数&lt;/li&gt;
&lt;li&gt;占位符必须是 %s，不能是%d 或%f&lt;/li&gt;
&lt;li&gt;参数的数据结构必须是list或tuple&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python类型和SQL类型对照
&lt;a href=&#34;http://initd.org/psycopg/docs/usage.html#adaptation-of-python-values-to-sql-types&#34;&gt;http://initd.org/psycopg/docs/usage.html#adaptation-of-python-values-to-sql-types&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用docker部署jekyll</title>
      <link>https://bigpigeon.org/post/docker-and-jekyll/</link>
      <pubDate>Sat, 06 Feb 2016 14:06:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/docker-and-jekyll/</guid>
      <description>&lt;p&gt;关于在docker部署jekyll在&lt;a href=&#34;http://books.linuxfocus.net/files/books/James.Turnbull.The.Docker.Book.Containerization.is.the.new.virtualization.B00LRROTI4.pdf&#34;&gt;The.Docker.Book&lt;/a&gt;中也有详细说明，但主要是自从jekyll升级到需要ruby2.0+版本后就没那么容易了&lt;/p&gt;

&lt;p&gt;所以我在这记录一下部署过程以免将来再次踩坑&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;首先-为什么要用docker&#34;&gt;首先，为什么要用docker&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;docker提供了基于操作系统的虚拟化技术，可以让你很方便的把应用的环境独立出来并且可以重用&lt;/p&gt;

&lt;p&gt;并且 docker提供了一套完善的工具去管理docker推出的进程&lt;/p&gt;

&lt;p&gt;所以 docker相当于是supervisor + 容器的组合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;编辑jekyll的dockerfile和nginx的dockerfile&#34;&gt;编辑jekyll的Dockerfile和nginx的Dockerfile&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;jekyll的目录结构&#34;&gt;jekyll的目录结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;|-base
    |-Dockerfile
|-create
    |-Dockerfile
|-push
    |-Dockerfile
    |-Rakefile
    |-key
       |-id_rsa
       |-id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;jekyll-base目录下的dockerfile&#34;&gt;jekyll base目录下的Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM ubuntu:latest
MAINTAINER bigpigeon0 &amp;lt;bigpigeon0@gmail.com&amp;gt;
ENV REFRESHED_AT 2016-02-13

RUN apt-get -yqq update
RUN apt-get -yqq install ruby2.0 ruby2.0-dev ruby-dev make nodejs git

RUN for i in {1..100};\
      do \
        gem2.0 install --source=http://rubygems.org jekyll;\
        if [ &amp;quot;$?&amp;quot; -eq 0 ];\
          then break;\
        fi;\
      done;
RUN gem2.0 install redcarpet
RUN gem2.0 install --source=http://rubygems.org rake
RUN gem2.0 install bundler
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;apt-get 增加了 ruby-dev(ruby某些库需要用到ruby-dev)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gem2.0 使用源是http的rubugems.org(某些下载文件过大使用https会出现connection reset)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;耐性等待jekyll的安装非常非常慢可能需要1个小时，而且没提示(想要提示可以用Bundler(gem install bundler)，但不知道为何bundler经常装到一半失败，并且缓存失败。。。)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;总的来说就是ruby坑爹，gem更坑爹&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rake的作用是把jekyll生成的网页推到github的master分支上，因为github上的jekyll不支持插件，所以只能本地生产完推上去&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;jekyll-create目录下的dockerfile&#34;&gt;jekyll create目录下的Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM bigpigeon0/jekyll:latest
MAINTAINER bigpigeon0 &amp;lt;bigpigeon0@gmail.com&amp;gt;

VOLUME [&amp;quot;/data&amp;quot;, &amp;quot;/var/www/html&amp;quot;]
WORKDIR /data

ENTRYPOINT [ &amp;quot;jekyll&amp;quot;, &amp;quot;build&amp;quot;, &amp;quot;--destination=/var/www/html&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;jekyll-push目录下的dockerfile&#34;&gt;jekyll push目录下的Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM bigpigeon0/jekyll:latest
MAINTAINER bigpigeon0 &amp;lt;bigpigeon0@gmail.com&amp;gt;

RUN mkdir -p /data/rakedata /data/blog
RUN git config --global user.email bigpigeon0@gmail.com
RUN git config --global user.name bigpigeon

ADD Rakefile /data/rakedata/
COPY key/    /root/.ssh/

WORKDIR /data/rakedata

ENTRYPOINT [&amp;quot;rake&amp;quot;, &amp;quot;publish&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;jekyll-push目录下的rakefile&#34;&gt;jekyll push目录下的Rakefile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &amp;quot;rubygems&amp;quot;
require &amp;quot;tmpdir&amp;quot;

require &amp;quot;bundler/setup&amp;quot;
require &amp;quot;jekyll&amp;quot;


# Change your GitHub reponame
GITHUB_REPONAME = &amp;quot;bigpigeon/bigpigeon.github.io&amp;quot;


desc &amp;quot;Generate blog files&amp;quot;
task :generate do
  Jekyll::Site.new(Jekyll.configuration({
    &amp;quot;source&amp;quot;      =&amp;gt; &amp;quot;../blog/.&amp;quot;,
    &amp;quot;destination&amp;quot; =&amp;gt; &amp;quot;_site&amp;quot;
  })).process
end


desc &amp;quot;Generate and publish blog to master&amp;quot;
task :publish =&amp;gt; [:generate] do
  Dir.mktmpdir do |tmp|
    cp_r &amp;quot;_site/.&amp;quot;, tmp

    pwd = Dir.pwd
    Dir.chdir tmp

    system &amp;quot;git init&amp;quot;
    system &amp;quot;git add .&amp;quot;
    message = &amp;quot;Site updated at #{Time.now.utc}&amp;quot;
    system &amp;quot;git commit -m #{message.inspect}&amp;quot;
    system &amp;quot;git remote add origin git@github.com:#{GITHUB_REPONAME}.git&amp;quot;
    system &amp;quot;git push origin master --force&amp;quot;

    Dir.chdir pwd
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;nginx-image的目录结构&#34;&gt;nginx image的目录结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;|-Dockerfile
|-nginx
    |-static.conf
    |-nginx.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;nginx-image的dockerfile&#34;&gt;nginx image的Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM ubuntu:latest
MAINTAINER bigpigeon &amp;lt;bigpigeon0@gmail.com&amp;gt;

ENV REFRESHED_AT 2016-02-06

RUN apt-get -yqq update
RUN apt-get install -yqq nginx
RUN mkdir -p /var/www/html

ADD nginx/nginx.conf /etc/nginx/nginx.conf
ADD nginx/static.conf /etc/nginx/conf.d/static.conf

VOLUME [&amp;quot;/var/www/html&amp;quot;]
WORKDIR /var/www/html

EXPOSE 80

ENTRYPOINT [&amp;quot;nginx&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;nginx-conf&#34;&gt;nginx.conf&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;user www-data;
worker_processes 4;
pid /run/nginx.pid;
daemon off;
events { }
http {
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;
  include /etc/nginx/mime.types;
  default_type application/octet-stream;
  access_log /var/log/nginx/access.log;
  error_log /var/log/nginx/error.log;
  gzip on;
  gzip_disable &amp;quot;msie6&amp;quot;;
  include /etc/nginx/conf.d/*.conf;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;static-conf&#34;&gt;static.conf&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
  listen 0.0.0.0:80;
  server_name _;
  root /var/www/html/;
  index index.html index.htm;
  access_log /var/log/nginx/default_access.log;
  error_log /var/log/nginx/default_error.log;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker的image就build好了，这里简单讲讲Dockerfile的语法&lt;/p&gt;

&lt;p&gt;FROM: Dockerfile的第一行必须是FROM，表示基于那个基础Docker image&lt;/p&gt;

&lt;p&gt;ENV: 设置环境变量&lt;/p&gt;

&lt;p&gt;MAINTAINER: 告诉docker该image的作者和他的邮箱地址，也是很有必要的&lt;/p&gt;

&lt;p&gt;RUN: 用shell执行一条命令，可以写成RUN xxx &amp;hellip; 或者RUN [&amp;ldquo;xxx&amp;rdquo;, &amp;hellip;]&lt;/p&gt;

&lt;p&gt;CMD: 执行一条命令，当image被运行(推出)时，用法和RUN相识&lt;/p&gt;

&lt;p&gt;ENTRYPOINT: 执行一条命令，当image被运行(推出)时，并且可以在运行时对该命令附加参数&lt;/p&gt;

&lt;p&gt;WORKDIR: 设置工作目录，相当于bash下的cd dir&lt;/p&gt;

&lt;p&gt;USER: 设置在docker build下执行命令的用户&lt;/p&gt;

&lt;p&gt;VOLUME: 方便容器之间挂载目录，可以在image被运行时配合&amp;ndash;volumes-from使用&lt;/p&gt;

&lt;p&gt;ADD: 把文件复制到image中，第一参数可填写网址，但不可访问当前目录以外的路径&lt;/p&gt;

&lt;p&gt;COPY: 把文件夹复制到image中&lt;/p&gt;

&lt;p&gt;ONBUILD: 在该image作为FROM基本容器再次build时执行&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;build-nginx和jekyll的image&#34;&gt;build nginx和jekyll的image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# build jekyll base image
cd Dockerfile存放目录
sudo docker build -t bigpigeon0/jekyll .

# build jekyll create image
cd Dockerfile存放目录
sudo docker build -t bigpigeon0/blog_create .

# build jekyll create image
cd Dockerfile存放目录
sudo docker build -t bigpigeon0/blog_push .

# build nginx image
cd Dockerfile存放目录
sudo docker build -t bigpigeon0/nginx .
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;运行docker&#34;&gt;运行Docker&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 把jekyll的模板下载下来
mkdir -p /data/work/ &amp;amp;&amp;amp; cd /data/work/
git clone https://github.com/bigpigeon/bigpigeon.github.io

# 运行一个博客生成的镜像
sudo docker run  -v /data/work/bigpigeon.github.io:/data --name blog_create bigpigeon0/blog_create

# 运行nginx的镜像
sudo docker run -p 8080:80 -d --name nginx --volumes-from blog_create bigpigeon0/nginx

# 生成博客提交到github
# 记得把key/id_rsa.pub中的内容添加到github.com/settings/ssh中
sudo docker run -t -i -v /data/work/bigpigeon.github.io:/data/blog --name blog_push bigpigeon0/blog_push

# 更新模板后重新生成网页和提交网页
docker start blog_create
docker start -a blog_push
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试网站&#34;&gt;测试网站&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;在浏览器输入&lt;a href=&#34;http://serveraddr:8080&#34;&gt;http://serveraddr:8080&lt;/a&gt; 查看博客&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;The.Docker.Book有&lt;a href=&#34;http://www.amazon.cn/%E7%AC%AC%E4%B8%80%E6%9C%ACDocker%E4%B9%A6-%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E7%89%B9%E6%81%A9%E5%B8%83%E5%B0%94/dp/B00RBEIFMI/&#34;&gt;中文版&lt;/a&gt;，然而我觉得价格太坑爹，还是不推荐大家买(电子书比实体书还贵)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gin框架介绍</title>
      <link>https://bigpigeon.org/post/gin-framework/</link>
      <pubDate>Thu, 24 Dec 2015 06:25:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/gin-framework/</guid>
      <description>&lt;h3 id=&#34;为何用gin&#34;&gt;为何用gin&lt;/h3&gt;

&lt;p&gt;它是一个轻量级框架，框架简单而且速度很快，它的功能用来做rust api开发已经足够&lt;/p&gt;

&lt;p&gt;而因为它的简单我们也能很好的在它上面增加功能或再开发&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;gin的特性&#34;&gt;gin的特性&lt;/h3&gt;

&lt;p&gt;支持中间层&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一个请求过来经过 global middleware,group middleware 最后到该path的middleware处理
我们可以把处理函数放入global/middleware/group middleware的中
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于Radix tree&lt;/p&gt;

&lt;p&gt;灾难恢复&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;处理请求崩溃后会在Recover函数中恢复然后返回500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多特性请看&lt;a href=&#34;https://gin-gonic.github.io/gin/&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本用法&#34;&gt;基本用法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;

func pingPath(c *gin.Context) {
	c.String(200, &amp;quot;pong&amp;quot;)
}

func main() {
    r := gin.Default()
	r.GET(&amp;quot;ping&amp;quot;, pingPath)
	r.Run(&amp;quot;:80&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;上面的代码是什么意思呢&#34;&gt;上面的代码是什么意思呢？&lt;/h3&gt;

&lt;h4 id=&#34;先看看gin-default的源码&#34;&gt;先看看gin.Default的源码&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Default() *Engine {
	engine := New()
	engine.Use(Recovery(), Logger())
	return engine
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;New()是用默认参数构造一个engine&lt;/li&gt;
&lt;li&gt;engine.Use(&amp;hellip;)把Recovery() 和Logger()生成的函数增加值全局handler列&lt;/li&gt;
&lt;li&gt;engine.Use要在所有handle的middleware绑定之前使用，否则某些绑定的path会不生效(在group的middleware之后加是可以的)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;然后我们来看看recovery干了什么&#34;&gt;然后我们来看看Recovery干了什么&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.
func Recovery() HandlerFunc {
	return RecoveryWithWriter(DefaultWriter)
}

func RecoveryWithWriter(out io.Writer) HandlerFunc {
	var logger *log.Logger
	if out != nil {
		logger = log.New(out, &amp;quot;&amp;quot;, log.LstdFlags)
	}
	return func(c *Context) {
		defer func() {
			if err := recover(); err != nil {
				if logger != nil {
					stack := stack(3)
					logger.Printf(&amp;quot;Panic recovery -&amp;gt; %s\n%s\n&amp;quot;, err, stack)
				}
				c.AbortWithStatus(500)
			}
		}()
		c.Next()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;关于recover的使用可以看&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34;&gt;http://blog.golang.org/defer-panic-and-recover&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;defer的函数会在函数结束后返回前调用&lt;/li&gt;
&lt;li&gt;c.Next()就是调用下一个handler 就和Nodejs中的http库差不多&lt;/li&gt;
&lt;li&gt;大致流程就是 FuncBody -&amp;gt; c.Next -&amp;gt; defer func (一个灾难恢复就这样简单的实现了)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;再然后来看看logger&#34;&gt;再然后来看看Logger&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Instances a Logger middleware that will write the logs to gin.DefaultWriter
// By default gin.DefaultWriter = os.Stdout
func Logger() HandlerFunc {
	return LoggerWithWriter(DefaultWriter)
}

// Instance a Logger middleware with the specified writter buffer.
// Example: os.Stdout, a file opened in write mode, a socket...
func LoggerWithWriter(out io.Writer) HandlerFunc {
	return func(c *Context) {
		// Start timer
		start := time.Now()
		path := c.Request.URL.Path

		// Process request
		c.Next()

		// Stop timer
		end := time.Now()
		latency := end.Sub(start)

		clientIP := c.ClientIP()
		method := c.Request.Method
		statusCode := c.Writer.Status()
		statusColor := colorForStatus(statusCode)
		methodColor := colorForMethod(method)
		comment := c.Errors.ByType(ErrorTypePrivate).String()

		fmt.Fprintf(out, &amp;quot;[GIN] %v |%s %3d %s| %13v | %s |%s  %s %-7s %s\n%s&amp;quot;,
			end.Format(&amp;quot;2006/01/02 - 15:04:05&amp;quot;),
			statusColor, statusCode, reset,
			latency,
			clientIP,
			methodColor, reset, method,
			path,
			comment,
		)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;大致就是输出请求头的数据和处理请求所花费的时间&lt;/li&gt;
&lt;li&gt;但听说获取系统时间会有阻塞&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;再来看看r-get之后发生了什么&#34;&gt;再来看看r.GET之后发生了什么&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// routergroup file
func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {
	return group.handle(&amp;quot;GET&amp;quot;, relativePath, handlers)
}

func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {
	absolutePath := group.calculateAbsolutePath(relativePath)
	handlers = group.combineHandlers(handlers)
	group.engine.addRoute(httpMethod, absolutePath, handlers)
	return group.returnObj()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;这里的类是RouterGroup但上面gin.Default()返回的却是是Engine&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;于是我们看看engine的定义&#34;&gt;于是我们看看Engine的定义&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Engine is the framework&#39;s instance, it contains the muxer, middleware and configuration settings.
// Create an instance of Engine, by using New() or Default()
Engine struct {
	RouterGroup
	HTMLRender  render.HTMLRender
	allNoRoute  HandlersChain
	allNoMethod HandlersChain
	noRoute     HandlersChain
	noMethod    HandlersChain
	pool        sync.Pool
	trees       methodTrees
	//忽略一些太长的数据
	...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Engine 是继承于RouteGroup的&lt;/li&gt;
&lt;li&gt;其实可以把Engine当成是RouteGroup节点，Group是可以嵌套的&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;最后看一下handler函数的context参数&#34;&gt;最后看一下handler函数的Context参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Context is the most important part of gin. It allows us to pass variables between middleware,
// manage the flow, validate the JSON of a request and render a JSON response for example.
type Context struct {
	writermem responseWriter
	Request   *http.Request
	Writer    ResponseWriter

	Params   Params
	handlers HandlersChain
	index    int8

	engine   *Engine
	Keys     map[string]interface{}
	Errors   errorMsgs
	Accepted []string
}

// Next should be used only inside middleware.
// It executes the pending handlers in the chain inside the calling handler.
// See example in github.
func (c *Context) Next() {
	c.index++
	s := int8(len(c.handlers))
	for ; c.index &amp;lt; s; c.index++ {
		c.handlers[c.index](c)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这里只展示了Context的定义和Next函数的实现,&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/context.go&#34;&gt;详细看源码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gin的运作原理大概就是这样了,之后讲gin的一些example和&lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;gin的github page&lt;/a&gt;上的一样&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;包含参数的路径&#34;&gt;包含参数的路径&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;
import &amp;quot;net/http&amp;quot;

func main() {
	r := gin.Default()
	// 这种写法只会匹配/user/pigeon ,/user/ 和/user就不会被匹配
	r.GET(&amp;quot;/user/:name&amp;quot;, func(c *gin.Context) {
		name := c.Param(&amp;quot;name&amp;quot;)
		c.String(http.StatusOK, &amp;quot;Hello %s&amp;quot;, name)
	})
	//这种写法会匹配 /user/pigeon/ 和/user/pigeon/enter 或 /user/pigeon/to/doing/something
	r.GET(&amp;quot;/user/:name/*action&amp;quot;, func(c *gin.Context) {
		name := c.Param(&amp;quot;name&amp;quot;)
		action := c.Param(&amp;quot;action&amp;quot;)
		message := name + &amp;quot; is &amp;quot; + action
		c.String(http.StatusOK, message)
	})
	r.Run(&amp;quot;:80&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;query字符串参数&#34;&gt;Query字符串参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;

func main() {
    router := gin.Default()
	// 注:Query函数获取的值都必定是字符串
    router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) {
        firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;)
        lastname := c.Query(&amp;quot;lastname&amp;quot;) // shortcut for c.Request.URL.Query().Get(&amp;quot;lastname&amp;quot;)

        c.String(http.StatusOK, &amp;quot;Hello %s %s&amp;quot;, firstname, lastname)
    })
    router.Run(&amp;quot;:80&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;请尝试用如下请求路径来请求:  /welcome?firstname=Jane&amp;amp;lastname=Doe&lt;/li&gt;
&lt;li&gt;然后查看请求结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;model-binding-and-validation&#34;&gt;Model binding and validation&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;
import &amp;quot;net/http&amp;quot;

// Binding from JSON
type Login struct {
    User     string `form:&amp;quot;user&amp;quot; json:&amp;quot;user&amp;quot; binding:&amp;quot;required&amp;quot;`
    Password string `form:&amp;quot;password&amp;quot; json:&amp;quot;password&amp;quot; binding:&amp;quot;required&amp;quot;`
}

func main() {
    router := gin.Default()

    // 该例子将绑定一个拥有 user 和 password 键的JSON数据
    router.POST(&amp;quot;/loginJSON&amp;quot;, func(c *gin.Context) {
        var json Login
        if c.BindJSON(&amp;amp;json) == nil {
            if json.User == &amp;quot;manu&amp;quot; &amp;amp;&amp;amp; json.Password == &amp;quot;123&amp;quot; {
                c.JSON(http.StatusOK, gin.H{&amp;quot;status&amp;quot;: &amp;quot;you are logged in&amp;quot;})
            } else {
                c.JSON(http.StatusUnauthorized, gin.H{&amp;quot;status&amp;quot;: &amp;quot;unauthorized&amp;quot;})
            }
        }
    })

    // Example for binding a HTML form (user=manu&amp;amp;password=123)
    router.POST(&amp;quot;/loginForm&amp;quot;, func(c *gin.Context) {
        var form Login
        // 用http头中Content-Type 的值去判定数据类型
        if c.Bind(&amp;amp;form) == nil {
            if form.User == &amp;quot;manu&amp;quot; &amp;amp;&amp;amp; form.Password == &amp;quot;123&amp;quot; {
                c.JSON(http.StatusOK, gin.H{&amp;quot;status&amp;quot;: &amp;quot;you are logged in&amp;quot;})
            } else {
                c.JSON(http.StatusUnauthorized, gin.H{&amp;quot;status&amp;quot;: &amp;quot;unauthorized&amp;quot;})
            }
        }
    })

    router.Run(&amp;quot;:80&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;在中间层中使用goroute&#34;&gt;在中间层中使用goroute&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;
import &amp;quot;time&amp;quot;
import &amp;quot;log&amp;quot;

func main() {
    r := gin.Default()

    r.GET(&amp;quot;/long_async&amp;quot;, func(c *gin.Context) {
        // create copy to be used inside the goroutine
        c_cp := c.Copy()
        go func() {
            // simulate a long task with time.Sleep(). 5 seconds
            time.Sleep(5 * time.Second)

            // note than you are using the copied context &amp;quot;c_cp&amp;quot;, IMPORTANT
            log.Println(&amp;quot;Done! in path &amp;quot; + c_cp.Request.URL.Path)
        }()
    })


    r.GET(&amp;quot;/long_sync&amp;quot;, func(c *gin.Context) {
        // simulate a long task with time.Sleep(). 5 seconds
        time.Sleep(5 * time.Second)

        // since we are NOT using a goroutine, we do not have to copy the context
        log.Println(&amp;quot;Done! in path &amp;quot; + c.Request.URL.Path)
    })

    r.Run(&amp;quot;:80&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;goroute 中请使用只读的Context,用Context.Copy可以返回一个只读的Context&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;更多gin的信息可看这&lt;a href=&#34;https://gin-gonic.github.io/gin/&#34;&gt;https://gin-gonic.github.io/gin/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>pac脚本优化</title>
      <link>https://bigpigeon.org/post/switchy-proxy-pac-optimization/</link>
      <pubDate>Sat, 19 Dec 2015 22:00:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/switchy-proxy-pac-optimization/</guid>
      <description>&lt;p&gt;最近发现lantern和shadowsocks client自生成pac都一定的性能问题，在url数目上升到一定程度的时候加载速度明显慢了很多.&lt;/p&gt;

&lt;p&gt;于是我翻看了它们的实现&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lantern

&lt;ul&gt;
&lt;li&gt;把所有需要代理的domain组合成一个RegExp，然后在FindProxyForURL时对host做RegExp.exec的操作来判断是否需要代理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;shadowsocks

&lt;ul&gt;
&lt;li&gt;把domain做成一个{domain:1,&amp;hellip;}的字典，然后在FindProxyForURL时对host做domains.hasOwnProperty判断是否在字典内，若不在，则去掉最前面的&amp;rsquo;.&amp;lsquo;和之前的内容 继续做domains.hasOwnProperty判断&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看出lantern的pac会严重影响网页的加载速度，shadowsocks的稍微好点，但在遇到不需要代理的网页时则会消耗更多无谓的判断

于是我自己实现一个pac优化FindProxyForURL匹配速度&lt;/p&gt;

&lt;p&gt;我的思路是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;把所有需要代理的url以 &amp;lsquo;.&amp;rsquo; 分割成节点&lt;/li&gt;
&lt;li&gt;然后存入一个dict 格式如下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;com&amp;quot;: {
    &amp;quot;google&amp;quot;: true,
    &amp;quot;blogspot&amp;quot;: {
      &amp;quot;www&amp;quot;: true  
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在FindProxyForURL中把host也split成list与这个dict match一下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var domains = [
    &amp;quot;google.com&amp;quot;,
    &amp;quot;www.blogspot.com&amp;quot;,
    ...
];
var domain_dict = {};
for(var i = 0; i &amp;lt; domains.length; i++){
    if(domains[i].endsWith(&amp;quot;.&amp;quot;)){
        domains[i] = domains[i].slice(0, -1)
    }
    var url_list = domains[i].split(&#39;.&#39;);

    var domain_node = domain_dict;
    for(var j = url_list.length; j &amp;gt; 0; j--){
        var node_name = url_list[j-1];
        if (!domain_node.hasOwnProperty(node_name)){
            if (j === 1){
                domain_node[node_name] = true;
                break;
            } else {
                domain_node[node_name] = {};
            }
        } else if(domain_node[node_name] === true) {
            break;
        }
        domain_node = domain_node[node_name];
    }
}

var proxy = &amp;quot;SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT&amp;quot;;

var direct = &#39;DIRECT;&#39;;

function FindProxyForURL(url, host) {
    if( host == &amp;quot;localhost&amp;quot; ||
        host == &amp;quot;127.0.0.1&amp;quot;) {
        return direct;
    }
    var host_list = host.split(&#39;.&#39;)
    var domain_node = domain_dict
    for(var i = host_list.length; i &amp;gt; 0; i--){
        var node_name = host_list[i-1]
        if (domain_node.hasOwnProperty(node_name)){
            if(domain_node[node_name] === true){
                return proxy;
            } else {
                domain_node = domain_node[node_name]
            }

        }
        else {
            return direct;
        }
    }
    return direct;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;以下是我在nodejs下的性能测试结果 &lt;a href=&#34;https://bigpigeon.org/static/testdata/pac_benchmark.zip&#34;&gt;测试js下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
&lt;canvas id=&#34;bench-chart-10k&#34; width=&#34;860&#34; height=&#34;500&#34;&gt;&lt;/canvas&gt;
&lt;canvas id=&#34;bench-chart-100k&#34; width=&#34;860&#34; height=&#34;500&#34;&gt;&lt;/canvas&gt;
&lt;canvas id=&#34;bench-chart-1m&#34; width=&#34;860&#34; height=&#34;500&#34;&gt;&lt;/canvas&gt;
&lt;script src=&#34;../../js/Chart.min.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;
var benck10kData = {
  shadowsocks: [3, 2, 6, 3, 5, 4],
  lantern: [4, 32, 2, 39, 18, 47],
  owner: [3, 3, 11, 3, 3, 3]
};
var benck100kData = {
  shadowsocks: [24, 22, 37, 37, 47, 51],
  lantern: [29, 279, 27, 373, 163, 441],
  owner: [27, 23, 29, 24, 29, 24]
};
var benck1mData = {
  shadowsocks: [136, 130, 287, 309, 401, 460],
  lantern: [222, 2776, 258, 3698, 1631, 4420],
  owner: [224, 220, 285, 218, 287, 220]
};

function renderChart(ctx, data) {
  var chart_obj = new Chart(ctx, {
    type: &#39;bar&#39;,
    data: {
      labels: [&#39;proxy_2_node&#39;, &#39;noproxy_2_node&#39;, &#39;proxy_3_node&#39;, &#39;noproxy_3_node&#39;, &#39;proxy_4_node&#39;, &#39;noproxy_4_node&#39;],
      datasets: [
        {
          type: &#39;bar&#39;,
          label: &#39;shadowsocks&#39;,
          data: data.shadowsocks,
          backgroundColor: &#34;#1C9b47&#34;,
        },
        {
          type: &#39;bar&#39;,
          label: &#39;lantern&#39;,
          data: data.lantern,
          backgroundColor: &#34;#00BCD4&#34;,
        },
        {
          type: &#39;bar&#39;,
          label: &#39;owner&#39;,
          data: data.owner,
          backgroundColor: &#34;#FF4088&#34;,
        }
      ]
    },
    options: {
        title: {
            display: true,
            text: ctx.id
        }
    }
  });
  return chart_obj;
}

renderChart(document.getElementById(&#34;bench-chart-10k&#34;), benck10kData);
renderChart(document.getElementById(&#34;bench-chart-100k&#34;), benck100kData);
renderChart(document.getElementById(&#34;bench-chart-1m&#34;), benck1mData);



&lt;/script&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>jekyll部署总结</title>
      <link>https://bigpigeon.org/post/jekyll-deploy/</link>
      <pubDate>Wed, 09 Dec 2015 16:00:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/jekyll-deploy/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;在网络并不好的情况下用gem install jeskll 代替 bundle install ，bundle install 总会出现 各种connection reset的情况&lt;/li&gt;
&lt;li&gt;把博客上传github的时候主要不要把_site里的内容上传上去，不然会你的邮箱会收到一个Page build failure的邮件&lt;/li&gt;
&lt;li&gt;这个博客的模板我是fork &lt;a href=&#34;https://github.com/Gaohaoyang&#34;&gt;浩阳 Gaohaoyang&lt;/a&gt; 的 &lt;a href=&#34;https://github.com/Gaohaoyang/gaohaoyang.github.io&#34;&gt;博客模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;其实我还是希望设计一个有特色点的博客，但毕竟我前端技能很烂，只能先用别人的了.
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
