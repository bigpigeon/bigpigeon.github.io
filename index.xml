<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bigpigeon</title>
    <link>https://bigpigeon.org/</link>
    <description>Recent content on bigpigeon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Thu, 21 May 2020 12:07:00 +0800</lastBuildDate>
    <atom:link href="https://bigpigeon.org/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>实现一个k8s的节点本地服务</title>
      <link>https://bigpigeon.org/post/k8s-crd/</link>
      <pubDate>Thu, 21 May 2020 12:07:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/k8s-crd/</guid>
      <description>&lt;p&gt;k8s的service实体的路由规则太简单，无法设置路由节点信息，于是我通过crd扩展一个LocalService的种类来控制节点的路由&lt;/p&gt;

&lt;p&gt;它的结构如下,创建LocalService会创建对应的节点service,通过&lt;code&gt;服务名-节点名&lt;/code&gt;就可以很方便的路由到该节点的上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;demo-service(kind:LocalService)
  \- demo-service-node1(kind:service)
  \- demo-service-node2(kind:service)
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;如何扩展k8s可以看&lt;a href=&#34;https://kubernetes.io/zh/docs/concepts/extend-kubernetes/extend-cluster/&#34;&gt;extend-cluster&lt;/a&gt;,下面开始讲解&lt;/p&gt;

&lt;p&gt;先来看下目录结构，这个目录是依照sample-controller来改的&lt;/p&gt;

&lt;h3 id=&#34;项目结构&#34;&gt;项目结构&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;├── artifacts 
│   └── examples // k8s的资源
│       ├── crd.yaml    //custom resource definition 资源
│       └── example-foo.yaml // LocalService 资源
├── controller.go // LocalService controller模块,根据LocalService生成service
├── pod_controller.go // pod controller模块,用于帮pod增加node信息label
├── hack          // 生成器工具
│   ├── boilerplate.go.txt
│   ├── custom-boilerplate.go.txt
│   ├── tools.go
│   ├── update-codegen.sh
│   └── verify-codegen.sh
├── main.go // main入口
├── pkg // k8s资源代码
│   ├── apis 
│   │   └── localservice_controller // LocalService自定义的crd类型
│   │       ├── register.go
│   │       └── v1alpha1
│   │           ├── doc.go
│   │           ├── register.go 
│   │           ├── types.go       // LocalService实体相关类型信息
│   │           └── zz_generated.deepcopy.go // update-codegen.sh生成相关类型的拷贝方法
│   ├── generated //生产的代码
│   │   ├── clientset // LocalService的客户端api，所有对该资源的操作都可以通过这个api
│   │   ├── informers // LocalService的资源查看，因为该库会缓存LocalService的资源，所以更效率并且不占用apiserver资源
│   │   └── listers   // 为informers提供list和get方法
│   └── signals // 退出信号的控制
│       ├── signal.go
│       ├── signal_posix.go
│       └── signal_windows.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;apis准备&#34;&gt;apis准备&lt;/h3&gt;

&lt;p&gt;k8s有一套生成工具可以生成一系列辅助函数，我们只需要把crd的数据类型定义好，注册到scheme.AddKnownTypes中&lt;/p&gt;

&lt;p&gt;生成代码之前注意以下几点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拉取的项目必须放到$GOPATH/src下，并且项目路径必须和项目地址路径相匹配&lt;/li&gt;
&lt;li&gt;pkg/apis/localservice_controller/v1alpha1/register.go下的SchemeGroupVersion决定apiVersion信息&lt;/li&gt;
&lt;li&gt;非go module模式请将k8s.io/code-generator项目拷贝到项目根目录下&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先 定义LocalService相关类型，LocalService和LocalServiceList上面必须有 &lt;code&gt;+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object&lt;/code&gt; 不然生产的代码会缺少&lt;code&gt;DeepCopyObject&lt;/code&gt; 方法&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bigpigeon/local-service-controller/blob/master/pkg/apis/localservice_controller/v1alpha1/types.go&#34;&gt;types.go代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注册到scheme中&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bigpigeon/local-service-controller/blob/master/pkg/apis/localservice_controller/v1alpha1/register.go&#34;&gt;register.go代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;修改完成执行update-codegen.sh生产相关代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./hack/update-codegen.sh
...

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建controller&#34;&gt;创建controller&lt;/h3&gt;

&lt;p&gt;controller能做许多不同的事情，但是它们都是通过api-server监听资源变更，修改/增加对应资源,将资源实际状态调整为其期望状态&lt;/p&gt;

&lt;p&gt;默认操作流程:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过informer().AddEventHandler增加相应资源的监听函数，informer会监听特定类型资源的变更事件&lt;/li&gt;
&lt;li&gt;在监听函数中对资源进行筛选，将匹配的资源的key放入workqueue队列&lt;/li&gt;
&lt;li&gt;worker从队列获取task交给实际的syncHandler函数处理&lt;/li&gt;
&lt;li&gt;syncHandler开始处理task&lt;/li&gt;
&lt;li&gt;任务完成后修改资源status,并增加相应的event&lt;/li&gt;
&lt;li&gt;task处理成功调用会调用&lt;code&gt;workqueue.Forget(obj)&lt;/code&gt;，否则任务会重新回到队列中&lt;/li&gt;
&lt;li&gt;worker调用&lt;code&gt;workqueue.Done(obj)&lt;/code&gt;释放对该任务的占用，无论成功与否该函数都会被调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;了解流程后再来看看&lt;code&gt;controller.go&lt;/code&gt;的代码&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bigpigeon/local-service-controller/blob/master/controller.go&#34;&gt;controller.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这代码看似很多，其实做的事情很简单，分为以下部分&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;创建controller并开始&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NewController-&amp;gt; Controller.Run&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;监听LocalService资源&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建对localService的监听，触发controller.enqueueLocalServer回调函数&lt;/li&gt;
&lt;li&gt;将任务放入Controller.workqueue队列&lt;/li&gt;
&lt;li&gt;processNextWorkItem获取任务并调用syncHandler处理任务&lt;/li&gt;
&lt;li&gt;找出所有k8s的Node和属于该LocalService的Service资源&lt;/li&gt;
&lt;li&gt;匹配Service和Node，对缺失的Node创建Service，删除不存在的node上的Service&lt;/li&gt;
&lt;li&gt;创建一个Event&lt;/li&gt;
&lt;li&gt;task处理成功调用会调用&lt;code&gt;workqueue.Forget(obj)&lt;/code&gt;，否则任务会重新回到队列中&lt;/li&gt;
&lt;li&gt;worker调用&lt;code&gt;workqueue.Done(obj)&lt;/code&gt;释放对该任务的占用，无论成功与否该函数都会被调用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;创建pod-controller&#34;&gt;创建pod-controller&lt;/h3&gt;

&lt;p&gt;因为Service只能通过label来匹配pod，于是我们需要创建一个pod-controller，将pod的&lt;code&gt;Spec.NodeName&lt;/code&gt;同步到Labels&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bigpigeon/local-service-controller/blob/master/pod_controller.go&#34;&gt;pod_controller.go&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;main函数&#34;&gt;main函数&lt;/h3&gt;

&lt;p&gt;main函数做了以下几件事情&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要处理退出信号&lt;/li&gt;
&lt;li&gt;初始化资源的clientset&lt;/li&gt;
&lt;li&gt;初始化资源的informer&lt;/li&gt;
&lt;li&gt;启动controller&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有工作准备完成，可以启动controller了&lt;/p&gt;

&lt;h3 id=&#34;创建crd资源-并启动服务&#34;&gt;创建Crd资源，并启动服务&lt;/h3&gt;

&lt;p&gt;如果我们现在启动服务则会得到&lt;code&gt;Failed to list *v1alpha1.LocalService: the server could not find the requested resource&lt;/code&gt;错误信息，这是因为k8s 的api-server还不知道该资源是什么，我们需要创建一个crd来告诉k8s apiserver&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create -f artifacts/examples/crd.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;crd声明的资源类型&lt;code&gt;spec.names.kind&lt;/code&gt;必须对应go里面定义的类型&lt;code&gt;pkg/apis/localservice_controller/v1alpha1/types.go.LocalService&lt;/code&gt;,所以这里只能是LocalService，如果想修改kind名，注册的时候用&lt;code&gt;scheme.AddKnownTypeWithName&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启动controller
    go build .
    ./local-service-controller -kubeconfig=your/kubernetes/config&lt;/p&gt;

&lt;h3 id=&#34;创建localservice验证controller&#34;&gt;创建LocalService验证controller&lt;/h3&gt;

&lt;p&gt;创建LocalService和Deployments&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create -f artifacts/examples/example.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待一段k8s创建完成,查看各个资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl get LocalService 

kubectl get service -l owner

kubectl get pod -l kind=localservice-app
kubectl get pod -l vm/rack=k8s03
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接到k8s环境，使用curl调用服务(你可以用kube-vpn或者kubectl exec连如该k8s环境)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localservice-app-k8s03:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你将看到，这消息永远来自k8s03节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello  this message from mylocalservice-app-586ffc555f-dgfp8/k8s03
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;附录&#34;&gt;附录&lt;/h3&gt;

&lt;p&gt;local-service-controller项目地址: &lt;a href=&#34;https://github.com/bigpigeon/local-service-controller&#34;&gt;https://github.com/bigpigeon/local-service-controller&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>当在k8s创建一个实体时会发生什么</title>
      <link>https://bigpigeon.org/post/k8s-concept/</link>
      <pubDate>Wed, 15 Apr 2020 18:43:37 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/k8s-concept/</guid>
      <description>&lt;h3 id=&#34;前置条件&#34;&gt;前置条件&lt;/h3&gt;

&lt;p&gt;容器: docker&lt;/p&gt;

&lt;p&gt;kubernetes: 1.14.2&lt;/p&gt;

&lt;p&gt;当在k8s中创建一个deployments,注意kubeapi会通知到每一个controller，多个controll同时对一个deployment增加replicaSet只有一个会成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;sequenceDiagram
  kubectl-&amp;gt;kubeapi: 创建一个deployment
  kubeapi-&amp;gt;etcd: 持久化这次修改
  kubeapi-&amp;gt;kubectl: 告知客户端创建成功
  deploymentController-&amp;gt;kubeapi: 获取该deployment，创建对应的replicationSet并绑定该deployment
  replicationSetController-&amp;gt;kubeapi: 获取该replicationSet，根据实例数创建pod
  kube_schedule-&amp;gt;kubeapi: 获取新的pod，通过权重为它分配节点信息
  kubelet-&amp;gt;kubeapi: 获取pod信息，通过cri发送给本地docker，创建container
  kubelet-&amp;gt;container: 通知docker创建pod中的container
  kubelet-&amp;gt;kubeapi: 收集container状态，更新pod状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;当k8s中创建一个service&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;sequenceDiagram
  kubectl-&amp;gt;kubeapi: 创建一个service
  kubeapi-&amp;gt;etcd: 持久化这次修改
  kubeapi-&amp;gt;kubectl: 告知客户端创建成功
  endpointController-&amp;gt;kubeapi: 获取service更新，更新当前endpoint
  kube-proxy-&amp;gt;kubeapi: 获取endpoint信息，根据网络plugin修改规则
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>go的text/template源码解析</title>
      <link>https://bigpigeon.org/post/go-text-template/</link>
      <pubDate>Sat, 05 Oct 2019 13:24:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/go-text-template/</guid>
      <description>&lt;p&gt;go的模板库一直缺少indent的功能，于是我决定自己造个轮子来解决这个问题&lt;/p&gt;

&lt;p&gt;为了造出好用，贴近源生态的轮子，所以我决定把text/template的源码熟读一遍&lt;/p&gt;

&lt;p&gt;本篇只是粗略的讲解模板的各个模块，不会深入函数细节&lt;/p&gt;

&lt;p&gt;首先基本用法开始&lt;/p&gt;

&lt;h4 id=&#34;基本用法&#34;&gt;基本用法&lt;/h4&gt;

&lt;p&gt;我们这里用的是text_template中example_test的ExampleTemplate()作为例子&lt;/p&gt;

&lt;p&gt;通过一下命令创建一个text模板,其中Must函数表示处理错误并panic，New表示创建一个空模板，解析模板内容的逻辑在Parse函数中&lt;/p&gt;

&lt;p&gt;然后通过&lt;code&gt;t.Execute&lt;/code&gt;把模板渲染出来&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;const letter = `
Dear {{.Name}},
{{if .Attended}}
It was a pleasure to see you at the wedding.
{{- else}}
It is a shame you couldn&#39;t make it to the wedding.
{{- end}}
{{with .Gift -}}
Thank you for the lovely {{.}}.
{{end}}
Best wishes,
Josie
`

// Prepare some data to insert into the template.
type Recipient struct {
	Name, Gift string
	Attended   bool
}
var recipients = []Recipient{
	{&amp;quot;Aunt Mildred&amp;quot;, &amp;quot;bone china tea set&amp;quot;, true},
	{&amp;quot;Uncle John&amp;quot;, &amp;quot;moleskin pants&amp;quot;, false},
	{&amp;quot;Cousin Rodney&amp;quot;, &amp;quot;&amp;quot;, false},
}

t := template.Must(template.New(&amp;quot;letter&amp;quot;).Parse(letter))

// Execute the template for each recipient.
for _, r := range recipients {
	err := t.Execute(os.Stdout, r)
	if err != nil {
		log.Println(&amp;quot;executing template:&amp;quot;, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;数据结构&#34;&gt;数据结构&lt;/h4&gt;

&lt;p&gt;先看看text/template的Template结构，这个是整个template库最重要了结构了，也是我们通过&lt;code&gt;template.New(&amp;quot;letter&amp;quot;).Parse(letter)&lt;/code&gt;得到对象&lt;/p&gt;

&lt;p&gt;下面我会加入自己的注释，以&lt;code&gt;// self&lt;/code&gt;开头&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Template is the representation of a parsed template. The *parse.Tree
// field is exported only for use by html/template and should be treated
// as unexported by all other clients.
type Template struct {
	name string     // self 模板名字
	*parse.Tree     // self 
	*common
	leftDelim  string  //self 左分隔符，一般是 {{ 
	rightDelim string  //self 右分隔符, 一般是 }}
}

// common holds the information shared by related templates.
type common struct {
	tmpl   map[string]*Template // Map from name to defined templates. //self 模板的子模板，在文件中的 {{ define xxx }} {{ end }} 就会创建一个模板
	option option
	// We use two maps, one for parsing and one for execution.
	// This separation makes the API cleaner since it doesn&#39;t
	// expose reflection to the client.
	muFuncs    sync.RWMutex // protects parseFuncs and execFuncs 
	parseFuncs FuncMap      //self 以interface{}形式保存的函数对象
	execFuncs  map[string]reflect.Value // self parseFuncs中的函数最终都会转换成reflect.Value形式
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Template中还有一个&lt;code&gt;parse.Tree&lt;/code&gt; 看看它长什么样子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Tree is the representation of a single parsed template.
type Tree struct {
	Name      string    // name of the template represented by the tree.
	ParseName string    // name of the top-level template during parsing, for error messages.
	Root      *ListNode // top-level root of the tree.
	text      string    // text parsed to create the template (or its parent) //self 等待解析的文本
	// Parsing only; cleared after parse.
	funcs     []map[string]interface{}
	lex       *lexer //self 词法解析器，用于解析模板中的关键字,比如 &#39;{{&#39; ,&#39;|&#39;, &#39;=&#39;, 函数名，表达式，等等
	token     [3]item // three-token lookahead for parser.
	peekCount int
	vars      []string // variables defined at the moment.
	treeSet   map[string]*Tree
}

// ListNode holds a sequence of nodes.
type ListNode struct {
	NodeType  //self 节点类型，没什么好说的
	Pos       //self 该节点在文本中的位置，也可以理解为index
	tr    *Tree //self 该节点在树中的位置
	Nodes []Node // The element nodes in lexical order.
}

// A Node is an element in the parse tree. The interface is trivial.
// The interface contains an unexported method so that only
// types local to this package can satisfy it.
type Node interface {
	Type() NodeType
	String() string
	// Copy does a deep copy of the Node and all its components.
	// To avoid type assertions, some XxxNodes also have specialized
	// CopyXxx methods that return *XxxNode.
	Copy() Node
	Position() Pos // byte position of start of node in full original input string
	// tree returns the containing *Tree.
	// It is unexported so all implementations of Node are in this package.
	tree() *Tree
}


const (
	NodeText       NodeType = iota // Plain text.
	NodeAction                     // A non-control action such as a field evaluation.
	NodeBool                       // A boolean constant.
	NodeChain                      // A sequence of field accesses.
	NodeCommand                    // An element of a pipeline.
	NodeDot                        // The cursor, dot.
	nodeElse                       // An else action. Not added to tree.
	nodeEnd                        // An end action. Not added to tree.
	NodeField                      // A field or method name.
	NodeIdentifier                 // An identifier; always a function name.
	NodeIf                         // An if action.
	NodeList                       // A list of Nodes.
	NodeNil                        // An untyped nil constant.
	NodeNumber                     // A numerical constant.
	NodePipe                       // A pipeline of commands.
	NodeRange                      // A range action.
	NodeString                     // A string constant.
	NodeTemplate                   // A template invocation action.
	NodeVariable                   // A $ variable.
	NodeWith                       // A with action.
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建模板&#34;&gt;创建模板&lt;/h4&gt;

&lt;p&gt;我们从Parse函数作为入口看看它做了什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Parse parses text as a template body for t.
// Named template definitions ({{define ...}} or {{block ...}} statements) in text
// define additional templates associated with t and are removed from the
// definition of t itself.
//
// Templates can be redefined in successive calls to Parse.
// A template definition with a body containing only white space and comments
// is considered empty and will not replace an existing template&#39;s body.
// This allows using Parse to add new named template definitions without
// overwriting the main template body.
func (t *Template) Parse(text string) (*Template, error) {
	t.init()
	t.muFuncs.RLock()
	trees, err := parse.Parse(t.name, text, t.leftDelim, t.rightDelim, t.parseFuncs, builtins)
	t.muFuncs.RUnlock()
	if err != nil {
		return nil, err
	}
	// Add the newly parsed trees, including the one for t, into our common structure.
	for name, tree := range trees {
		if _, err := t.AddParseTree(name, tree); err != nil {
			return nil, err
		}
	}
	return t, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在模板使用语法我就不讲了，从注释中我们还可以知道，该函数可以重复调用，新的模板会覆盖旧的，然后我们看看代码&lt;/p&gt;

&lt;p&gt;代码大致含义 &lt;strong&gt;parse.Parse&lt;/strong&gt; 函数把文本解析成&lt;code&gt;map[string]*parse.Tree&lt;/code&gt;的树map对象,然后把它append到当前模板的t.temp中&lt;/p&gt;

&lt;p&gt;然后看看&lt;strong&gt;parse.Parse&lt;/strong&gt;发生了什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
// Parse returns a map from template name to parse.Tree, created by parsing the
// templates described in the argument string. The top-level template will be
// given the specified name. If an error is encountered, parsing stops and an
// empty map is returned with the error.
func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (map[string]*Tree, error) {
	treeSet := make(map[string]*Tree)
	t := New(name)
	t.text = text
	_, err := t.Parse(text, leftDelim, rightDelim, treeSet, funcs...)
	return treeSet, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们接着往下看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
// Parse parses the template definition string to construct a representation of
// the template for execution. If either action delimiter string is empty, the
// default (&amp;quot;{{&amp;quot; or &amp;quot;}}&amp;quot;) is used. Embedded template definitions are added to
// the treeSet map.
func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]interface{}) (tree *Tree, err error) {
	defer t.recover(&amp;amp;err)
	t.ParseName = t.Name
	t.startParse(funcs, lex(t.Name, text, leftDelim, rightDelim), treeSet)
	t.text = text
	t.parse()
	t.add()
	t.stopParse()
	return t, nil
}

// lex creates a new scanner for the input string.
func lex(name, input, left, right string) *lexer {
	if left == &amp;quot;&amp;quot; {
		left = leftDelim
	}
	if right == &amp;quot;&amp;quot; {
		right = rightDelim
	}
	l := &amp;amp;lexer{
		name:       name,
		input:      input,
		leftDelim:  left,
		rightDelim: right,
		items:      make(chan item),
		line:       1,
	}
	go l.run()
	return l
}

// startParse initializes the parser, using the lexer.
func (t *Tree) startParse(funcs []map[string]interface{}, lex *lexer, treeSet map[string]*Tree) {
	t.Root = nil
	t.lex = lex
	t.vars = []string{&amp;quot;$&amp;quot;}
	t.funcs = funcs
	t.treeSet = treeSet
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lex就是词法解析器，它不断的读取文本中的关键字，传给&lt;code&gt;Tree.parse&lt;/code&gt;来解析&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Tree.startParse&lt;/code&gt;并不是真的开始解析，它只是初始化&lt;code&gt;Tree&lt;/code&gt;的词法解析器等字段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Tree.parse&lt;/code&gt;会读取从lex中解析的关键词，构建成不同的节点，保存到树中(这个源码我会在下面讲解时才贴)&lt;/p&gt;

&lt;p&gt;我们先从lex开始看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// lex creates a new scanner for the input string.
func lex(name, input, left, right string) *lexer {
	if left == &amp;quot;&amp;quot; {
		left = leftDelim
	}
	if right == &amp;quot;&amp;quot; {
		right = rightDelim
	}
	l := &amp;amp;lexer{
		name:       name,
		input:      input,
		leftDelim:  left,
		rightDelim: right,
		items:      make(chan item),
		line:       1,
	}
	go l.run()
	return l
}

// run runs the state machine for the lexer.
func (l *lexer) run() {
	for state := lexText; state != nil; {
		state = state(l)
	}
	close(l.items)
}


// lexText scans until an opening action delimiter, &amp;quot;{{&amp;quot;.
func lexText(l *lexer) stateFn {
	l.width = 0
	if x := strings.Index(l.input[l.pos:], l.leftDelim); x &amp;gt;= 0 {
		ldn := Pos(len(l.leftDelim))
		l.pos += Pos(x)
		trimLength := Pos(0)
		if strings.HasPrefix(l.input[l.pos+ldn:], leftTrimMarker) {
			trimLength = rightTrimLength(l.input[l.start:l.pos])
		}
		l.pos -= trimLength
		if l.pos &amp;gt; l.start {
			l.emit(itemText)
		}
		l.pos += trimLength
		l.ignore()
		return lexLeftDelim
	} else {
		l.pos = Pos(len(l.input))
	}
	// Correctly reached EOF.
	if l.pos &amp;gt; l.start {
		l.emit(itemText)
	}
	l.emit(itemEOF)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lex&lt;/code&gt;函数通过&lt;code&gt;go l.run&lt;/code&gt;异步执行单词解析，并通过&lt;code&gt;items chan&lt;/code&gt;传给外面&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lexer.Run&lt;/code&gt;通过不断执行 &lt;code&gt;stateFn&lt;/code&gt;直到它返回一个空值&lt;/p&gt;

&lt;p&gt;第一个被执行的&lt;code&gt;stateFn&lt;/code&gt;是lexText，它负责扫描遇到 &lt;code&gt;{{&lt;/code&gt;符号之前的所有字符，也就是模板语法之外的文本&lt;/p&gt;

&lt;p&gt;&lt;code&gt;l.emit&lt;/code&gt;就是往 &lt;code&gt;l.items&lt;/code&gt;发送一个 item，我们看看l.emit是怎么样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// emit passes an item back to the client.
func (l *lexer) emit(t itemType) {
	l.items &amp;lt;- item{t, l.start, l.input[l.start:l.pos], l.line}
	// Some items contain text internally. If so, count their newlines.
	switch t {
	case itemText, itemRawString, itemLeftDelim, itemRightDelim:
		l.line += strings.Count(l.input[l.start:l.pos], &amp;quot;\n&amp;quot;)
	}
	l.start = l.pos
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;l.input[l.start:l.pos]&lt;/code&gt; 表示这次分析的 “词” 对应的位置(&lt;code&gt;{{,/*,:=&lt;/code&gt;等等也是属于词 )&lt;/p&gt;

&lt;p&gt;lex函数解析顺序(TODO)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lexText -&amp;gt; lexLeftDelim -&amp;gt;  lexComment -&amp;gt; lexText
						-&amp;gt; lexInsideAction -&amp;gt; 	

lexText -&amp;gt; EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来开开&lt;code&gt;Tree.parse&lt;/code&gt;拿到item后怎么处理&lt;/p&gt;

&lt;h5 id=&#34;tree-parse&#34;&gt;Tree.parse&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// parse is the top-level parser for a template, essentially the same
// as itemList except it also parses {{define}} actions.
// It runs to EOF.
func (t *Tree) parse() {
	t.Root = t.newList(t.peek().pos)
	for t.peek().typ != itemEOF {
		if t.peek().typ == itemLeftDelim {
			delim := t.next()
			if t.nextNonSpace().typ == itemDefine {
				newT := New(&amp;quot;definition&amp;quot;) // name will be updated once we know it.
				newT.text = t.text
				newT.ParseName = t.ParseName
				newT.startParse(t.funcs, t.lex, t.treeSet)
				newT.parseDefinition()
				continue
			}
			t.backup2(delim)
		}
		switch n := t.textOrAction(); n.Type() {
		case nodeEnd, nodeElse:
			t.errorf(&amp;quot;unexpected %s&amp;quot;, n)
		default:
			t.Root.append(n)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先parse这个函数的目的是把lex解析出来的item进一步解析成&lt;code&gt;parse.Node&lt;/code&gt;然后放入t.Root中&lt;/p&gt;

&lt;p&gt;在解释这个函数之前我也简单说说 &lt;code&gt;peek&lt;/code&gt;,&lt;code&gt;next&lt;/code&gt;,&lt;code&gt;backup&lt;/code&gt;,&lt;code&gt;backup2&lt;/code&gt; 这几个函数的含义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;peek: 查看栈的最后一个item&lt;/li&gt;
&lt;li&gt;next: 拿出栈的最后一个item&lt;/li&gt;
&lt;li&gt;backend: 把最后一个拿出来的item塞到栈尾&lt;/li&gt;
&lt;li&gt;backend2: 把最后一个拿出来的item塞到栈尾，并额外塞一个进去&lt;/li&gt;
&lt;li&gt;backend3: 和backend2同理，塞2个进去&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了理解了这些我们就基本能看到这个函数在干什么了&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用第0个item.pos来初始化&lt;code&gt;t.Root&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;for循环遍历item，直到遇到&lt;code&gt;itemEOF&lt;/code&gt;这个结束符item为止&lt;/li&gt;
&lt;li&gt;遇到 左分隔符(也就是&amp;rdquo;{{&amp;ldquo;)判断这个分隔符中的是不是 itemDefine(也就是{{define subTemp}}来定义额外的模板树)，如果是，开始解析子模板树并跳过这一轮循环，如果不是回到itemLeftDelim之前从新解析&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Tree.textOrAction&lt;/code&gt;返回下一个Node放入&lt;code&gt;t.Root&lt;/code&gt;中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下一步我们来看看textOrAction干了什么&lt;/p&gt;

&lt;h5 id=&#34;textoraction&#34;&gt;textOrAction&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// textOrAction:
//	text | action
func (t *Tree) textOrAction() Node {
	switch token := t.nextNonSpace(); token.typ {
	case itemText:
		return t.newText(token.pos, token.val)
	case itemLeftDelim:
		return t.action()
	default:
		t.unexpected(token, &amp;quot;input&amp;quot;)
	}
	return nil
}


func (t *Tree) newText(pos Pos, text string) *TextNode {
	return &amp;amp;TextNode{tr: t, NodeType: NodeText, Pos: pos, Text: []byte(text)}
}

// Action:
//	control
//	command (&amp;quot;|&amp;quot; command)*
// Left delim is past. Now get actions.
// First word could be a keyword such as range.
func (t *Tree) action() (n Node) {
	switch token := t.nextNonSpace(); token.typ {
	case itemBlock:
		return t.blockControl()
	case itemElse:
		return t.elseControl()
	case itemEnd:
		return t.endControl()
	case itemIf:
		return t.ifControl()
	case itemRange:
		return t.rangeControl()
	case itemTemplate:
		return t.templateControl()
	case itemWith:
		return t.withControl()
	}
	t.backup()
	token := t.peek()
	// Do not pop variables; they persist until &amp;quot;end&amp;quot;.
	return t.newAction(token.pos, token.line, t.pipeline(&amp;quot;command&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;textOrAction非常简单，就是把item分成2部分，遇到itemText就解析成&lt;code&gt;TextNode&lt;/code&gt;遇到&lt;code&gt;{{&lt;/code&gt;就开始action解析&lt;/p&gt;

&lt;p&gt;所以继续看几个关键的action函数这部分就算完成了&lt;/p&gt;

&lt;h5 id=&#34;ifnode&#34;&gt;IfNode&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// If:
//	{{if pipeline}} itemList {{end}}
//	{{if pipeline}} itemList {{else}} itemList {{end}}
// If keyword is past.
func (t *Tree) ifControl() Node {
	return t.newIf(t.parseControl(true, &amp;quot;if&amp;quot;))
}

func (t *Tree) newIf(pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) *IfNode {
	return &amp;amp;IfNode{BranchNode{tr: t, NodeType: NodeIf, Pos: pos, Line: line, Pipe: pipe, List: list, ElseList: elseList}}
}

func (t *Tree) parseControl(allowElseIf bool, context string) (pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) {
	defer t.popVars(len(t.vars))
	pipe = t.pipeline(context)
	var next Node
	list, next = t.itemList()
	switch next.Type() {
	case nodeEnd: //done
	case nodeElse:
		if allowElseIf {
			// Special case for &amp;quot;else if&amp;quot;. If the &amp;quot;else&amp;quot; is followed immediately by an &amp;quot;if&amp;quot;,
			// the elseControl will have left the &amp;quot;if&amp;quot; token pending. Treat
			//	{{if a}}_{{else if b}}_{{end}}
			// as
			//	{{if a}}_{{else}}{{if b}}_{{end}}{{end}}.
			// To do this, parse the if as usual and stop at it {{end}}; the subsequent{{end}}
			// is assumed. This technique works even for long if-else-if chains.
			// TODO: Should we allow else-if in with and range?
			if t.peek().typ == itemIf {
				t.next() // Consume the &amp;quot;if&amp;quot; token.
				elseList = t.newList(next.Position())
				elseList.append(t.ifControl())
				// Do not consume the next item - only one {{end}} required.
				break
			}
		}
		elseList, next = t.itemList()
		if next.Type() != nodeEnd {
			t.errorf(&amp;quot;expected end; found %s&amp;quot;, next)
		}
	}
	return pipe.Position(), pipe.Line, pipe, list, elseList
}

// itemList:
//	textOrAction*
// Terminates at {{end}} or {{else}}, returned separately.
func (t *Tree) itemList() (list *ListNode, next Node) {
	list = t.newList(t.peekNonSpace().pos)
	for t.peekNonSpace().typ != itemEOF {
		n := t.textOrAction()
		switch n.Type() {
		case nodeEnd, nodeElse:
			return list, n
		}
		list.append(n)
	}
	t.errorf(&amp;quot;unexpected EOF&amp;quot;)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数内容太多我就跳过细节了&lt;/p&gt;

&lt;p&gt;首先ifControl/rangeControl/withControl/rangeControl需要调用parseControl，也可以理解为所有&lt;code&gt;{{ }}&lt;/code&gt;可以支持语句的都需要通过该函数来解析，比如pipeline &lt;code&gt;|&lt;/code&gt; 或者函数调用等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;parseControl&lt;/code&gt;逻辑&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把 &lt;code&gt;{{}}&lt;/code&gt;中所有内容解析成&lt;code&gt;PipeNode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;Tree.itemList&lt;/code&gt;尝试获取ElseNode和EndNode&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在最后，我们来看看下面例子生成的node是怎么样的,以下是letter模板生成的Node结构，缩进表示层级&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;testdata/letter.tmpl:1:0 (NodeList)
 testdata/letter.tmpl:1:0 (NodeText)
 testdata/letter.tmpl:1:7 (NodeAction)
  testdata/letter.tmpl:1:7 (NodePipe)
   testdata/letter.tmpl:1:7 (NodeCommand)
    testdata/letter.tmpl:1:7 (NodeField)
 testdata/letter.tmpl:1:14 (NodeText)
 testdata/letter.tmpl:2:5 (NodeIf)
  testdata/letter.tmpl:2:5 (NodePipe)
   testdata/letter.tmpl:2:5 (NodeCommand)
    testdata/letter.tmpl:2:5 (NodeField)
  testdata/letter.tmpl:2:16 (NodeList)
   testdata/letter.tmpl:2:16 (NodeText)
  testdata/letter.tmpl:4:10 (NodeList)
   testdata/letter.tmpl:4:10 (NodeText)
 testdata/letter.tmpl:6:9 (NodeText)
 testdata/letter.tmpl:7:7 (NodeWith)
  testdata/letter.tmpl:7:7 (NodePipe)
   testdata/letter.tmpl:7:7 (NodeCommand)
    testdata/letter.tmpl:7:7 (NodeField)
  testdata/letter.tmpl:8:4 (NodeList)
   testdata/letter.tmpl:8:4 (NodeText)
   testdata/letter.tmpl:8:31 (NodeAction)
    testdata/letter.tmpl:8:31 (NodePipe)
     testdata/letter.tmpl:8:31 (NodeCommand)
      testdata/letter.tmpl:8:31 (NodeDot)
   testdata/letter.tmpl:8:34 (NodeText)
 testdata/letter.tmpl:9:7 (NodeText)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下&lt;/p&gt;

&lt;p&gt;text/template通过 lex 将文本解析成一个个item,然后通过&lt;code&gt;Tree.parse&lt;/code&gt;生成一个有层级关系的node，最后通过 &lt;code&gt;Execute&lt;/code&gt;生成文本，下面来介绍模板Execute&lt;/p&gt;

&lt;p&gt;其实和语言编译原理有点像，词法解析器-&amp;gt;语法解析器-&amp;gt;编译成一个对象-&amp;gt;根据执行参数的不同输出不同结果&lt;/p&gt;

&lt;h4 id=&#34;模板execute&#34;&gt;模板Execute&lt;/h4&gt;

&lt;p&gt;execute就很简单了，基本就是该循环循环，该打印打印，&lt;/p&gt;

&lt;p&gt;Pipe里面只有当node.Pipe.Decl为0才会把Pipe中的值渲染出来，不然只是一次赋值，&lt;/p&gt;

&lt;p&gt;稍微能讲讲的就是node.Pipe&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Execute applies a parsed template to the specified data object,
// and writes the output to wr.
// If an error occurs executing the template or writing its output,
// execution stops, but partial results may already have been written to
// the output writer.
// A template may be executed safely in parallel, although if parallel
// executions share a Writer the output may be interleaved.
//
// If data is a reflect.Value, the template applies to the concrete
// value that the reflect.Value holds, as in fmt.Print.
func (t *Template) Execute(wr io.Writer, data interface{}) error {
	return t.execute(wr, data)
}

func (t *Template) execute(wr io.Writer, data interface{}) (err error) {
	defer errRecover(&amp;amp;err)
	value, ok := data.(reflect.Value)
	if !ok {
		value = reflect.ValueOf(data)
	}
	state := &amp;amp;state{
		tmpl: t,
		wr:   wr,
		vars: []variable{{&amp;quot;$&amp;quot;, value}},
	}
	if t.Tree == nil || t.Root == nil {
		state.errorf(&amp;quot;%q is an incomplete or empty template&amp;quot;, t.Name())
	}
	state.walk(value, t.Root)
	return
}

// Walk functions step through the major pieces of the template structure,
// generating output as they go.
func (s *state) walk(dot reflect.Value, node parse.Node) {
	s.at(node)
	switch node := node.(type) {
	case *parse.ActionNode:
		// Do not pop variables so they persist until next end.
		// Also, if the action declares variables, don&#39;t print the result.
		val := s.evalPipeline(dot, node.Pipe)
		if len(node.Pipe.Decl) == 0 {
			s.printValue(node, val)
		}
	case *parse.IfNode:
		s.walkIfOrWith(parse.NodeIf, dot, node.Pipe, node.List, node.ElseList)
	case *parse.ListNode:
		for _, node := range node.Nodes {
			s.walk(dot, node)
		}
	case *parse.RangeNode:
		s.walkRange(dot, node)
	case *parse.TemplateNode:
		s.walkTemplate(dot, node)
	case *parse.TextNode:
		if _, err := s.wr.Write(node.Text); err != nil {
			s.writeError(err)
		}
	case *parse.WithNode:
		s.walkIfOrWith(parse.NodeWith, dot, node.Pipe, node.List, node.ElseList)
	default:
		s.errorf(&amp;quot;unknown node: %s&amp;quot;, node)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看看Pipe的解析时怎么样的&lt;/p&gt;

&lt;p&gt;执行里面的cmds，然后跳过&lt;code&gt;interface{}&lt;/code&gt;对象拿里面的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Eval functions evaluate pipelines, commands, and their elements and extract
// values from the data structure by examining fields, calling methods, and so on.
// The printing of those values happens only through walk functions.

// evalPipeline returns the value acquired by evaluating a pipeline. If the
// pipeline has a variable declaration, the variable will be pushed on the
// stack. Callers should therefore pop the stack after they are finished
// executing commands depending on the pipeline value.
func (s *state) evalPipeline(dot reflect.Value, pipe *parse.PipeNode) (value reflect.Value) {
	if pipe == nil {
		return
	}
	s.at(pipe)
	value = missingVal
	for _, cmd := range pipe.Cmds {
		value = s.evalCommand(dot, cmd, value) // previous value is this one&#39;s final arg.
		// If the object has type interface{}, dig down one level to the thing inside.
		if value.Kind() == reflect.Interface &amp;amp;&amp;amp; value.Type().NumMethod() == 0 {
			value = reflect.ValueOf(value.Interface()) // lovely!
		}
	}
	for _, variable := range pipe.Decl {
		if pipe.IsAssign {
			s.setVar(variable.Ident[0], value)
		} else {
			s.push(variable.Ident[0], value)
		}
	}
	return value
}


func (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value {
	firstWord := cmd.Args[0]
	switch n := firstWord.(type) {
	case *parse.FieldNode:
		return s.evalFieldNode(dot, n, cmd.Args, final)
	case *parse.ChainNode:
		return s.evalChainNode(dot, n, cmd.Args, final)
	case *parse.IdentifierNode:
		// Must be a function.
		return s.evalFunction(dot, n, cmd, cmd.Args, final)
	case *parse.PipeNode:
		// Parenthesized pipeline. The arguments are all inside the pipeline; final is ignored.
		return s.evalPipeline(dot, n)
	case *parse.VariableNode:
		return s.evalVariableNode(dot, n, cmd.Args, final)
	}
	s.at(firstWord)
	s.notAFunction(cmd.Args, final)
	switch word := firstWord.(type) {
	case *parse.BoolNode:
		return reflect.ValueOf(word.True)
	case *parse.DotNode:
		return dot
	case *parse.NilNode:
		s.errorf(&amp;quot;nil is not a command&amp;quot;)
	case *parse.NumberNode:
		return s.idealConstant(word)
	case *parse.StringNode:
		return reflect.ValueOf(word.Text)
	}
	s.errorf(&amp;quot;can&#39;t evaluate command %q&amp;quot;, firstWord)
	panic(&amp;quot;not reached&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go模板就写到这里，里面代码给人一种零乱的感觉，但是代码意图和注释还是很清晰的，看函数名和注释能猜到个大概&lt;/p&gt;

&lt;p&gt;抛开代码结构不说，go的template的语法自成一派让人用起来很不舒服，每次使用都得查查文档，如果能和go语法统一就好了&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go module无法拉取库的原因排查</title>
      <link>https://bigpigeon.org/post/go-change-compile-source-code/</link>
      <pubDate>Mon, 23 Sep 2019 16:58:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/go-change-compile-source-code/</guid>
      <description>&lt;p&gt;有个同事问我go module突然无法拉取他写的某个库了，报了个以下错误，而且他说昨天还能拉，今天突然不行了，并且不久前又刚好重启过gitlab服务器，所以想确认是不是gitlab某些配置改了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package xxx.internel.io/lib/with-lfs: unknown import path &amp;quot;xxx.internel.io/lib/with-lfs&amp;quot;: downloaded zip file too large
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在多方信息干扰下我先从gitlab查起，当然比较竟然叫 &lt;code&gt;go module无法拉取库的原因排查&lt;/code&gt;,问题自然不在这，在我确保gitlab的配置和重启前完全一致后,并且排除了git lfs导致的问题，我把怀疑目标移到了go module上&lt;/p&gt;

&lt;p&gt;在一番google我找到了 &lt;a href=&#34;https://github.com/golang/go/issues/29987&#34;&gt;issue&lt;/a&gt; 应该就是对应这个问题的，但一直没有close,看来是没解决&lt;/p&gt;

&lt;p&gt;但我不甘心，好歹找到问题了，如果得到的答案是无法解决这半天时间岂不是浪费了，于是乎我开始查看go源码，找到&lt;code&gt;downloaded zip file too large&lt;/code&gt;关键字对应的行&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd $GOROOT
$ grep -I  -r -n &amp;quot;downloaded zip file too large&amp;quot;
src/cmd/go/internal/modfetch/proxy.go:396:		return p.versionError(version, fmt.Errorf(&amp;quot;downloaded zip file too large&amp;quot;))
src/cmd/go/internal/modfetch/coderepo.go:807:		return fmt.Errorf(&amp;quot;downloaded zip file too large&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到后就好办了，首先使用&lt;code&gt;dlv&lt;/code&gt; debug看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 编译go之前把go module关掉
$ export GO111MODULE=off
$ go build -gcflags &amp;quot;all=-N -l&amp;quot; -o debug-go $GOROOT/src/cmd/go
# 打开go module保证go使用module拉取项目
$ export GO111MODULE=on
$ dlv exec -- ./debug-go get xxx.internel.io/lib/with-lfs
# 进入交互模式，打好断点就可以跑了
(dlv) break src/cmd/go/internal/modfetch/proxy.go:396
(dlv) break src/cmd/go/internal/modfetch/coderepo.go:807
(dlv) continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待到达错误断点然后开始debug就好了&lt;/p&gt;

&lt;p&gt;也可以使用一些IDE，比如goland,这样可以得到比较好的交互体验，因为我懒得截图，所以就用命令行来说明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go: xxx.internel.io/lib/with-lfs v0.2.6
&amp;gt; cmd/go/internal/modfetch.(*codeRepo).Zip() /home/benjamin/.go/src/cmd/go/internal/modfetch/coderepo.go:807 (hits goroutine(47):1 total:1) (PC: 0xa97844)
   802:			dl.Close()
   803:			return err
   804:		}
   805:		dl.Close()
   806:		if lr.N &amp;lt;= 0 {
=&amp;gt; 807:			return fmt.Errorf(&amp;quot;downloaded zip file too large&amp;quot;)
   808:		}
   809:		size := (maxSize + 1) - lr.N
   810:		if _, err := f.Seek(0, 0); err != nil {
   811:			return err
   812:		}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们跳过debug步骤，直接来说结论吧，go module 拉取项目全部逻辑&lt;/p&gt;

&lt;p&gt;通过 在 &lt;code&gt;src/cmd/go/internal/modfetch/codehost/codehost.go:253&lt;/code&gt; 打断点就可以看到go执行的所以exec&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化项目&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;src/cmd/go/internal/modfetch/codehost/git.go:76
# 其中hash值就是 sha256.Sum256([]byte(&amp;quot;git3:https://xxx.internel.io/lib/with-lfs&amp;quot;)
cd $GOPATH/pkg/mod/cache/vcs/0f8908983e14c7e04862deff0f8df25b0a3477a4a53e91555891b8518004664d
git init --bare 
git remote add origin -- https://xxx.internel.io/lib/with-lfs
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;列出所有git 远程分支名，用一套规则匹配最合适的tag&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;git tag -l
git ls-remote -q origin 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;检查本地对应tag的分支存不存在，不存在则从远端拉取&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;git -c log.showsignature=false log -m --format=&amp;quot;format:%H %ct %D&amp;quot;  bf4fcb5a15f71ba8c5d50de10604048331ae94df --
git fetch -f --depth=1 origin refs/tags/v0.2.6:refs/tags/v0.2.6
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;再次查询tag信息&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;git -c log.showsignature=false log -n1 --format=&amp;quot;format:%H %ct %D&amp;quot; refs/tags/v0.2.6 --
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;查看该tag的&lt;code&gt;go.mod&lt;/code&gt;文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;git cat-file blob bf4fcb5a15f71ba8c5d50de10604048331ae94df:go.mod
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;把该分支整个打成zip包并解压(这一步git lfs才会真实下载需要的大文件),因为该Run函数执行的命令行返回值直接缓存到[]byte里，而不是一个Reader，于是乎相当于你的库有多大，该进程就得占多少内存&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;git -c core.autocrlf=input -c core.eol=lf archive --format=zip --prefix=prefix/ bf4fcb5a15f71ba8c5d50de10604048331ae94df
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;在TempDir下创建一个&lt;code&gt;go-codehost-&lt;/code&gt;前缀的文件并把刚刚的zip内容拷过去，当字节数大于&lt;code&gt;codehost.MaxZipFile&lt;/code&gt;时报错&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该代码在src/cmd/go/internal/modfetch/coderepo.go:781-804&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将zip文件解压放入&lt;code&gt;$GOPATH/pkg/mod/cache/download&lt;/code&gt;对应的项目目录&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该代码地址src/cmd/go/internal/modfetch/coderepo.go:820&lt;/p&gt;

&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;

&lt;p&gt;好了，目前的问题就出在第7步这里，当文件大于&lt;code&gt;codehost.MaxZipFile&lt;/code&gt;时，就会报错导致无法下载，所以解决方案嘛，就是加大codehost.MaxZipFile的值，我真机智&lt;/p&gt;

&lt;p&gt;首先将$GOROOT下面的代码拷贝到一个安全目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp -r $GOROOT /tmp/custom-go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改$GOROOT到安全目录去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOROOT=/tmp/custom-go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入新目录对应的cmd/go 目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp/custom-go/src/cmd/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改codehost.MaxZipFile到一个合适的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim internal/modfetch/codehost/codehost.go
// edit 31 line MaxZipFile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新build go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go build -o custom-go .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用这个custom-go去拉包就行了&lt;/p&gt;

&lt;h3 id=&#34;吐槽&#34;&gt;吐槽&lt;/h3&gt;

&lt;p&gt;看过源码，感觉go module这一块实现的很不好，首先在步骤6一定会把zip包写入内存，也就是说你限制只是针对拉下来后的包，不会减少进程内存使用，&lt;code&gt;func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64)&lt;/code&gt; 的maxSize也没有使用&lt;/p&gt;

&lt;p&gt;所以我才大胆改了&lt;code&gt;codehost.MaxZipFile&lt;/code&gt;,这个值目前作用不大，但是还是不建议大家改go源码，到时候出问题就坑了，而且go的包这么大本来就不对&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes官方kubeadm部署笔记</title>
      <link>https://bigpigeon.org/post/kubernetes-deployment/</link>
      <pubDate>Tue, 30 Apr 2019 11:47:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/kubernetes-deployment/</guid>
      <description>&lt;p&gt;老的k8s环境太乱，而且版本太老，但因为历史原因无法更新，于是我觉得在新的测试服部署一台新的k8s集群，并把所有服务慢慢迁移到新集群来&lt;/p&gt;

&lt;p&gt;这里做一个k8s部署(踩坑)笔记&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;准备阶段&#34;&gt;准备阶段&lt;/h2&gt;

&lt;h4 id=&#34;3台机器&#34;&gt;3台机器&lt;/h4&gt;

&lt;p&gt;需要准备至少3台机器，我这里用的是&lt;a href=&#34;https://linux.die.net/man/1/virsh&#34;&gt;virsh&lt;/a&gt;虚拟出3台ubuntu-18.04&lt;/p&gt;

&lt;p&gt;这是我其中一台机器的配置，其他机器也是类似配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;domain type=&#39;kvm&#39; id=&#39;1&#39;&amp;gt;
  &amp;lt;name&amp;gt;k8s-01&amp;lt;/name&amp;gt;
  &amp;lt;uuid&amp;gt;eec00f24-7b85-4032-93c8-121d1abd5ee9&amp;lt;/uuid&amp;gt;
  &amp;lt;memory unit=&#39;KiB&#39;&amp;gt;8388608&amp;lt;/memory&amp;gt;
  &amp;lt;currentMemory unit=&#39;KiB&#39;&amp;gt;8388608&amp;lt;/currentMemory&amp;gt;
  &amp;lt;vcpu placement=&#39;static&#39;&amp;gt;8&amp;lt;/vcpu&amp;gt;
  &amp;lt;resource&amp;gt;
    &amp;lt;partition&amp;gt;/machine&amp;lt;/partition&amp;gt;
  &amp;lt;/resource&amp;gt;
  &amp;lt;os&amp;gt;
    &amp;lt;type arch=&#39;x86_64&#39; machine=&#39;pc-i440fx-xenial&#39;&amp;gt;hvm&amp;lt;/type&amp;gt;
  &amp;lt;/os&amp;gt;
  &amp;lt;features&amp;gt;
    &amp;lt;acpi/&amp;gt;
    &amp;lt;apic/&amp;gt;
  &amp;lt;/features&amp;gt;
  &amp;lt;clock offset=&#39;utc&#39;&amp;gt;
    &amp;lt;timer name=&#39;rtc&#39; tickpolicy=&#39;catchup&#39;/&amp;gt;
    &amp;lt;timer name=&#39;pit&#39; tickpolicy=&#39;delay&#39;/&amp;gt;
    &amp;lt;timer name=&#39;hpet&#39; present=&#39;no&#39;/&amp;gt;
  &amp;lt;/clock&amp;gt;
  &amp;lt;on_poweroff&amp;gt;destroy&amp;lt;/on_poweroff&amp;gt;
  &amp;lt;on_reboot&amp;gt;restart&amp;lt;/on_reboot&amp;gt;
  &amp;lt;on_crash&amp;gt;restart&amp;lt;/on_crash&amp;gt;
  &amp;lt;pm&amp;gt;
    &amp;lt;suspend-to-mem enabled=&#39;no&#39;/&amp;gt;
    &amp;lt;suspend-to-disk enabled=&#39;no&#39;/&amp;gt;
  &amp;lt;/pm&amp;gt;
  &amp;lt;devices&amp;gt;
    &amp;lt;emulator&amp;gt;/usr/bin/kvm-spice&amp;lt;/emulator&amp;gt;
    &amp;lt;disk type=&#39;block&#39; device=&#39;disk&#39;&amp;gt;
      &amp;lt;driver name=&#39;qemu&#39; type=&#39;raw&#39;/&amp;gt;
      &amp;lt;source dev=&#39;/dev/sdb2&#39;/&amp;gt;
      &amp;lt;backingStore/&amp;gt;
      &amp;lt;target dev=&#39;vdb&#39; bus=&#39;virtio&#39;/&amp;gt;
      &amp;lt;boot order=&#39;1&#39;/&amp;gt;
      &amp;lt;alias name=&#39;virtio-disk1&#39;/&amp;gt;
      &amp;lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x06&#39; function=&#39;0x0&#39;/&amp;gt;
    &amp;lt;/disk&amp;gt;
    &amp;lt;disk type=&#39;file&#39; device=&#39;cdrom&#39;&amp;gt;
      &amp;lt;driver name=&#39;qemu&#39; type=&#39;raw&#39;/&amp;gt;
      &amp;lt;source file=&#39;/home/speakin/ubuntu-18.04.2-live-server-amd64.iso&#39;/&amp;gt;
      &amp;lt;backingStore/&amp;gt;
      &amp;lt;target dev=&#39;hda&#39; bus=&#39;ide&#39;/&amp;gt;
      &amp;lt;readonly/&amp;gt;
      &amp;lt;alias name=&#39;ide0-0-0&#39;/&amp;gt;
      &amp;lt;address type=&#39;drive&#39; controller=&#39;0&#39; bus=&#39;0&#39; target=&#39;0&#39; unit=&#39;0&#39;/&amp;gt;
    &amp;lt;/disk&amp;gt;
    &amp;lt;controller type=&#39;pci&#39; index=&#39;0&#39; model=&#39;pci-root&#39;&amp;gt;
      &amp;lt;alias name=&#39;pci.0&#39;/&amp;gt;
    &amp;lt;/controller&amp;gt;
    &amp;lt;controller type=&#39;ide&#39; index=&#39;0&#39;&amp;gt;
      &amp;lt;alias name=&#39;ide&#39;/&amp;gt;
      &amp;lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x01&#39; function=&#39;0x1&#39;/&amp;gt;
    &amp;lt;/controller&amp;gt;
    &amp;lt;controller type=&#39;virtio-serial&#39; index=&#39;0&#39;&amp;gt;
      &amp;lt;alias name=&#39;virtio-serial0&#39;/&amp;gt;
      &amp;lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x05&#39; function=&#39;0x0&#39;/&amp;gt;
    &amp;lt;/controller&amp;gt;
    &amp;lt;controller type=&#39;usb&#39; index=&#39;0&#39;&amp;gt;
      &amp;lt;alias name=&#39;usb&#39;/&amp;gt;
      &amp;lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x01&#39; function=&#39;0x2&#39;/&amp;gt;
    &amp;lt;/controller&amp;gt;
    &amp;lt;interface type=&#39;bridge&#39;&amp;gt;
      &amp;lt;mac address=&#39;52:54:00:e7:53:84&#39;/&amp;gt;
      &amp;lt;source bridge=&#39;br0&#39;/&amp;gt;
      &amp;lt;target dev=&#39;vnet0&#39;/&amp;gt;
      &amp;lt;model type=&#39;virtio&#39;/&amp;gt;
      &amp;lt;alias name=&#39;net0&#39;/&amp;gt;
      &amp;lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x03&#39; function=&#39;0x0&#39;/&amp;gt;
    &amp;lt;/interface&amp;gt;
    &amp;lt;serial type=&#39;pty&#39;&amp;gt;
      &amp;lt;source path=&#39;/dev/pts/0&#39;/&amp;gt;
      &amp;lt;target port=&#39;0&#39;/&amp;gt;
      &amp;lt;alias name=&#39;serial0&#39;/&amp;gt;
    &amp;lt;/serial&amp;gt;
    &amp;lt;console type=&#39;pty&#39; tty=&#39;/dev/pts/0&#39;&amp;gt;
      &amp;lt;source path=&#39;/dev/pts/0&#39;/&amp;gt;
      &amp;lt;target type=&#39;serial&#39; port=&#39;0&#39;/&amp;gt;
      &amp;lt;alias name=&#39;serial0&#39;/&amp;gt;
    &amp;lt;/console&amp;gt;
    &amp;lt;channel type=&#39;spicevmc&#39;&amp;gt;
      &amp;lt;target type=&#39;virtio&#39; name=&#39;com.redhat.spice.0&#39; state=&#39;disconnected&#39;/&amp;gt;
      &amp;lt;alias name=&#39;channel0&#39;/&amp;gt;
      &amp;lt;address type=&#39;virtio-serial&#39; controller=&#39;0&#39; bus=&#39;0&#39; port=&#39;1&#39;/&amp;gt;
    &amp;lt;/channel&amp;gt;
    &amp;lt;input type=&#39;mouse&#39; bus=&#39;ps2&#39;/&amp;gt;
    &amp;lt;input type=&#39;keyboard&#39; bus=&#39;ps2&#39;/&amp;gt;
    &amp;lt;graphics type=&#39;spice&#39; port=&#39;5900&#39; autoport=&#39;yes&#39; listen=&#39;127.0.0.1&#39;&amp;gt;
      &amp;lt;listen type=&#39;address&#39; address=&#39;127.0.0.1&#39;/&amp;gt;
    &amp;lt;/graphics&amp;gt;
    &amp;lt;graphics type=&#39;vnc&#39; port=&#39;5901&#39; autoport=&#39;yes&#39; listen=&#39;127.0.0.1&#39;&amp;gt;
      &amp;lt;listen type=&#39;address&#39; address=&#39;127.0.0.1&#39;/&amp;gt;
    &amp;lt;/graphics&amp;gt;
    &amp;lt;sound model=&#39;ich6&#39;&amp;gt;
      &amp;lt;alias name=&#39;sound0&#39;/&amp;gt;
      &amp;lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x04&#39; function=&#39;0x0&#39;/&amp;gt;
    &amp;lt;/sound&amp;gt;
    &amp;lt;video&amp;gt;
      &amp;lt;model type=&#39;qxl&#39; ram=&#39;65536&#39; vram=&#39;65536&#39; vgamem=&#39;16384&#39; heads=&#39;1&#39;/&amp;gt;
      &amp;lt;alias name=&#39;video0&#39;/&amp;gt;
      &amp;lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x02&#39; function=&#39;0x0&#39;/&amp;gt;
    &amp;lt;/video&amp;gt;
    &amp;lt;redirdev bus=&#39;usb&#39; type=&#39;spicevmc&#39;&amp;gt;
      &amp;lt;alias name=&#39;redir0&#39;/&amp;gt;
    &amp;lt;/redirdev&amp;gt;
    &amp;lt;redirdev bus=&#39;usb&#39; type=&#39;spicevmc&#39;&amp;gt;
      &amp;lt;alias name=&#39;redir1&#39;/&amp;gt;
    &amp;lt;/redirdev&amp;gt;
    &amp;lt;memballoon model=&#39;virtio&#39;&amp;gt;
      &amp;lt;alias name=&#39;balloon0&#39;/&amp;gt;
      &amp;lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x00&#39; slot=&#39;0x08&#39; function=&#39;0x0&#39;/&amp;gt;
    &amp;lt;/memballoon&amp;gt;
  &amp;lt;/devices&amp;gt;
  &amp;lt;seclabel type=&#39;dynamic&#39; model=&#39;apparmor&#39; relabel=&#39;yes&#39;&amp;gt;
    &amp;lt;label&amp;gt;libvirt-eec00f24-7b85-4032-93c8-121d1abd5ee9&amp;lt;/label&amp;gt;
    &amp;lt;imagelabel&amp;gt;libvirt-eec00f24-7b85-4032-93c8-121d1abd5ee9&amp;lt;/imagelabel&amp;gt;
  &amp;lt;/seclabel&amp;gt;
&amp;lt;/domain&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;一个vpn用来科学上网&#34;&gt;一个vpn用来科学上网&lt;/h4&gt;

&lt;p&gt;部署k8s最好用vpn而不是代理，因为k8s里面很多工具可能使用的代理方式都不一样，而且有些命令是在docker里面跑的，你还得跑进去配置&lt;/p&gt;

&lt;p&gt;vpn要确保网段不与k8s的网段冲突&lt;/p&gt;

&lt;h2 id=&#34;部署master机器&#34;&gt;部署master机器&lt;/h2&gt;

&lt;h4 id=&#34;使用docker作为k8s的cri&#34;&gt;使用docker作为k8s的cri&lt;/h4&gt;

&lt;p&gt;以下代码都是照抄k8s官网,只把docker的&lt;strong&gt;&amp;ldquo;exec-opts&amp;rdquo;: [&amp;ldquo;native.cgroupdriver=systemd&amp;rdquo;],&lt;/strong&gt; 改成 &lt;strong&gt;&amp;ldquo;exec-opts&amp;rdquo;: [&amp;ldquo;native.cgroupdriver=cgroupfs&amp;rdquo;],&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install Docker CE
## Set up the repository:
### Install packages to allow apt to use a repository over HTTPS
apt-get update &amp;amp;&amp;amp; apt-get install apt-transport-https ca-certificates curl software-properties-common

### Add Docker’s official GPG key
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -

### Add Docker apt repository.
add-apt-repository \
  &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) \
  stable&amp;quot;

## Install Docker CE.
apt-get update &amp;amp;&amp;amp; apt-get install docker-ce=18.06.2~ce~3-0~ubuntu

# Setup daemon.
cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;exec-opts&amp;quot;: [&amp;quot;native.cgroupdriver=cgroupfs&amp;quot;],
  &amp;quot;log-driver&amp;quot;: &amp;quot;json-file&amp;quot;,
  &amp;quot;log-opts&amp;quot;: {
    &amp;quot;max-size&amp;quot;: &amp;quot;100m&amp;quot;
  },
  &amp;quot;storage-driver&amp;quot;: &amp;quot;overlay2&amp;quot;
}
EOF

mkdir -p /etc/systemd/system/docker.service.d

# Restart docker.
systemctl daemon-reload
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;安装k8s三件套&#34;&gt;安装k8s三件套&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https curl
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list
deb https://apt.kubernetes.io/ kubernetes-xenial main
EOF
apt-get update
apt-get install -y kubelet kubeadm kubectl
apt-mark hold kubelet kubeadm kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;修改kubelet的env参数&#34;&gt;修改kubelet的Env参数&lt;/h4&gt;

&lt;p&gt;这里使用cgroupfs是 因为这个 issue &lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/71887&#34;&gt;https://github.com/kubernetes/kubernetes/issues/71887&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat &amp;gt; /var/lib/kubelet/kubeadm-flags.env &amp;lt;&amp;lt;EOF
KUBELET_KUBEADM_ARGS=--cgroup-driver=cgroupfs --network-plugin=cni --resolv-conf=/run/systemd/resolve/resolv.conf
EOF

cat &amp;gt; /etc/default/kubelet &amp;lt;&amp;lt;EOF
KUBELET_EXTRA_ARGS=--cgroup-driver=cgroupfs
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用kubeadm初始化master节点&#34;&gt;使用kubeadm初始化master节点&lt;/h4&gt;

&lt;p&gt;因为我们用flannel作为我们的cni，所以要指定一个network-cidr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubeadm init --pod-network-cidr=10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置kubectl&#34;&gt;配置kubectl&lt;/h4&gt;

&lt;p&gt;参照官方文档，只要吧/etc/kubernetes/admin.conf放到你机器对应的$HOME/.kube/config 目录,kubectl就能连上k8s了&lt;/p&gt;

&lt;p&gt;多个k8s,也可以使用kubectl &amp;ndash;kubeconfig config 指定对应k8s&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用kubectl-安装flannel&#34;&gt;使用kubectl 安装flannel&lt;/h4&gt;

&lt;p&gt;k8s必须在部署app之前安装cni，不然k8s的网络和dns无法使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待安装完成&lt;/p&gt;

&lt;h4 id=&#34;使用kubectl-安装dashboard&#34;&gt;使用kubectl 安装dashboard&lt;/h4&gt;

&lt;p&gt;安装 dashboard&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过kubelet创建service account&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建cluster role binding 绑定admin-user&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取登录授权token&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用proxy代理k8s&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; kubectl proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器访问dashboard,在里面使用token登录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建一个k8s的token&#34;&gt;创建一个k8s的token&lt;/h4&gt;

&lt;p&gt;每个k8s cluster要加入master都需要创建一个token，可以使用下面命令创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubeadm token create
// 5didvk.d09sbcov8ph2amjw 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过下面命令查看已有的token&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubeadm token list
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查看ca证书的hash值&#34;&gt;查看ca证书的hash值&lt;/h4&gt;

&lt;p&gt;cluster机器加入时需要该值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&amp;gt;/dev/null | openssl dgst -sha256 -hex | sed &#39;s/^.* //&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;部署cluster机器&#34;&gt;部署cluster机器&lt;/h2&gt;

&lt;p&gt;cluster机器比较简单，只需要安装docker和k8s三件套，然后使用token加入master即可&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#使用docker作为k8s的cri&#34;&gt;安装docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#安装k8s三件套&#34;&gt;安装k8s三件套&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;加入k8s-master节点&#34;&gt;加入k8s master节点&lt;/h4&gt;

&lt;p&gt;加入节点需要一个刚才在master的token和ca证书hash值，&lt;strong&gt;master-port&lt;/strong&gt;默认是6443&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubeadm join &amp;lt;master-ip&amp;gt;:&amp;lt;master-port&amp;gt; --token &amp;lt;token&amp;gt; --discovery-token-ca-cert-hash sha256:&amp;lt;hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重置k8s&#34;&gt;重置k8s&lt;/h2&gt;

&lt;p&gt;如果你在安装k8s过程中某些改动或者网络情况导致不可用，可以使用下面命令，然后重新安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubeadm reset 
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>使用go/ast来解析go文件III</title>
      <link>https://bigpigeon.org/post/go-ast-walk/</link>
      <pubDate>Sun, 23 Sep 2018 12:42:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/go-ast-walk/</guid>
      <description>&lt;p&gt;可能很多人想问types中的Type和Object接口有什么区别&lt;/p&gt;

&lt;p&gt;我觉得Object可以理解为有实体的Type或者是对Type的定义，Type则是一个Object的抽象&lt;/p&gt;

&lt;p&gt;比如type V1 struct {Name string}  和type V2 struct {Name string} V1和V2属于不同Object但它们的Underlying Type是一样的(Type不一样是因为它们是一个Named Type类型) ,不过type不能通过==来比较，必须用Identical&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面所有内容在这个&lt;a href=&#34;https://github.com/bigpigeon/Test/blob/master/go/blog_go_walk/main.go&#34;&gt;Example&lt;/a&gt;中有对应的测试代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们先来看看go/types中所有的Types实现&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Array&lt;/td&gt;
&lt;td&gt;固定长度数组类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Basic&lt;/td&gt;
&lt;td&gt;基本类型,比如int,string,float等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Chan&lt;/td&gt;
&lt;td&gt;通道类型，相当于线程安全的slice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Interface&lt;/td&gt;
&lt;td&gt;接口类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Map&lt;/td&gt;
&lt;td&gt;map类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Named&lt;/td&gt;
&lt;td&gt;所有用type起名字的自定义类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Pointer&lt;/td&gt;
&lt;td&gt;指针类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Signature&lt;/td&gt;
&lt;td&gt;所有函数或者method都属于这个类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Slice&lt;/td&gt;
&lt;td&gt;slice类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Struct&lt;/td&gt;
&lt;td&gt;结构体类型，注意:自定义的结构体是named类型，它的Underlying是Struct类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tuple&lt;/td&gt;
&lt;td&gt;函数的参数和返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;array-类型&#34;&gt;Array 类型&lt;/h3&gt;

&lt;p&gt;array类型中包括它的子类型Elem()和数组长度Len() 2个属性&lt;/p&gt;

&lt;h3 id=&#34;basic-类型&#34;&gt;Basic 类型&lt;/h3&gt;

&lt;p&gt;basic类型有Kind()和Info()2个属性，Kind是types.BasicKind类型，用来表示所有go的类型，如果import &amp;ldquo;C&amp;rdquo;，所有C.type都是Invalid类型&lt;/p&gt;

&lt;p&gt;而Info则是types.BasicInfo类型，使用&amp;amp;运算符比较类型，比如types.IsNumeric&amp;amp; x.Info() 可以知道这个类型是否为数字(数字可以是所有int，float,complex类型)&lt;/p&gt;

&lt;h3 id=&#34;chan-类型&#34;&gt;Chan 类型&lt;/h3&gt;

&lt;p&gt;chan类型有Dir()和Elem()方法&lt;/p&gt;

&lt;p&gt;其中Dir()返回types.ChanDir,它可以是SendRecv,SendOnly,RecvOnly分别表示 发送接收，只发送，只接收 3中channel类型&lt;/p&gt;

&lt;h3 id=&#34;接口类型&#34;&gt;接口类型&lt;/h3&gt;

&lt;p&gt;接口类型有ExplicitMethod，Embedded，Method 3个方法，分别对应对应获取自己定义的方法，获取嵌套Interface，获取包含嵌套的所有方法&lt;/p&gt;

&lt;p&gt;这3个方法有对应的Num方法拿到它们的总数&lt;/p&gt;

&lt;h3 id=&#34;map-类型&#34;&gt;map 类型&lt;/h3&gt;

&lt;p&gt;map类型有Key和Elem方法，分别对应map的key,value类型&lt;/p&gt;

&lt;h3 id=&#34;named-类型&#34;&gt;named 类型&lt;/h3&gt;

&lt;p&gt;named类型就是用户定义的类型，用户定义所有有名字的类型都是named&lt;/p&gt;

&lt;p&gt;named类型有个Obj方法，可以返回它对应的types.TypeName，TypeName是一个types.Object接口实现&lt;/p&gt;

&lt;p&gt;named 类型也是唯一使用Underlying方法返回的不是自身，可以说Underlying方法就是因为有named类型强加上去的&lt;/p&gt;

&lt;p&gt;named也有Method和NumMethods方法，用于查看该named下所定义的方法&lt;/p&gt;

&lt;p&gt;结合named和interface的Method可以非常方便的实现Interface实现扫描&lt;/p&gt;

&lt;h3 id=&#34;pointer-类型&#34;&gt;Pointer 类型&lt;/h3&gt;

&lt;p&gt;Pointer类型有一个Elem方法返回它的子类型&lt;/p&gt;

&lt;h3 id=&#34;signature-类型&#34;&gt;Signature 类型&lt;/h3&gt;

&lt;p&gt;所有方法和函数都属于这个类型，一些go的bulit-in函数和伪函数则不是，它们属于Basic类型&lt;/p&gt;

&lt;p&gt;Signature有Params和Results方法返回函数的参数和返回值，Params和Results本身则返回一个Tuple类型&lt;/p&gt;

&lt;p&gt;Signature还有一个Recv方法，用于返回方法类型的接收者&lt;/p&gt;

&lt;h3 id=&#34;slice类型&#34;&gt;Slice类型&lt;/h3&gt;

&lt;p&gt;Pointer类型有一个Elem方法返回它的成员类型&lt;/p&gt;

&lt;h3 id=&#34;struct类型&#34;&gt;Struct类型&lt;/h3&gt;

&lt;p&gt;struct类型的Field(int)方法返回结构体中第n个字段，而Tag方法则是对应字段的tag信息&lt;/p&gt;

&lt;p&gt;Field方法返回的是types.Var类型，它是type.Object接口的实现&lt;/p&gt;

&lt;h3 id=&#34;tuple类型&#34;&gt;Tuple类型&lt;/h3&gt;

&lt;p&gt;Tuple只会出现在Signature的参数和返回值中&lt;/p&gt;

&lt;p&gt;它有At(int)返回第n个字段的信息，该信息是types.Var类型，它是type.Object接口的实现&lt;/p&gt;

&lt;p&gt;Len方法则返回总字段数&lt;/p&gt;

&lt;h3 id=&#34;比对type类型&#34;&gt;比对Type类型&lt;/h3&gt;

&lt;p&gt;使用types.Identical函数可以比对2个type类型，返回bool值,比对的具体逻辑可以看下面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var idName1 struct {
	ID   int
	Name string
}

var idName2 struct {
	ID   int
	Name string
}

var idName3 struct {
	ID   int
	Name []byte
}

type IDName struct {
	ID   int
	Name string
}

var idName4 IDName

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中idName1和idName2是相同的类型，和idName3不同类型&lt;/p&gt;

&lt;p&gt;idName1和idName4也是不同类型，idName4属于Named type，所以比如和idName1不相等&lt;/p&gt;

&lt;h3 id=&#34;实现扫描&#34;&gt;实现扫描&lt;/h3&gt;

&lt;p&gt;使用types.Implements(T,I)可以判断T类型是否实现了接口I&lt;/p&gt;

&lt;p&gt;比如下面的Response就实现了Stringer接口，Implements比如返回true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Stringer interface {
	String() string
}

// named 类型包含它的method信息
type Response struct {
	Name  string
	Value string
	Buff  bytes.Buffer
}

func (r Response) String() string {
	return r.Name + &amp;quot; &amp;quot; + r.Value
}

func (r *Response) Write(w io.Writer) {
	r.Buff.WriteTo(w)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;types.Implements也可以对接口与接口之间的扫描，下面的WriteStringer也实现了Stringer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Stringer interface {
	String() string
}

type WriteStringer interface {
	String() string
	Writer(writer io.Writer)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;types.AssertableTo(I,T)则是判断T类型能否分配成I接口,可以理解为接口版的types.AssignableTo&lt;/p&gt;

&lt;p&gt;伪代码:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;types.AssertableTo(WriteStringer, Stringer) =&amp;gt; true&lt;/p&gt;

&lt;p&gt;types.AssertableTo(Stringer, Response) =&amp;gt; true&lt;/p&gt;

&lt;p&gt;types.AssertableTo(Stringer, WriteStringer) =&amp;gt; false&lt;/p&gt;

&lt;p&gt;types.AssertableTo(WriteStringer, Response) =&amp;gt; false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;类型转换判断&#34;&gt;类型转换判断&lt;/h3&gt;

&lt;p&gt;types.ConvertibleTo(T1,T2)可以用来判断T1类型能否转成T2类型&lt;/p&gt;

&lt;p&gt;通常使用type T2 T1的类型都可以互相转换，还有一些基本类型比如[]byte和string类型，int和int64/int32类型等&lt;/p&gt;

&lt;h3 id=&#34;赋值转换判断&#34;&gt;赋值转换判断&lt;/h3&gt;

&lt;p&gt;types.AssignableTo(T1,T2)可以判断T1类型是否可以赋给T2类型&lt;/p&gt;

&lt;p&gt;赋值转换和类型转换不同，它是一种软转换，也就是不需要带声明&lt;/p&gt;

&lt;p&gt;在go里面所有类型都是强类型，每个对象都有明确的类型标识，而软转换的条件就是不允许转换后的类型信息丢失&lt;/p&gt;

&lt;p&gt;所以只有3种情况可以接受转换：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同类型的转换&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;普通类型转接口类型或接口类型直接的转换，因为接口类型会携带源类型的信息，所以不算做信息丢失&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由一个untype类型转成符合条件的type类型比如42转int64,32.0转float64，&amp;rdquo;abc&amp;rdquo;转string类型&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用伪代码举几个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
var strType string
var interfaceType interface{}

var int64Type int = 24

const unintType = 42

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;types.AssignableTo(strType, interfaceType) =&amp;gt; true&lt;/p&gt;

&lt;p&gt;types.AssignableTo(24, int64Type) =&amp;gt; true&lt;/p&gt;

&lt;p&gt;types.AssignableTo(unintType, int64Type) =&amp;gt; false // 这个不知道是不是bug,理应能转的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;末尾&#34;&gt;末尾&lt;/h3&gt;

&lt;p&gt;types.Type的所有内容基本都介绍齐了，如有遗漏就遗漏了&lt;/p&gt;

&lt;p&gt;我也许还会出一篇关于types.Object介绍，也可能直接出一篇关于ast应用实践的博客，写ast实在是太累的，下期见&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用go/ast来解析go文件II</title>
      <link>https://bigpigeon.org/post/go-ast-type/</link>
      <pubDate>Wed, 23 May 2018 10:07:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/go-ast-type/</guid>
      <description>&lt;p&gt;在进行go文件解析经常需要对Ident对象的类型/值进行比较&lt;/p&gt;

&lt;p&gt;但go/ast只对单文件进行解析，并不适合用来比较类型，所以这个时候就需要用到另一个库go/types&lt;/p&gt;

&lt;p&gt;先来看看全部代码&lt;/p&gt;

&lt;p&gt;代码也可以通过&lt;a href=&#34;https://github.com/bigpigeon/Test/tree/master/go/blog_go_types&#34;&gt;这里&lt;/a&gt;下载，建议在看教程的同时运行这个demo代码&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
这是被分析的文件,在data/src.go中
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

// implicitly import
import &amp;quot;fmt&amp;quot;

import . &amp;quot;unsafe&amp;quot;

type Product struct {
	Name string
}

func (p Product) String() string {
	return &amp;quot;Product:&amp;quot; + p.Name
}

func ImplicitlyNode() {
	var d interface{} = 5
	switch x := d.(type) {
	case int:
		fmt.Println(x)
	default:
		fmt.Println(x)
	}
	var e func(int)
	fmt.Println(e)
}

func SelectionNode() {
	p := Product{Name: &amp;quot;t011&amp;quot;}
	fmt.Println(p.Name)
	fmt.Println(p.String())
	fmt.Println(Product.String(p))
	fmt.Println(Offsetof(p.Name))
}

const MaxRoutines = 100

var CurrentRoutines = 1

func main() { //test1
	fmt.Println(&amp;quot;Hello, World!&amp;quot;) //test2
	a := []int{1, 2, 3}
	fmt.Println(a)
	b := map[int]string{
		1: &amp;quot;a&amp;quot;,
		2: &amp;quot;b&amp;quot;,
	}
	fmt.Println(b)

	d := make(chan int, 5)
	fmt.Println(d)

	fmt.Println(MaxRoutines)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
使用types分析库并打印其中各种信息
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;go/ast&amp;quot;
	&amp;quot;go/importer&amp;quot;
	&amp;quot;go/parser&amp;quot;
	&amp;quot;go/token&amp;quot;
	&amp;quot;go/types&amp;quot;
	&amp;quot;reflect&amp;quot;
	&amp;quot;sort&amp;quot;
)

// 排序规则order by Pos(), End()
func sortNodes(nodes []ast.Node) {
	sort.Slice(nodes, func(i, j int) bool {
		if nodes[i].Pos() == nodes[j].Pos() {
			return nodes[i].End() &amp;lt; nodes[j].End()
		}
		return nodes[i].Pos() &amp;lt; nodes[j].Pos()
	})
}

// map中的元素是无序的，对key排序打印更好查看
func getSortedKeys(m interface{}) []ast.Node {
	mValue := reflect.ValueOf(m)
	nodes := make([]ast.Node, mValue.Len())
	keys := mValue.MapKeys()
	for i := range keys {
		nodes[i] = keys[i].Interface().(ast.Node)
	}
	sortNodes(nodes)
	return nodes
}

func main() {
	fset := token.NewFileSet() // 位置是相对于节点
	// 用ParseFile把文件解析成*ast.File节点
	f, err := parser.ParseFile(fset, &amp;quot;data/src.go&amp;quot;, nil, 0)
	if err != nil {
		panic(err)
	}

	// 使用types check
	// 构造config
	config := types.Config{
		// 加载包的方式，可以通过源码或编译好的包，其中编译好的包分为gc和gccgo,前者应该是
		Importer: importer.For(&amp;quot;source&amp;quot;, nil),
		// 表示允许包里面加载c库 import &amp;quot;c&amp;quot;
		FakeImportC: true,
	}

	info := &amp;amp;types.Info{
		// 表达式对应的类型
		Types: make(map[ast.Expr]types.TypeAndValue),
		// 被定义的标示符
		Defs: make(map[*ast.Ident]types.Object),
		// 被使用的标示符
		Uses: make(map[*ast.Ident]types.Object),
		// 隐藏节点，匿名import包，type-specific时的case对应的当前类型，声明函数的匿名参数如var func(int)
		Implicits: make(map[ast.Node]types.Object),
		// 选择器,只能针对类型/对象.字段/method的选择，package.API这种不会记录在这里
		Selections: make(map[*ast.SelectorExpr]*types.Selection),
		// scope 记录当前库scope下的所有域，*ast.File/*ast.FuncType/... 都属于scope，详情看Scopes说明
		// scope关系: 最外层Universe scope,之后Package scope，其他子scope
		Scopes: make(map[ast.Node]*types.Scope),
		// 记录所有package级的初始化值
		InitOrder: make([]*types.Initializer, 0, 0),
	}
	// 这里第一个path参数觉得当前pkg前缀，和FileSet的文件路径是无关的
	pkg, err := config.Check(&amp;quot;&amp;quot;, fset, []*ast.File{f}, info)

	if err != nil {
		panic(err)
	}
	// 打印types
	fmt.Println(&amp;quot;------------ types -----------&amp;quot;)
	for _, node := range getSortedKeys(info.Types) {
		expr := node.(ast.Expr)
		typeValue := info.Types[expr]
		fmt.Printf(&amp;quot;%s - %s %T it&#39;s value: %v type: %s\n&amp;quot;,
			fset.Position(expr.Pos()),
			fset.Position(expr.End()),
			expr,
			typeValue.Value,
			typeValue.Type.String(),
		)
		if typeValue.Assignable() {
			fmt.Print(&amp;quot;assignable &amp;quot;)
		}
		if typeValue.Addressable() {
			fmt.Print(&amp;quot;addressable &amp;quot;)
		}
		if typeValue.IsNil() {
			fmt.Print(&amp;quot;nil &amp;quot;)
		}
		if typeValue.HasOk() {
			fmt.Print(&amp;quot;has ok &amp;quot;)
		}
		if typeValue.IsBuiltin() {
			fmt.Print(&amp;quot;builtin &amp;quot;)
		}
		if typeValue.IsType() {
			fmt.Print(&amp;quot;is type &amp;quot;)
		}
		if typeValue.IsValue() {
			fmt.Print(&amp;quot;is value &amp;quot;)
		}
		if typeValue.IsVoid() {
			fmt.Print(&amp;quot;void &amp;quot;)
		}
		fmt.Println()
	}
	// 打印defs
	fmt.Println(&amp;quot;------------ def -----------&amp;quot;)
	for _, node := range getSortedKeys(info.Defs) {
		ident := node.(*ast.Ident)
		object := info.Defs[ident]
		fmt.Printf(&amp;quot;%s - %s %T&amp;quot;,
			fset.Position(ident.Pos()),
			fset.Position(ident.End()),
			object,
		)
		if object != nil {
			fmt.Printf(&amp;quot; it&#39;s object: %s type: %s&amp;quot;,
				object,
				object.Type().String(),
			)

		}
		fmt.Println()
	}
	// 打印Uses
	fmt.Println(&amp;quot;------------ uses -----------&amp;quot;)
	for _, node := range getSortedKeys(info.Uses) {
		ident := node.(*ast.Ident)
		object := info.Uses[ident]
		fmt.Printf(&amp;quot;%s - %s %T&amp;quot;,
			fset.Position(ident.Pos()),
			fset.Position(ident.End()),
			object,
		)
		if object != nil {
			fmt.Printf(&amp;quot; it&#39;s object: %s type: %s&amp;quot;,
				object,
				object.Type().String(),
			)

		}
		fmt.Println()
	}
	// 打印Implicits
	fmt.Println(&amp;quot;------------ implicits -----------&amp;quot;)
	for _, node := range getSortedKeys(info.Implicits) {
		object := info.Implicits[node]
		fmt.Printf(&amp;quot;%s - %s %T it&#39;s object: %s\n&amp;quot;,
			fset.Position(node.Pos()),
			fset.Position(node.End()),
			node,
			object,
		)
	}
	// 打印Selections
	fmt.Println(&amp;quot;------------ selections -----------&amp;quot;)
	for _, node := range getSortedKeys(info.Selections) {
		sel := node.(*ast.SelectorExpr)
		typeSel := info.Selections[sel]
		fmt.Printf(&amp;quot;%s - %s it&#39;s selection: %s\n&amp;quot;,
			fset.Position(sel.Pos()),
			fset.Position(sel.End()),
			typeSel.String(),
		)
		fmt.Printf(&amp;quot;receive: %s index: %v obj: %s\n&amp;quot;, typeSel.Recv(), typeSel.Index(), typeSel.Obj())
	}
	// 打印Scopes
	fmt.Println(&amp;quot;------------ scopes -----------&amp;quot;)
	//打印package scope
	fmt.Printf(&amp;quot;package level scope %s\n&amp;quot;,
		pkg.Scope().String(),
	)
	// 打印宇宙级scope
	fmt.Printf(&amp;quot;universe level scope %s\n&amp;quot;,
		pkg.Scope().Parent().String(),
	)
	for _, node := range getSortedKeys(info.Scopes) {
		scope := info.Scopes[node]
		fmt.Printf(&amp;quot;%s - %s %T it&#39;s scope %s\n&amp;quot;,
			fset.Position(node.Pos()),
			fset.Position(node.End()),
			node,
			scope.String(),
		)
	}
	// 打印InitOrder
	fmt.Println(&amp;quot;------------ init -----------&amp;quot;)
	for _, init := range info.InitOrder {
		fmt.Printf(&amp;quot;init %s\n&amp;quot;,
			init.String(),
		)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h4 id=&#34;构建types-config&#34;&gt;构建types.Config&lt;/h4&gt;

&lt;p&gt;types.Config决定如何去解析go代码，这里&lt;strong&gt;importer.For(&amp;ldquo;source&amp;rdquo;, nil)&lt;/strong&gt;表示通过源码的方式解析go库,FakeImportC表示允许加载C库&lt;/p&gt;

&lt;h4 id=&#34;创建types-info&#34;&gt;创建types.Info&lt;/h4&gt;

&lt;p&gt;types.Info决定要解析哪些信息，给字段赋值后在Config.Check是会对这部分信息进行解析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Types保存表达式对应的类型，
Defs保存所有被定义的标示符，包括package name（包名）和带名字的加载库(import _ &amp;quot;package&amp;quot; / import . &amp;quot;package&amp;quot;)
Uses保存所有被使用的标示符
Implicits保存三种隐藏节点,匿名import 的库(import &amp;quot;package&amp;quot;), type-specific时的case对应类型（switch t := x.(type){case int:}中case节点映射的t类型)
Selections保存所有类选择器,只能针对类型/对象.字段/method的选择，package.API这种不会记录在这里
Scopes保存当前库scope下的所有域，*ast.File/*ast.FuncType/... 都属于scope,最外层Universe scope,之后Package scope，其他子scope
InitOrder保存所有最外部初始化的值
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;config-check&#34;&gt;config.Check&lt;/h4&gt;

&lt;p&gt;使用config.Check会填充types.Info的内容&lt;/p&gt;

&lt;p&gt;这里第一个path参数决定当前pkg前缀，和FileSet的文件路径是无关的，[]*ast.File{f}是要解析的go文件，这些go文件必须是同一个pkg的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pkg, err := config.Check(&amp;quot;&amp;quot;, fset, []*ast.File{f}, info)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pkg包含顶级scope和包名信息，err则是解析文件的语法错误&lt;/p&gt;

&lt;p&gt;config.Check过后我们就可以通过types.Info来读取go文件信息了&lt;/p&gt;

&lt;h4 id=&#34;types-info-types&#34;&gt;types.Info.Types&lt;/h4&gt;

&lt;p&gt;types.Info.Types 映射ast.Expr(不包括在types.Info.Defs和types.Info.Users中的*ast.Ident)到types.TypeAndValue类型&lt;/p&gt;

&lt;p&gt;types.TypeAndValue解析expr的类型和它的额外属性，如果expr是一个常量值，TypeAndValue也会解析它的Value&lt;/p&gt;

&lt;p&gt;我们来打印一下types.Info.Types的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Println(&amp;quot;------------ types -----------&amp;quot;)
for _, node := range getSortedKeys(info.Types) {
	expr := node.(ast.Expr)
	typeValue := info.Types[expr]
	fmt.Printf(&amp;quot;%s - %s %T it&#39;s value: %v type: %s\n&amp;quot;,
		fset.Position(expr.Pos()),
		fset.Position(expr.End()),
		expr,
		typeValue.Value,
		typeValue.Type.String(),
	)
	if typeValue.Assignable() {
		fmt.Print(&amp;quot;assignable &amp;quot;)
	}
	if typeValue.Addressable() {
		fmt.Print(&amp;quot;addressable &amp;quot;)
	}
	if typeValue.IsNil() {
		fmt.Print(&amp;quot;nil &amp;quot;)
	}
	if typeValue.HasOk() {
		fmt.Print(&amp;quot;has ok &amp;quot;)
	}
	if typeValue.IsBuiltin() {
		fmt.Print(&amp;quot;builtin &amp;quot;)
	}
	if typeValue.IsType() {
		fmt.Print(&amp;quot;is type &amp;quot;)
	}
	if typeValue.IsValue() {
		fmt.Print(&amp;quot;is value &amp;quot;)
	}
	if typeValue.IsVoid() {
		fmt.Print(&amp;quot;void &amp;quot;)
	}
	fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
打印日志
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;------------ types -----------
data/src.go:7:14 - data/src.go:9:2 *ast.StructType it&#39;s value: &amp;lt;nil&amp;gt; type: struct{Name string}
is type 
data/src.go:8:7 - data/src.go:8:13 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: string
is type 
data/src.go:11:9 - data/src.go:11:16 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: Product
is type 
data/src.go:11:27 - data/src.go:11:33 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: string
is type 
data/src.go:12:9 - data/src.go:12:19 *ast.BasicLit it&#39;s value: &amp;quot;Product:&amp;quot; type: string
is value 
data/src.go:12:9 - data/src.go:12:28 *ast.BinaryExpr it&#39;s value: &amp;lt;nil&amp;gt; type: string
is value 
data/src.go:12:22 - data/src.go:12:23 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: Product
assignable addressable is value 
data/src.go:12:22 - data/src.go:12:28 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: string
assignable addressable is value 
data/src.go:16:8 - data/src.go:16:19 *ast.InterfaceType it&#39;s value: &amp;lt;nil&amp;gt; type: interface{}
is type 
data/src.go:16:22 - data/src.go:16:23 *ast.BasicLit it&#39;s value: 5 type: int
is value 
data/src.go:17:14 - data/src.go:17:15 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: interface{}
assignable addressable is value 
data/src.go:18:7 - data/src.go:18:10 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: int
is type 
data/src.go:19:3 - data/src.go:19:14 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:19:3 - data/src.go:19:17 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:19:15 - data/src.go:19:16 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: int
assignable addressable is value 
data/src.go:21:3 - data/src.go:21:14 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:21:3 - data/src.go:21:17 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:21:15 - data/src.go:21:16 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: interface{}
assignable addressable is value 
data/src.go:23:8 - data/src.go:23:17 *ast.FuncType it&#39;s value: &amp;lt;nil&amp;gt; type: func(int)
is type 
data/src.go:23:13 - data/src.go:23:16 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: int
is type 
data/src.go:24:2 - data/src.go:24:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:24:2 - data/src.go:24:16 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:24:14 - data/src.go:24:15 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: func(int)
assignable addressable is value 
data/src.go:28:7 - data/src.go:28:14 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: Product
is type 
data/src.go:28:7 - data/src.go:28:28 *ast.CompositeLit it&#39;s value: &amp;lt;nil&amp;gt; type: Product
is value 
data/src.go:28:21 - data/src.go:28:27 *ast.BasicLit it&#39;s value: &amp;quot;t011&amp;quot; type: string
is value 
data/src.go:29:2 - data/src.go:29:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:29:2 - data/src.go:29:21 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:29:14 - data/src.go:29:15 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: Product
assignable addressable is value 
data/src.go:29:14 - data/src.go:29:20 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: string
assignable addressable is value 
data/src.go:30:2 - data/src.go:30:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:30:2 - data/src.go:30:25 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:30:14 - data/src.go:30:15 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: Product
assignable addressable is value 
data/src.go:30:14 - data/src.go:30:22 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func() string
is value 
data/src.go:30:14 - data/src.go:30:24 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: string
is value 
data/src.go:31:2 - data/src.go:31:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:31:2 - data/src.go:31:32 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:31:14 - data/src.go:31:21 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: Product
is type 
data/src.go:31:14 - data/src.go:31:28 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(Product) string
is value 
data/src.go:31:14 - data/src.go:31:31 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: string
is value 
data/src.go:31:29 - data/src.go:31:30 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: Product
assignable addressable is value 
data/src.go:32:2 - data/src.go:32:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:32:2 - data/src.go:32:31 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:32:14 - data/src.go:32:22 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: invalid type
builtin 
data/src.go:32:14 - data/src.go:32:30 *ast.CallExpr it&#39;s value: 0 type: uintptr
is value 
data/src.go:32:23 - data/src.go:32:24 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: Product
assignable addressable is value 
data/src.go:35:21 - data/src.go:35:24 *ast.BasicLit it&#39;s value: 100 type: untyped int
is value 
data/src.go:37:23 - data/src.go:37:24 *ast.BasicLit it&#39;s value: 1 type: int
is value 
data/src.go:40:2 - data/src.go:40:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:40:2 - data/src.go:40:30 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:40:14 - data/src.go:40:29 *ast.BasicLit it&#39;s value: &amp;quot;Hello, World!&amp;quot; type: string
is value 
data/src.go:41:7 - data/src.go:41:12 *ast.ArrayType it&#39;s value: &amp;lt;nil&amp;gt; type: []int
is type 
data/src.go:41:7 - data/src.go:41:21 *ast.CompositeLit it&#39;s value: &amp;lt;nil&amp;gt; type: []int
is value 
data/src.go:41:9 - data/src.go:41:12 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: int
is type 
data/src.go:41:13 - data/src.go:41:14 *ast.BasicLit it&#39;s value: 1 type: int
is value 
data/src.go:41:16 - data/src.go:41:17 *ast.BasicLit it&#39;s value: 2 type: int
is value 
data/src.go:41:19 - data/src.go:41:20 *ast.BasicLit it&#39;s value: 3 type: int
is value 
data/src.go:42:2 - data/src.go:42:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:42:2 - data/src.go:42:16 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:42:14 - data/src.go:42:15 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: []int
assignable addressable is value 
data/src.go:43:7 - data/src.go:43:21 *ast.MapType it&#39;s value: &amp;lt;nil&amp;gt; type: map[int]string
is type 
data/src.go:43:7 - data/src.go:46:3 *ast.CompositeLit it&#39;s value: &amp;lt;nil&amp;gt; type: map[int]string
is value 
data/src.go:43:11 - data/src.go:43:14 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: int
is type 
data/src.go:43:15 - data/src.go:43:21 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: string
is type 
data/src.go:44:3 - data/src.go:44:4 *ast.BasicLit it&#39;s value: 1 type: int
is value 
data/src.go:44:6 - data/src.go:44:9 *ast.BasicLit it&#39;s value: &amp;quot;a&amp;quot; type: string
is value 
data/src.go:45:3 - data/src.go:45:4 *ast.BasicLit it&#39;s value: 2 type: int
is value 
data/src.go:45:6 - data/src.go:45:9 *ast.BasicLit it&#39;s value: &amp;quot;b&amp;quot; type: string
is value 
data/src.go:47:2 - data/src.go:47:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:47:2 - data/src.go:47:16 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:47:14 - data/src.go:47:15 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: map[int]string
assignable addressable is value 
data/src.go:49:7 - data/src.go:49:11 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: func(chan int, int) chan int
builtin 
data/src.go:49:7 - data/src.go:49:24 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: chan int
is value 
data/src.go:49:12 - data/src.go:49:20 *ast.ChanType it&#39;s value: &amp;lt;nil&amp;gt; type: chan int
is type 
data/src.go:49:17 - data/src.go:49:20 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: int
is type 
data/src.go:49:22 - data/src.go:49:23 *ast.BasicLit it&#39;s value: 5 type: int
is value 
data/src.go:50:2 - data/src.go:50:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:50:2 - data/src.go:50:16 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:50:14 - data/src.go:50:15 *ast.Ident it&#39;s value: &amp;lt;nil&amp;gt; type: chan int
assignable addressable is value 
data/src.go:52:2 - data/src.go:52:13 *ast.SelectorExpr it&#39;s value: &amp;lt;nil&amp;gt; type: func(a ...interface{}) (n int, err error)
is value 
data/src.go:52:2 - data/src.go:52:26 *ast.CallExpr it&#39;s value: &amp;lt;nil&amp;gt; type: (n int, err error)
is value 
data/src.go:52:14 - data/src.go:52:25 *ast.Ident it&#39;s value: 100 type: int
is value 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h4 id=&#34;types-info-defs&#34;&gt;types.Info.Defs&lt;/h4&gt;

&lt;p&gt;Defs保存所有定义的*ast.Ident，并映射为types.Object&lt;/p&gt;

&lt;p&gt;types.Object可以是一个包名，函数，常量，变量,或者标签的接口&lt;/p&gt;

&lt;p&gt;当前包的package name也保存在Defs表中，不过它的Object是nil，不知道是不是bug&lt;/p&gt;

&lt;p&gt;打印一下Defs的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Println(&amp;quot;------------ def -----------&amp;quot;)
for _, node := range getSortedKeys(info.Defs) {
	ident := node.(*ast.Ident)
	object := info.Defs[ident]
	fmt.Printf(&amp;quot;%s - %s %T&amp;quot;,
		fset.Position(ident.Pos()),
		fset.Position(ident.End()),
		object,
	)
	if object != nil {
		fmt.Printf(&amp;quot; it&#39;s object: %s type: %s&amp;quot;,
			object,
			object.Type().String(),
		)

	}
	fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
打印日志
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;------------ def -----------
data/src.go:1:9 - data/src.go:1:13 &amp;lt;nil&amp;gt;
data/src.go:5:8 - data/src.go:5:9 *types.PkgName it&#39;s object: package . (&amp;quot;unsafe&amp;quot;) type: invalid type
data/src.go:7:6 - data/src.go:7:13 *types.TypeName it&#39;s object: type Product struct{Name string} type: Product
data/src.go:8:2 - data/src.go:8:6 *types.Var it&#39;s object: field Name string type: string
data/src.go:11:7 - data/src.go:11:8 *types.Var it&#39;s object: var p Product type: Product
data/src.go:11:18 - data/src.go:11:24 *types.Func it&#39;s object: func (Product).String() string type: func() string
data/src.go:15:6 - data/src.go:15:20 *types.Func it&#39;s object: func ImplicitlyNode() type: func()
data/src.go:16:6 - data/src.go:16:7 *types.Var it&#39;s object: var d interface{} type: interface{}
data/src.go:17:9 - data/src.go:17:10 &amp;lt;nil&amp;gt;
data/src.go:23:6 - data/src.go:23:7 *types.Var it&#39;s object: var e func(int) type: func(int)
data/src.go:27:6 - data/src.go:27:19 *types.Func it&#39;s object: func SelectionNode() type: func()
data/src.go:28:2 - data/src.go:28:3 *types.Var it&#39;s object: var p Product type: Product
data/src.go:35:7 - data/src.go:35:18 *types.Const it&#39;s object: const MaxRoutines untyped int type: untyped int
data/src.go:37:5 - data/src.go:37:20 *types.Var it&#39;s object: var CurrentRoutines int type: int
data/src.go:39:6 - data/src.go:39:10 *types.Func it&#39;s object: func main() type: func()
data/src.go:41:2 - data/src.go:41:3 *types.Var it&#39;s object: var a []int type: []int
data/src.go:43:2 - data/src.go:43:3 *types.Var it&#39;s object: var b map[int]string type: map[int]string
data/src.go:49:2 - data/src.go:49:3 *types.Var it&#39;s object: var d chan int type: chan int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h4 id=&#34;types-info-uses&#34;&gt;types.Info.Uses&lt;/h4&gt;

&lt;p&gt;Uses保存所有使用的*ast.Ident，并映射为types.Object&lt;/p&gt;

&lt;p&gt;基本在Uses中的Ident也会出现在Types里，这部分逻辑很迷&lt;/p&gt;

&lt;p&gt;打印Uses&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Println(&amp;quot;------------ uses -----------&amp;quot;)
for _, node := range getSortedKeys(info.Uses) {
	ident := node.(*ast.Ident)
	object := info.Uses[ident]
	fmt.Printf(&amp;quot;%s - %s %T&amp;quot;,
		fset.Position(ident.Pos()),
		fset.Position(ident.End()),
		object,
	)
	if object != nil {
		fmt.Printf(&amp;quot; it&#39;s object: %s type: %s&amp;quot;,
			object,
			object.Type().String(),
		)

	}
	fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
打印日志
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;------------ uses -----------
data/src.go:8:7 - data/src.go:8:13 *types.TypeName it&#39;s object: type string type: string
data/src.go:11:9 - data/src.go:11:16 *types.TypeName it&#39;s object: type Product struct{Name string} type: Product
data/src.go:11:27 - data/src.go:11:33 *types.TypeName it&#39;s object: type string type: string
data/src.go:12:22 - data/src.go:12:23 *types.Var it&#39;s object: var p Product type: Product
data/src.go:12:24 - data/src.go:12:28 *types.Var it&#39;s object: field Name string type: string
data/src.go:17:14 - data/src.go:17:15 *types.Var it&#39;s object: var d interface{} type: interface{}
data/src.go:18:7 - data/src.go:18:10 *types.TypeName it&#39;s object: type int type: int
data/src.go:19:3 - data/src.go:19:6 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:19:7 - data/src.go:19:14 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:19:15 - data/src.go:19:16 *types.Var it&#39;s object: var x int type: int
data/src.go:21:3 - data/src.go:21:6 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:21:7 - data/src.go:21:14 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:21:15 - data/src.go:21:16 *types.Var it&#39;s object: var x interface{} type: interface{}
data/src.go:23:13 - data/src.go:23:16 *types.TypeName it&#39;s object: type int type: int
data/src.go:24:2 - data/src.go:24:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:24:6 - data/src.go:24:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:24:14 - data/src.go:24:15 *types.Var it&#39;s object: var e func(int) type: func(int)
data/src.go:28:7 - data/src.go:28:14 *types.TypeName it&#39;s object: type Product struct{Name string} type: Product
data/src.go:28:15 - data/src.go:28:19 *types.Var it&#39;s object: field Name string type: string
data/src.go:29:2 - data/src.go:29:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:29:6 - data/src.go:29:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:29:14 - data/src.go:29:15 *types.Var it&#39;s object: var p Product type: Product
data/src.go:29:16 - data/src.go:29:20 *types.Var it&#39;s object: field Name string type: string
data/src.go:30:2 - data/src.go:30:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:30:6 - data/src.go:30:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:30:14 - data/src.go:30:15 *types.Var it&#39;s object: var p Product type: Product
data/src.go:30:16 - data/src.go:30:22 *types.Func it&#39;s object: func (Product).String() string type: func() string
data/src.go:31:2 - data/src.go:31:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:31:6 - data/src.go:31:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:31:14 - data/src.go:31:21 *types.TypeName it&#39;s object: type Product struct{Name string} type: Product
data/src.go:31:22 - data/src.go:31:28 *types.Func it&#39;s object: func (Product).String() string type: func() string
data/src.go:31:29 - data/src.go:31:30 *types.Var it&#39;s object: var p Product type: Product
data/src.go:32:2 - data/src.go:32:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:32:6 - data/src.go:32:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:32:14 - data/src.go:32:22 *types.Builtin it&#39;s object: builtin unsafe.Offsetof type: invalid type
data/src.go:32:23 - data/src.go:32:24 *types.Var it&#39;s object: var p Product type: Product
data/src.go:32:25 - data/src.go:32:29 *types.Var it&#39;s object: field Name string type: string
data/src.go:40:2 - data/src.go:40:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:40:6 - data/src.go:40:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:41:9 - data/src.go:41:12 *types.TypeName it&#39;s object: type int type: int
data/src.go:42:2 - data/src.go:42:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:42:6 - data/src.go:42:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:42:14 - data/src.go:42:15 *types.Var it&#39;s object: var a []int type: []int
data/src.go:43:11 - data/src.go:43:14 *types.TypeName it&#39;s object: type int type: int
data/src.go:43:15 - data/src.go:43:21 *types.TypeName it&#39;s object: type string type: string
data/src.go:47:2 - data/src.go:47:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:47:6 - data/src.go:47:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:47:14 - data/src.go:47:15 *types.Var it&#39;s object: var b map[int]string type: map[int]string
data/src.go:49:7 - data/src.go:49:11 *types.Builtin it&#39;s object: builtin make type: invalid type
data/src.go:49:17 - data/src.go:49:20 *types.TypeName it&#39;s object: type int type: int
data/src.go:50:2 - data/src.go:50:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:50:6 - data/src.go:50:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:50:14 - data/src.go:50:15 *types.Var it&#39;s object: var d chan int type: chan int
data/src.go:52:2 - data/src.go:52:5 *types.PkgName it&#39;s object: package fmt type: invalid type
data/src.go:52:6 - data/src.go:52:13 *types.Func it&#39;s object: func fmt.Println(a ...interface{}) (n int, err error) type: func(a ...interface{}) (n int, err error)
data/src.go:52:14 - data/src.go:52:25 *types.Const it&#39;s object: const MaxRoutines untyped int type: untyped int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h4 id=&#34;types-info-implicits&#34;&gt;types.Info.Implicits&lt;/h4&gt;

&lt;p&gt;Implicits保存各种隐藏声明的节点,以下节点可能出现在Implicits表中&lt;/p&gt;

&lt;p&gt;没有包名的import&lt;/p&gt;

&lt;p&gt;type-specific的swtich语句&lt;/p&gt;

&lt;p&gt;声明函数时的匿名参数&lt;/p&gt;

&lt;p&gt;这个example已经把实现了所有隐藏声明代码，来看看哪些节点会出现在这里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Println(&amp;quot;------------ implicits -----------&amp;quot;)
for _, node := range getSortedKeys(info.Implicits) {
	object := info.Implicits[node]
	fmt.Printf(&amp;quot;%s - %s %T it&#39;s object: %s\n&amp;quot;,
		fset.Position(node.Pos()),
		fset.Position(node.End()),
		node,
		object,
	)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
打印日志
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;------------ implicits -----------
data/src.go:4:8 - data/src.go:4:13 *ast.ImportSpec it&#39;s object: package fmt
data/src.go:11:27 - data/src.go:11:33 *ast.Field it&#39;s object: var  string
data/src.go:18:2 - data/src.go:19:17 *ast.CaseClause it&#39;s object: var x int
data/src.go:20:2 - data/src.go:21:17 *ast.CaseClause it&#39;s object: var x interface{}
data/src.go:23:13 - data/src.go:23:16 *ast.Field it&#39;s object: var  int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h4 id=&#34;types-info-selections&#34;&gt;types.Info.Selections&lt;/h4&gt;

&lt;p&gt;Selections保存所有结构体选择表达式像 x.f，它会把*ast.SelectorExpr映射成*types.Selection，只有类成员的使用表达式会被映射，库成员的使用则不会&lt;/p&gt;

&lt;p&gt;types.Selection有3中类型，对应3种调用方式(这里参考了types源码)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;//	type T struct{ x int; E }
//	type E struct{}
//	func (e E) m() {}
//	var p *T
//
// the following relations exist:
//
//	Selector    Kind          Recv    Obj    Type               Index     Indirect
//
//	p.x         FieldVal      T       x      int                {0}       true
//	p.m         MethodVal     *T      m      func (e *T) m()    {1, 0}    true
//	T.m         MethodExpr    T       m      func m(_ T)        {1, 0}    false
//
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Println(&amp;quot;------------ selections -----------&amp;quot;)
for _, node := range getSortedKeys(info.Selections) {
	sel := node.(*ast.SelectorExpr)
	typeSel := info.Selections[sel]
	fmt.Printf(&amp;quot;%s - %s it&#39;s selection: %s\n&amp;quot;,
		fset.Position(sel.Pos()),
		fset.Position(sel.End()),
		typeSel.String(),
	)
	fmt.Printf(&amp;quot;receive: %s index: %v obj: %s\n&amp;quot;, typeSel.Recv(), typeSel.Index(), typeSel.Obj())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
打印日志
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;------------ selections -----------
data/src.go:13:22 - data/src.go:13:28 it&#39;s selection: field (Product) Name string
receive: Product index: [0] obj: field Name string
data/src.go:30:14 - data/src.go:30:20 it&#39;s selection: field (Product) Name string
receive: Product index: [0] obj: field Name string
data/src.go:31:14 - data/src.go:31:22 it&#39;s selection: method (Product) String() string
receive: Product index: [0] obj: func (Product).String() string
data/src.go:32:14 - data/src.go:32:28 it&#39;s selection: method expr (Product) String(p Product) string
receive: Product index: [0] obj: func (Product).String() string
data/src.go:33:23 - data/src.go:33:29 it&#39;s selection: field (Product) Name string
receive: Product index: [0] obj: field Name string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h4 id=&#34;types-info-scope&#34;&gt;types.Info.Scope&lt;/h4&gt;

&lt;p&gt;scope 记录当前库scope下的所有域，*ast.File/*ast.FuncType/&amp;hellip; 都属于scope，详情看Scopes说明&lt;/p&gt;

&lt;p&gt;scope关系: 最外层Universe scope,之后Package scope，其他子scope&lt;/p&gt;

&lt;p&gt;打印Universe scope的内容和Package scope的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 打印宇宙级scope
//打印package scope
fmt.Printf(&amp;quot;package level scope %s\n&amp;quot;,
	pkg.Scope().String(),
)
// 打印宇宙级scope
fmt.Printf(&amp;quot;universe level scope %s\n&amp;quot;,
	pkg.Scope().Parent().String(),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
打印日志
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;package level scope package &amp;quot;&amp;quot; scope 0xc42009dbd0 {
.  var CurrentRoutines int
.  func ImplicitlyNode()
.  const MaxRoutines untyped int
.  type Product struct{Name string}
.  func SelectionNode()
.  func main()
}
universe level scope universe scope 0xc42009c320 {
.  builtin append
.  type bool
.  type byte
.  builtin cap
.  builtin close
.  builtin complex
.  type complex128
.  type complex64
.  builtin copy
.  builtin delete
.  type error interface{Error() string}
.  const false untyped bool
.  type float32
.  type float64
.  builtin imag
.  type int
.  type int16
.  type int32
.  type int64
.  type int8
.  const iota untyped int
.  builtin len
.  builtin make
.  builtin new
.  nil
.  builtin panic
.  builtin print
.  builtin println
.  builtin real
.  builtin recover
.  type rune
.  type string
.  const true untyped bool
.  type uint
.  type uint16
.  type uint32
.  type uint64
.  type uint8
.  type uintptr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;打印所有scope(types.Info.Scope不会包含Package scope和Universe scope)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;for _, node := range getSortedKeys(info.Scopes) {
	scope := info.Scopes[node]
	fmt.Printf(&amp;quot;%s - %s %T it&#39;s scope: %s\n&amp;quot;,
		fset.Position(node.Pos()),
		fset.Position(node.End()),
		node,
		scope.String(),
	)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
打印日志
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;data/src.go:12:1 - data/src.go:12:33 *ast.FuncType it&#39;s scope: function scope 0xc421388ff0 {
.  var p Product
}
data/src.go:16:1 - data/src.go:16:22 *ast.FuncType it&#39;s scope: function scope 0xc4213890e0 {
.  var d interface{}
.  var e func(int)
}
data/src.go:18:2 - data/src.go:23:3 *ast.TypeSwitchStmt it&#39;s scope: type switch scope 0xc421389310 {}

data/src.go:19:2 - data/src.go:20:17 *ast.CaseClause it&#39;s scope: case scope 0xc421389360 {
.  var x int
}
data/src.go:21:2 - data/src.go:22:17 *ast.CaseClause it&#39;s scope: case scope 0xc421389400 {
.  var x interface{}
}
data/src.go:24:8 - data/src.go:24:17 *ast.FuncType it&#39;s scope: function scope 0xc4213894f0 {}

data/src.go:28:1 - data/src.go:28:21 *ast.FuncType it&#39;s scope: function scope 0xc421389180 {
.  var p Product
}
data/src.go:40:1 - data/src.go:40:12 *ast.FuncType it&#39;s scope: function scope 0xc4213891d0 {
.  var a []int
.  var b map[int]string
.  var d chan int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h4 id=&#34;types-info-initorder&#34;&gt;types.Info.InitOrder&lt;/h4&gt;

&lt;p&gt;InitOrder保存当前库最外层的变量&lt;/p&gt;

&lt;p&gt;打印当前所有InitOrder内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Println(&amp;quot;------------ init -----------&amp;quot;)
for _, init := range info.InitOrder {
	fmt.Printf(&amp;quot;init %s\n&amp;quot;,
		init.String(),
	)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
打印日志
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;init CurrentRoutines = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h4 id=&#34;types-object比较&#34;&gt;types.Object比较&lt;/h4&gt;

&lt;p&gt;可以使用Object.Pos()模块查找这个Object的声明时的位置，从而比较哪些Object属于同一个对象&lt;/p&gt;

&lt;h4 id=&#34;types-type比较&#34;&gt;types.Type比较&lt;/h4&gt;

&lt;p&gt;可以通过Type.String()来比较这2个Type是不是相同的类型&lt;/p&gt;

&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;

&lt;p&gt;以上就是就是go/types的全部内容了，下一章继续介绍go/types中实现的Type类型&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用go/ast来解析go文件</title>
      <link>https://bigpigeon.org/post/go-ast-parser-file/</link>
      <pubDate>Sat, 05 May 2018 10:07:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/go-ast-parser-file/</guid>
      <description>&lt;p&gt;go/ast是go的type checker 标准包之一(不是编译器的那套工具，编译器用的另外一套)，它定义了抽象语法树(AST)的数据类型和操作ast节点的工具&lt;/p&gt;

&lt;p&gt;下面我们来看看如何ast树的结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;go/ast&amp;quot;
	&amp;quot;go/parser&amp;quot;
	&amp;quot;go/token&amp;quot;
)

func main() {
	src := `
package main

// 该声明为GenDecl TOK=token.IMPORT
import &amp;quot;fmt&amp;quot;

// 该声明为GenDecl TOK=token.TYPE
type Product struct {
	Name string
}

// 该声明为GenDecl TOK=token.VAR
var product Product

// 该声明为FunDecl
func main() { //test1
	fmt.Println(&amp;quot;Hello, World!&amp;quot;) //test2
	a := []int{1,2,3}
	a[1],a[2] = 5,6
}
`
	fset := token.NewFileSet() // 位置是相对于节点
	// 用ParseFile把文件解析成*ast.File节点
	f, err := parser.ParseFile(fset, &amp;quot;&amp;quot;, src, 0)
	if err != nil {
		panic(err)
	}

	// 打印ast节点
	ast.Print(fset, f)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
然后我们可以巨量的打印信息
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 0  *ast.File {
 1  .  Package: 2:1
 2  .  Name: *ast.Ident {
 3  .  .  NamePos: 2:9
 4  .  .  Name: &amp;quot;main&amp;quot;
 5  .  }
 6  .  Decls: []ast.Decl (len = 4) {
 7  .  .  0: *ast.GenDecl {
 8  .  .  .  TokPos: 5:1
 9  .  .  .  Tok: import
10  .  .  .  Lparen: -
11  .  .  .  Specs: []ast.Spec (len = 1) {
12  .  .  .  .  0: *ast.ImportSpec {
13  .  .  .  .  .  Path: *ast.BasicLit {
14  .  .  .  .  .  .  ValuePos: 5:8
15  .  .  .  .  .  .  Kind: STRING
16  .  .  .  .  .  .  Value: &amp;quot;\&amp;quot;fmt\&amp;quot;&amp;quot;
17  .  .  .  .  .  }
18  .  .  .  .  .  EndPos: -
19  .  .  .  .  }
20  .  .  .  }
21  .  .  .  Rparen: -
22  .  .  }
23  .  .  1: *ast.GenDecl {
24  .  .  .  TokPos: 8:1
25  .  .  .  Tok: type
26  .  .  .  Lparen: -
27  .  .  .  Specs: []ast.Spec (len = 1) {
28  .  .  .  .  0: *ast.TypeSpec {
29  .  .  .  .  .  Name: *ast.Ident {
30  .  .  .  .  .  .  NamePos: 8:6
31  .  .  .  .  .  .  Name: &amp;quot;Product&amp;quot;
32  .  .  .  .  .  .  Obj: *ast.Object {
33  .  .  .  .  .  .  .  Kind: type
34  .  .  .  .  .  .  .  Name: &amp;quot;Product&amp;quot;
35  .  .  .  .  .  .  .  Decl: *(obj @ 28)
36  .  .  .  .  .  .  }
37  .  .  .  .  .  }
38  .  .  .  .  .  Assign: -
39  .  .  .  .  .  Type: *ast.StructType {
40  .  .  .  .  .  .  Struct: 8:14
41  .  .  .  .  .  .  Fields: *ast.FieldList {
42  .  .  .  .  .  .  .  Opening: 8:21
43  .  .  .  .  .  .  .  List: []*ast.Field (len = 1) {
44  .  .  .  .  .  .  .  .  0: *ast.Field {
45  .  .  .  .  .  .  .  .  .  Names: []*ast.Ident (len = 1) {
46  .  .  .  .  .  .  .  .  .  .  0: *ast.Ident {
47  .  .  .  .  .  .  .  .  .  .  .  NamePos: 9:2
48  .  .  .  .  .  .  .  .  .  .  .  Name: &amp;quot;Name&amp;quot;
49  .  .  .  .  .  .  .  .  .  .  .  Obj: *ast.Object {
50  .  .  .  .  .  .  .  .  .  .  .  .  Kind: var
51  .  .  .  .  .  .  .  .  .  .  .  .  Name: &amp;quot;Name&amp;quot;
52  .  .  .  .  .  .  .  .  .  .  .  .  Decl: *(obj @ 44)
53  .  .  .  .  .  .  .  .  .  .  .  }
54  .  .  .  .  .  .  .  .  .  .  }
55  .  .  .  .  .  .  .  .  .  }
56  .  .  .  .  .  .  .  .  .  Type: *ast.Ident {
57  .  .  .  .  .  .  .  .  .  .  NamePos: 9:7
58  .  .  .  .  .  .  .  .  .  .  Name: &amp;quot;string&amp;quot;
59  .  .  .  .  .  .  .  .  .  }
60  .  .  .  .  .  .  .  .  }
61  .  .  .  .  .  .  .  }
62  .  .  .  .  .  .  .  Closing: 10:1
63  .  .  .  .  .  .  }
64  .  .  .  .  .  .  Incomplete: false
65  .  .  .  .  .  }
66  .  .  .  .  }
67  .  .  .  }
68  .  .  .  Rparen: -
69  .  .  }
70  .  .  2: *ast.GenDecl {
71  .  .  .  TokPos: 13:1
72  .  .  .  Tok: var
73  .  .  .  Lparen: -
74  .  .  .  Specs: []ast.Spec (len = 1) {
75  .  .  .  .  0: *ast.ValueSpec {
76  .  .  .  .  .  Names: []*ast.Ident (len = 1) {
77  .  .  .  .  .  .  0: *ast.Ident {
78  .  .  .  .  .  .  .  NamePos: 13:5
79  .  .  .  .  .  .  .  Name: &amp;quot;product&amp;quot;
80  .  .  .  .  .  .  .  Obj: *ast.Object {
81  .  .  .  .  .  .  .  .  Kind: var
82  .  .  .  .  .  .  .  .  Name: &amp;quot;product&amp;quot;
83  .  .  .  .  .  .  .  .  Decl: *(obj @ 75)
84  .  .  .  .  .  .  .  .  Data: 0
85  .  .  .  .  .  .  .  }
86  .  .  .  .  .  .  }
87  .  .  .  .  .  }
88  .  .  .  .  .  Type: *ast.Ident {
89  .  .  .  .  .  .  NamePos: 13:13
90  .  .  .  .  .  .  Name: &amp;quot;Product&amp;quot;
91  .  .  .  .  .  .  Obj: *(obj @ 32)
92  .  .  .  .  .  }
93  .  .  .  .  }
94  .  .  .  }
95  .  .  .  Rparen: -
96  .  .  }
97  .  .  3: *ast.FuncDecl {
98  .  .  .  Name: *ast.Ident {
99  .  .  .  .  NamePos: 16:6
100  .  .  .  .  Name: &amp;quot;main&amp;quot;
101  .  .  .  .  Obj: *ast.Object {
102  .  .  .  .  .  Kind: func
103  .  .  .  .  .  Name: &amp;quot;main&amp;quot;
104  .  .  .  .  .  Decl: *(obj @ 97)
105  .  .  .  .  }
106  .  .  .  }
107  .  .  .  Type: *ast.FuncType {
108  .  .  .  .  Func: 16:1
109  .  .  .  .  Params: *ast.FieldList {
110  .  .  .  .  .  Opening: 16:10
111  .  .  .  .  .  Closing: 16:11
112  .  .  .  .  }
113  .  .  .  }
114  .  .  .  Body: *ast.BlockStmt {
115  .  .  .  .  Lbrace: 16:13
116  .  .  .  .  List: []ast.Stmt (len = 1) {
117  .  .  .  .  .  0: *ast.ExprStmt {
118  .  .  .  .  .  .  X: *ast.CallExpr {
119  .  .  .  .  .  .  .  Fun: *ast.SelectorExpr {
120  .  .  .  .  .  .  .  .  X: *ast.Ident {
121  .  .  .  .  .  .  .  .  .  NamePos: 17:2
122  .  .  .  .  .  .  .  .  .  Name: &amp;quot;fmt&amp;quot;
123  .  .  .  .  .  .  .  .  }
124  .  .  .  .  .  .  .  .  Sel: *ast.Ident {
125  .  .  .  .  .  .  .  .  .  NamePos: 17:6
126  .  .  .  .  .  .  .  .  .  Name: &amp;quot;Println&amp;quot;
127  .  .  .  .  .  .  .  .  }
128  .  .  .  .  .  .  .  }
129  .  .  .  .  .  .  .  Lparen: 17:13
130  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) {
131  .  .  .  .  .  .  .  .  0: *ast.BasicLit {
132  .  .  .  .  .  .  .  .  .  ValuePos: 17:14
133  .  .  .  .  .  .  .  .  .  Kind: STRING
134  .  .  .  .  .  .  .  .  .  Value: &amp;quot;\&amp;quot;Hello, World!\&amp;quot;&amp;quot;
135  .  .  .  .  .  .  .  .  }
136  .  .  .  .  .  .  .  }
137  .  .  .  .  .  .  .  Ellipsis: -
138  .  .  .  .  .  .  .  Rparen: 17:29
139  .  .  .  .  .  .  }
140  .  .  .  .  .  }
141  .  .  .  .  }
142  .  .  .  .  Rbrace: 18:1
143  .  .  .  }
144  .  .  }
145  .  }
146  .  Scope: *ast.Scope {
147  .  .  Objects: map[string]*ast.Object (len = 3) {
148  .  .  .  &amp;quot;Product&amp;quot;: *(obj @ 32)
149  .  .  .  &amp;quot;product&amp;quot;: *(obj @ 80)
150  .  .  .  &amp;quot;main&amp;quot;: *(obj @ 101)
151  .  .  }
152  .  }
153  .  Imports: []*ast.ImportSpec (len = 1) {
154  .  .  0: *(obj @ 12)
155  .  }
156  .  Unresolved: []*ast.Ident (len = 2) {
157  .  .  0: *(obj @ 56)
158  .  .  1: *(obj @ 120)
159  .  }
160  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;从ast树中我们可以看到go/ast的逻辑结构&lt;/p&gt;

&lt;p&gt;因为ast的信息繁多且复杂，这里只列举比较重要的几点，有兴趣的可以自行浏览go/ast中的源码&lt;/p&gt;

&lt;p&gt;在ast.Files中最重要的部分就是Decls，这里面保存了该文件的全局声明(go中的声明既定义)，而Decl接口中有3种类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BadDecl: 有语法错误的声明
GenDecl: 通用声明，import/type/const/var都属于这种声明
FuncDecl: 函数和method的定义属于这种声明
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而GenDecl的TokPos决定它Specs中的元素类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;token.IMPORT *ImportSpec 
token.CONST  *ValueSpec
token.TYPE   *TypeSpec
token.VAR    *ValueSpec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FuncDecl，位置，参数和返回值的信息保存FuncDecl.Type中，而函数定义部分保存在FuncDecl.Body中，我们来看看FuncDecl.Body的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A BlockStmt node represents a braced statement list.
BlockStmt struct {
	Lbrace token.Pos // position of &amp;quot;{&amp;quot;
	List   []Stmt
	Rbrace token.Pos // position of &amp;quot;}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FuncDecl.Body是*ast.BlockStmt类型，在文件中所有{code&amp;hellip;}块都属于*ast.BlockStmt，包括if condition {&amp;hellip;}，switch condition {&amp;hellip;}等&lt;/p&gt;

&lt;p&gt;*ast.BlockStmt中的List元素是ast.Stmt接口，有别于全局声明的ast.Decl,函数中支持的语法更多，所以ast.Stmt接口有更多类型,并且Stmt有一个ast.DeclStmt的实现，也就是说，Stmt支持所有Decl表达式&lt;/p&gt;

&lt;p&gt;在代码中obj := expr 和 var obj = expr等价，但在ast中这2个表达式分别属于AssignStmt和DeclStmt(GenDecl(token.VAR)),来看看他们的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// An AssignStmt node represents an assignment or
// a short variable declaration.
//
AssignStmt struct {
	Lhs    []Expr
	TokPos token.Pos   // position of Tok
	Tok    token.Token // assignment token, DEFINE
	Rhs    []Expr
}

// A ValueSpec node represents a constant or variable declaration
// (ConstSpec or VarSpec production).
//
ValueSpec struct {
	Doc     *CommentGroup // associated documentation; or nil
	Names   []*Ident      // value names (len(Names) &amp;gt; 0)
	Type    Expr          // value type; or nil
	Values  []Expr        // initial values; or nil
	Comment *CommentGroup // line comments; or nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到他们的子元素通常都是一个Expr，而Expr就是一个表达式，如果用文章来类比的话，Decl相当于段落，Stmt相当于是段落中的句子，而Expr就是句子中的一个词或者分句,而在ast中，Decl构成文件的最外层部分，里面由FuncDecl和GenDecl填充，而我们99%的代码都是FuncDecl的Body中的Stmt,而几乎所有变量和调用和值就是Expr,这样是不是好理解多了&lt;/p&gt;

&lt;h5 id=&#34;注-可以看到assignstmt的lhs是expr类型而valuespec的names确可以是ident类型-这是因为所有-的赋值操作也是用assignstmt来表达-所以lhs的元素还有可能是一个-ast-selectorexpr或-ast-indexexpr&#34;&gt;注:可以看到AssignStmt的Lhs是Expr类型而ValueSpec的Names确可以是Ident类型，这是因为所有=的赋值操作也是用AssignStmt来表达，所以Lhs的元素还有可能是一个*ast.SelectorExpr或*ast.IndexExpr&lt;/h5&gt;

&lt;p&gt;汇总一下Stmt和Expr的实现&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
Stmt实现
&lt;/summary&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Stmt类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BadStmt&lt;/td&gt;
&lt;td&gt;错误的语句&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DeclStmt&lt;/td&gt;
&lt;td&gt;继承Decl&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EmptyStmt&lt;/td&gt;
&lt;td&gt;空语句&lt;/td&gt;
&lt;td&gt;;;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LabeledStmt&lt;/td&gt;
&lt;td&gt;定义标签用让goto/break/continue可跳到此处&lt;/td&gt;
&lt;td&gt;MainLoop:&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ExprStmt&lt;/td&gt;
&lt;td&gt;纯表达式，一些不取函数返回值的调用都属于这部分&lt;/td&gt;
&lt;td&gt;a.Call()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SendStmt&lt;/td&gt;
&lt;td&gt;channel的&amp;lt;-传值语句&lt;/td&gt;
&lt;td&gt;a &amp;lt;- b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IncDecStmt&lt;/td&gt;
&lt;td&gt;自增/自减语句&lt;/td&gt;
&lt;td&gt;a++ or a&amp;ndash;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AssignStmt&lt;/td&gt;
&lt;td&gt;赋值语句&lt;/td&gt;
&lt;td&gt;a := 2 or a = 2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GoStmt&lt;/td&gt;
&lt;td&gt;go协程语句&lt;/td&gt;
&lt;td&gt;go myfunc()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DeferStmt&lt;/td&gt;
&lt;td&gt;defer语句&lt;/td&gt;
&lt;td&gt;defer myfunc()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ReturnStmt&lt;/td&gt;
&lt;td&gt;函数返回&lt;/td&gt;
&lt;td&gt;return xxx&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BranchStmt&lt;/td&gt;
&lt;td&gt;循环控制&lt;/td&gt;
&lt;td&gt;break [branch]/continue [branch]/goto branch/fallthrough&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BlockStmt&lt;/td&gt;
&lt;td&gt;块语句&lt;/td&gt;
&lt;td&gt;{stmt&amp;hellip;}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IfStmt&lt;/td&gt;
&lt;td&gt;if语句包含BlockStmt&lt;/td&gt;
&lt;td&gt;if condition {stmt&amp;hellip;}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CaseClause&lt;/td&gt;
&lt;td&gt;case语句包含stmt&lt;/td&gt;
&lt;td&gt;case expr1,expr2: stmt&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SwitchStmt&lt;/td&gt;
&lt;td&gt;switch语句包含BlockStmt&lt;/td&gt;
&lt;td&gt;switch expr {stmt&amp;hellip;}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TypeSwitchStmt&lt;/td&gt;
&lt;td&gt;类型转换的switch&lt;/td&gt;
&lt;td&gt;switch x.(type){stmt&amp;hellip;} or switch y := x.(type){stmt&amp;hellip;}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CommClause&lt;/td&gt;
&lt;td&gt;select中的case语句&lt;/td&gt;
&lt;td&gt;case a &amp;lt;-b: stmt&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SelectStmt&lt;/td&gt;
&lt;td&gt;select语句&lt;/td&gt;
&lt;td&gt;select expr{stmt&amp;hellip;}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ForStmt&lt;/td&gt;
&lt;td&gt;for 语句&lt;/td&gt;
&lt;td&gt;for assign;condition;stmt {stmt&amp;hellip;}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RangeStmt&lt;/td&gt;
&lt;td&gt;for &amp;hellip; range语句&lt;/td&gt;
&lt;td&gt;for k,v :=range kayVal{stmt&amp;hellip;}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
Expr实现
&lt;/summary&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Expr类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BadExpr&lt;/td&gt;
&lt;td&gt;错误表达式&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ident&lt;/td&gt;
&lt;td&gt;标示符，最基本的表达式&lt;/td&gt;
&lt;td&gt;a := myfunc()中的a是ident&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ellipsis&lt;/td&gt;
&lt;td&gt;可变长度参数&lt;/td&gt;
&lt;td&gt;myfunc(args&amp;hellip;)中的args&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BasicLit&lt;/td&gt;
&lt;td&gt;literal常量&lt;/td&gt;
&lt;td&gt;a := 22 中的22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FuncLit&lt;/td&gt;
&lt;td&gt;函数literal常量&lt;/td&gt;
&lt;td&gt;var fun = func(){}中的fun&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CompositeLit&lt;/td&gt;
&lt;td&gt;容器literal常量&lt;/td&gt;
&lt;td&gt;a := []int{1,2,3} 中的[]int{1,2,3} 或 b := map[int]string{}中的map[int]string{}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ParenExpr&lt;/td&gt;
&lt;td&gt;括号表达式&lt;/td&gt;
&lt;td&gt;a + (b*c)中的(b*c)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SelectorExpr&lt;/td&gt;
&lt;td&gt;选择表达式&lt;/td&gt;
&lt;td&gt;a.Method()中的a.Method&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IndexExpr&lt;/td&gt;
&lt;td&gt;索引表达式&lt;/td&gt;
&lt;td&gt;a[2] or a[&amp;ldquo;a&amp;rdquo;]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SliceExpr&lt;/td&gt;
&lt;td&gt;切片表达式&lt;/td&gt;
&lt;td&gt;a[1:2] or a[1:2:1]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TypeAssertExpr&lt;/td&gt;
&lt;td&gt;类型转换表达式&lt;/td&gt;
&lt;td&gt;b := a.(int)中的 a.(int)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CallExpr&lt;/td&gt;
&lt;td&gt;函数调用表达式&lt;/td&gt;
&lt;td&gt;a.Call()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;StarExpr&lt;/td&gt;
&lt;td&gt;星表达式，去地址中的值或者定义指针变量&lt;/td&gt;
&lt;td&gt;*pa = 2 or var pa *int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UnaryExpr&lt;/td&gt;
&lt;td&gt;一元操作符，除了*外都用这个&lt;/td&gt;
&lt;td&gt;return &amp;amp;a中的&amp;amp;a&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BinaryExpr&lt;/td&gt;
&lt;td&gt;条件表达式&lt;/td&gt;
&lt;td&gt;if a &amp;gt; b {}中的 a &amp;gt; b，是的这个是expr不是stmt&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;KeyValueExpr&lt;/td&gt;
&lt;td&gt;初始化map赋值时会用到&lt;/td&gt;
&lt;td&gt;m := map[int]string{1:&amp;ldquo;a&amp;rdquo;, 2: &amp;ldquo;b&amp;rdquo;}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ArrayType&lt;/td&gt;
&lt;td&gt;容器类型&lt;/td&gt;
&lt;td&gt;a := []int{1,2,3} 中的[]int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;StructType&lt;/td&gt;
&lt;td&gt;结构体类型&lt;/td&gt;
&lt;td&gt;type Product struct { Name string }中的struct { Name string }&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;InterfaceType&lt;/td&gt;
&lt;td&gt;接口类型&lt;/td&gt;
&lt;td&gt;var d interface{} = 5中的interface{}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MapType&lt;/td&gt;
&lt;td&gt;map类型&lt;/td&gt;
&lt;td&gt;b := map[int]string{}中的map[int]string&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ChanType&lt;/td&gt;
&lt;td&gt;chan类型&lt;/td&gt;
&lt;td&gt;d := make(chan int,5)中的chan int&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h5 id=&#34;ps-我个人认为stmt和expr直接的定义是模糊的-一些expr当成stmt也是没有问题的&#34;&gt;PS: 我个人认为stmt和expr直接的定义是模糊的，一些expr当成stmt也是没有问题的&lt;/h5&gt;

&lt;p&gt;好了，ast的类型部分基本介绍完了，我们可以开始解析源码做一些生成器或者type check工具了吗？&lt;/p&gt;

&lt;p&gt;并不，因为无论parser.ParserFile或parser.ParserDir都是对单个go文件做解析的，go文件之间没有关联，而且也不会解析import的包，为了对go代码进行更准确解析需要用到另一个库go/types,不过这些我会留到下一章再讲&lt;/p&gt;

&lt;h3 id=&#34;ref&#34;&gt;Ref&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/go/ast&#34;&gt;go/ast&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/example/tree/master/gotypes&#34;&gt;go/types&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gorm简介[中]</title>
      <link>https://bigpigeon.org/post/gorm-tutorial-second/</link>
      <pubDate>Fri, 23 Jun 2017 15:16:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/gorm-tutorial-second/</guid>
      <description>&lt;p&gt;上篇讲到如何用gorm增删改查，但如果涉及一些复杂的操作又想避免使用字符串就需要借助Scopes模块&lt;/p&gt;

&lt;h3 id=&#34;scopes简介&#34;&gt;scopes简介&lt;/h3&gt;

&lt;p&gt;scopes是需要一个自定义的函数&lt;strong&gt;func(db *gorm.DB) *gorm.DB&lt;/strong&gt;作为参数，这样就可以在不破坏链式语法的情况下自定义操作了&lt;/p&gt;

&lt;p&gt;比如我要查询GreekAlphabet表中LatinName是&amp;rdquo;Alpha&amp;rdquo;或 &amp;ldquo;Omega&amp;rdquo;的条目可以这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;chars := []GreekAlphabet{}
db.Model(&amp;amp;GreekAlphabet{}).Where(&amp;quot;latin_name in (?)&amp;quot;, []string{&amp;quot;Alpha&amp;quot;, &amp;quot;Omega&amp;quot;}).Find(&amp;amp;chars)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为查询多个字段的值只能用 &lt;strong&gt;Where(&amp;ldquo;field in (?)&amp;rdquo;, fields)&lt;/strong&gt; 这种方法，相当于是自己拼接sql语句了，这种方法非常容易出错，所以我们用Scopes封装这部分操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;firstAndLast := func(db *gorm.DB) *gorm.DB {
  return db.Where(&amp;quot;latin_name in (?)&amp;quot;, []string{&amp;quot;Alpha&amp;quot;, &amp;quot;Omega&amp;quot;})
}
chars := []GreekAlphabet{}
db.Model(&amp;amp;GreekAlphabet{}).Scopes(firstAndLast).Find(&amp;amp;chars).Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样只要我们对firstAndLast做充足的单元测试就可以让其他人非常安心的使用了，但这样做还是很不灵活，所以下面我们使用offset来制造一个灵活的socpes查询&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用offset制作一个灵活的where-in查询&#34;&gt;使用offset制作一个灵活的Where in查询&lt;/h3&gt;

&lt;p&gt;首先要构建2个offset的map，用来查询offset对应的字段名(Name)和表字段名(DBName),我把它们放入OffsetSelector变量中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var OffsetSelector = struct {
	NameMap   map[reflect.Type]map[uintptr]string
	DBNameMap map[reflect.Type]map[uintptr]string
}{
	NameMap:   map[reflect.Type]map[uintptr]string{},
	DBNameMap: map[reflect.Type]map[uintptr]string{},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将Product和GreekAlphabet放入FieldSelector变量中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var FieldSelector struct {
	Product       Product
	GreekAlphabet GreekAlphabet
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后构造OffsetSelector中的NameMap和DBNameMap&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 把FieldSelector解析为reflect.Value这样可以用for循环获取其中的字段
fieldSelectVal := reflect.ValueOf(&amp;amp;FieldSelector).Elem()
for i := 0; i &amp;lt; fieldSelectVal.NumField(); i++ {
  fieldVal := fieldSelectVal.Field(i)
  // 通过gorm.scope来解析字段名(Name)和表字段名(DBName)容易很多
  scope := &amp;amp;gorm.Scope{Value: fieldVal.Interface()}
  // 获取表结构体的reflect.Type
  table := scope.GetModelStruct().ModelType
  // 获取表结构体中所有字段（这里的字段是gorm.Field而不是relfect.Field）
  gormFields := scope.Fields()
  OffsetSelector.NameMap[table] = map[uintptr]string{}
  OffsetSelector.DBNameMap[table] = map[uintptr]string{}
  // 循环拿取表结构体中每一个字段然后把对应的offset和字段名/表字段名分别映射到NameMap/DBNameMap对应的table映射中
  for j := 0; j &amp;lt; len(gormFields); j++ {
    subfield := gormFields[j]
    offset := subfield.StructField.Struct.Offset

    OffsetSelector.NameMap[table][offset] = subfield.Name
    OffsetSelector.DBNameMap[table][offset] = subfield.DBName
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们就可以创建一个通过字段的offset来查询Where In函数了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;WhereIn := func(fieldOffset uintptr, set interface{}) func(db *gorm.DB) *gorm.DB {
  return func(db *gorm.DB) *gorm.DB {
    val := db.Value
    structType := reflect.TypeOf(val)
    // 获取非list或指针的reflect.Type
    for structType.Kind() == reflect.Slice || structType.Kind() == reflect.Ptr {
      structType = structType.Elem()
    }
    // Where的查询语句中用的是表字段名
    dbname, ok := OffsetSelector.DBNameMap[structType][fieldOffset]
    if ok == false {
      db.AddError(errors.New(&amp;quot;offset is invalid&amp;quot;))
    }
    query := fmt.Sprintf(&amp;quot;%s in (?)&amp;quot;, dbname)
    return db.Where(query, set)
  }
}
frequentNames := []string{&amp;quot;Alpha&amp;quot;, &amp;quot;Beta&amp;quot;, &amp;quot;Gamma&amp;quot;, &amp;quot;Delta&amp;quot;, &amp;quot;Pi&amp;quot;, &amp;quot;Lambda&amp;quot;}
//获取GreekAlphabet.LatinName的offset,记住Offsetof中的参数是表达式，所以不能传参,比如xx := GreekAlphabet{}.LatinName;unsafe.Offsetof(xx)这样是不行的
latinNameOffset := unsafe.Offsetof(GreekAlphabet{}.LatinName)
db.Model(&amp;amp;GreekAlphabet{}).Scopes(WhereIn(latinNameOffset, frequentNames)).Updates(&amp;amp;GreekAlphabet{IsFrequent: true})

frequents := []GreekAlphabet{}
// 查看所有IsFrequent=true的集合
db.Where(&amp;amp;GreekAlphabet{IsFrequent: true}).Find(&amp;amp;frequents)
t.Logf(&amp;quot;%10s\t%s\t%s\t%s&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;upper&amp;quot;, &amp;quot;lower&amp;quot;, &amp;quot;frequent&amp;quot;)
for _, c := range frequents {
  t.Logf(&amp;quot;%10s\t%c\t%c\t%v&amp;quot;, c.LatinName, c.UpperCode, c.LowerCode, c.IsFrequent)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用offset制作一个灵活的field-preload&#34;&gt;使用Offset制作一个灵活的Field Preload&lt;/h3&gt;

&lt;p&gt;上篇已经讲过利用Preload可以获取嵌套的获取外键关联的字段比如这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
db.Preload(&amp;quot;Origin&amp;quot;).Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是Preload函数需要提供一个字段名字符串作为参数，所以我们这里通过构造一个利用Offset来查询外键关联字段&lt;/p&gt;

&lt;p&gt;使用刚才已经创建的OffsetSelector.NameMap就可以获取offset对应的字段名了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;FieldPreload := func(offset uintptr) func(db *gorm.DB) *gorm.DB {
  return func(db *gorm.DB) *gorm.DB {
    val := db.Value
    structType := reflect.TypeOf(val)
    // 获取非list或指针的reflect.Type
    for structType.Kind() == reflect.Slice || structType.Kind() == reflect.Ptr {
      structType = structType.Elem()
    }
    name, ok := OffsetSelector.NameMap[structType][offset]
    if ok == false {
      db.AddError(errors.New(&amp;quot;offset is invalid&amp;quot;))
    }
    t.Log(OffsetSelector.NameMap[structType])
    return db.Preload(name)
  }
}
var product Product
fieldOffset := unsafe.Offsetof(product.Origin)
originPreload := FieldPreload(fieldOffset)
db.Model(&amp;amp;Product{}).Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).Scopes(originPreload).First(&amp;amp;product)
// 查看查询结构是否正确
t.Logf(&amp;quot;this product name &#39;%s&#39;, the address is &#39;%v&#39;&amp;quot;, product.Name, product.Origin.Address1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;结尾&#34;&gt;&lt;strong&gt;结尾&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;上面举了2个使用Scopes的使用例子，用来帮助大家在使用gorm时如何更好的保持一致性原则&lt;/p&gt;

&lt;p&gt;不过如果有人通过gorm修改了默认表名/默认字符串名创建方式上面的方法就会失效，因为我这边为了易读性就没有用更复杂的写法了&lt;/p&gt;

&lt;p&gt;下篇将会解析gorm下的各个数据结构，可能需要很长时间来整理资料&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>谈谈go的relfect</title>
      <link>https://bigpigeon.org/post/go-reflect-talk/</link>
      <pubDate>Tue, 06 Jun 2017 15:16:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/go-reflect-talk/</guid>
      <description>&lt;p&gt;go的reflect实现了一个运行时反射，它允许程序操纵任意类型的对象&lt;/p&gt;

&lt;p&gt;reflect.TypeOf函数能把对象的类型信息，它返回一个relect.Type&lt;/p&gt;

&lt;p&gt;reflect.Type.Field模块可以获得&lt;strong&gt;struct&lt;/strong&gt;或者&lt;strong&gt;interface&lt;/strong&gt;中的字段名，字段类型，字段的tag等信息&lt;/p&gt;

&lt;p&gt;reflect.ValueOf可以获得一个对象的值信息，比如它是指针还是实体，值的类型和interface类型下的值，它返回一个reflect.Value&lt;/p&gt;

&lt;p&gt;我这里简单谈谈reflect的用法和哪些能做到哪些不能做到&lt;/p&gt;

&lt;p&gt;Ps:以下所有代码都包含在这个&lt;a href=&#34;https://github.com/bigpigeon/Test/tree/master/go/reflect_demo&#34;&gt;测试项目&lt;/a&gt;中&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;reflect库有3个重要的类型，Type,Value和StructField,分别对应对象类型，对象值，字段对象&lt;/p&gt;

&lt;p&gt;Type和Value可以通过TypeOf(obj)和ValueOf(obj)的方法来获取obj的类型属性和值属性&lt;/p&gt;

&lt;p&gt;当Type的类型为Struct时可以通过Field，FieldByIndex，FieldByName模块等到里面的StructField&lt;/p&gt;

&lt;p&gt;而Value下的Field，FieldByIndex，FieldByName只是获取字段对应的Value&lt;/p&gt;

&lt;h3 id=&#34;普通字段的取值&#34;&gt;普通字段的取值&lt;/h3&gt;

&lt;p&gt;int类型，其他比如float,uint和complex都是这种，就不举例了&lt;/p&gt;

&lt;p&gt;t是*testing.T，因为是在Test函数里面跑，所以用t.Logf来打印日志&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a int = 20
aVal := reflect.ValueOf(a)
aType := reflect.TypeOf(a)
t.Logf(&amp;quot;variable a Value is %v&amp;quot;, aVal.Interface())
t.Logf(&amp;quot;variable a Type is %s&amp;quot;, aType.String())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a string = &amp;quot;abcd1234&amp;quot;
aVal := reflect.ValueOf(a)
aType := reflect.TypeOf(a)
t.Logf(&amp;quot;variable a Value is %v&amp;quot;, aVal.Interface())
t.Logf(&amp;quot;variable a Type is %s&amp;quot;, aType.String())
t.Logf(&amp;quot;variable a length is %d, last character is %c&amp;quot;, aVal.Len(), aVal.Index(aVal.Len()-1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a []int = []int{1, 2, 3, 4, 5}
// 当使用append遇到list的空间不足时会重分配n*2的空间，这里只是为了让cap和length不同才这么做
a = append(a, 6)
aVal := reflect.ValueOf(a)
aType := reflect.TypeOf(a)
t.Logf(&amp;quot;variable a Value is %v&amp;quot;, aVal.Interface())
t.Logf(&amp;quot;variable a Type is %s&amp;quot;, aType.String())
t.Logf(&amp;quot;variable a length is %d,cap is %d, last int is %d&amp;quot;, aVal.Len(), aVal.Cap(), aVal.Index(aVal.Len()-1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a map[int]string = map[int]string{1: &amp;quot;a&amp;quot;, 2: &amp;quot;b&amp;quot;, 3: &amp;quot;c&amp;quot;}
aVal := reflect.ValueOf(a)
aType := reflect.TypeOf(a)
OneVal := reflect.ValueOf(1)
t.Logf(&amp;quot;variable a Value is %v&amp;quot;, aVal.Interface())
t.Logf(&amp;quot;variable a Type is %s&amp;quot;, aType.String())
t.Logf(&amp;quot;variable a length is %d,one index value is %s&amp;quot;, aVal.Len(), aVal.MapIndex(OneVal))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改对象的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var a int32 = 10
// 要改变reflect的中的值必须是一个指针的Elem()下的reflect.Value
aVal := reflect.ValueOf(a)
aPointVal := reflect.ValueOf(&amp;amp;a)
t.Logf(&amp;quot;variable a set status %v&amp;quot;, aVal.CanSet())
t.Logf(&amp;quot;variable a in point set status %v&amp;quot;, aPointVal.Elem().CanSet())
// 不用担心因为SetInt传入的是一个int64而设置负数会导致不正确，在这个函数中会根据int具体类型而做转换
aPointVal.Elem().SetInt(-20)
t.Logf(&amp;quot;variable a changed value %d&amp;quot;, aPointVal.Elem().Interface())
// Slice中元素都可以修改
var b []int = []int{1, 2, 3, 4}
bVal := reflect.ValueOf(b)
t.Logf(&amp;quot;slice b first element set status %v&amp;quot;, bVal.Index(0).CanSet())
// Map中元素都不能直接修改
var c map[int]int = map[int]int{1: 2, 2: 4, 3: 6}
cVal := reflect.ValueOf(c)
oneValue := reflect.ValueOf(1)
fourValue := reflect.ValueOf(4)

t.Logf(&amp;quot;map c the 1 key l element set status %v&amp;quot;, cVal.MapIndex(oneValue).CanSet())
// 不过可以使用SetMapIndex修改Val的值
cVal.SetMapIndex(oneValue, oneValue)
t.Logf(&amp;quot;map c the value with 1 key is %d&amp;quot;, cVal.MapIndex(oneValue))
// 也可以对不存在的key设值
cVal.SetMapIndex(fourValue, oneValue)
t.Logf(&amp;quot;now map c is %v&amp;quot;, cVal)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;结构体字段的取值&#34;&gt;结构体字段的取值&lt;/h3&gt;

&lt;p&gt;创建几个相关联的结构体和模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Application struct {
	Name        string `json:&amp;quot;name&amp;quot;`
	Description string `json:&amp;quot;description&amp;quot;`
	packageData []byte `json:&amp;quot;-&amp;quot;`
}
type MoneyType int

const (
	MoneyTypeUS = MoneyType(iota)
	MoneyTypeCN
)

type Money struct {
	MoneyType MoneyType `json:&amp;quot;money_type&amp;quot; xml:&amp;quot;MoneyType&amp;quot;`
	Number    float64   `json:&amp;quot;number&amp;quot;`
}

type MacApplication struct {
	Application `json:&amp;quot;application&amp;quot;`
	AppleStore  string `json:&amp;quot;apple_store&amp;quot;`
	Favorite    int    `json:&amp;quot;favorite&amp;quot;`
	Money       Money  `json:&amp;quot;money&amp;quot;`
}

func (app Application) GetData() []byte {
	return app.packageData
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并创建对应的对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;app := MacApplication{
  Application: Application{
    Name:        &amp;quot;sandbox tower defence&amp;quot;,
    Description: &amp;quot;a rpg td game&amp;quot;,
    packageData: []byte{},
  },
  AppleStore: &amp;quot;https://itunes.apple.com/us/app/example&amp;quot;,
  Favorite:   0,
  Money: Money{
    MoneyType: MoneyTypeUS,
    Number:    0,
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;strong&gt;reflect.Type下的Field(i)模块函数&lt;/strong&gt; 来获取结构体的第i个字段的StructField信息&lt;/p&gt;

&lt;p&gt;获得StructField可以获取字段的名字，标签和偏移量和索引信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;structVal := reflect.TypeOf(app)
for i := 0; i &amp;lt; structVal.NumField(); i++ {
			field := structVal.Field(i)
      // 如果是匿名字段,字段名等于类型名
      t.Logf(&amp;quot;%s, this field is a %s and kind is %v&amp;quot;, field.Name, field.Type, field.Type.Kind())

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过StructField.Anonymous判断是否匿名字段，StructField.Type.Kind() == reflect.Struct判断是否结构体，用这种方式来递归读取struct中的结构体信息&lt;/p&gt;

&lt;p&gt;下面这个函数带有一个回调，递归读取structType的字段， 并把它下面的每一个field都交给f去处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var RecursionGetField func(string, reflect.Type, func(field *reflect.StructField))
RecursionGetField = func(prefix string, structType reflect.Type, f func(field *reflect.StructField)) {
  for i := 0; i &amp;lt; structType.NumField(); i++ {
    field := structType.Field(i)
    field.Name = prefix + &amp;quot;.&amp;quot; + field.Name
    f(&amp;amp;field)
    if field.Type.Kind() == reflect.Struct {
      // 匿名结构体字段中的字段当成当前结构体的
      if field.Anonymous == true {
        RecursionGetField(prefix, field.Type, f)
      } else {
        RecursionGetField(field.Name, field.Type, f)
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过StructField.Tag获取标签相关信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;structVal := reflect.TypeOf(app)
for i := 0; i &amp;lt; structVal.NumField(); i++ {
     field := structVal.Field(i)
     t.Logf(&amp;quot;this field %s,tag is &#39;%s&#39; json field &#39;%s&#39;&amp;quot;, field.Name, field.Tag, field.Tag.Get(&amp;quot;json&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;应用实现&#34;&gt;应用实现&lt;/h3&gt;

&lt;p&gt;通过获取Field Name和Type Name来组装创建表的sql语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 这里只是做简单取类型和字段名,不涉及主键和附加属性的处理
// tableFields[table name][field name][field kind name]
tableFields := map[string]map[string]string{}
tables := []string{}
sqlTypeMap := map[reflect.Kind]string{
  reflect.Int:     &amp;quot;integer&amp;quot;,
  reflect.String:  &amp;quot;varchar(255)&amp;quot;,
  reflect.Float64: &amp;quot;real&amp;quot;,
}
structType := reflect.TypeOf(MacApplication{})
var GetTableField func(string, reflect.Type)

GetTableField = func(tName string, structType reflect.Type) {

  if tableFields[tName] == nil {
    tableFields[tName] = map[string]string{}
  }
  for i := 0; i &amp;lt; structType.NumField(); i++ {
    field := structType.Field(i)
    if field.Type.Kind() == reflect.Struct {
      if field.Anonymous == true {
        GetTableField(tName, field.Type)
      } else {
        GetTableField(field.Type.Name(), field.Type)
      }
    } else {
      tableFields[tName][field.Name] = sqlTypeMap[field.Type.Kind()]
    }
  }
}
GetTableField(structType.Name(), structType)
// 通过tableFields表组装sql到tables中
for tName, fields := range tableFields {
  fNameTypeList := []string{}
  for fName, fType := range fields {
    fNameTypeList = append(fNameTypeList, fmt.Sprintf(`&amp;quot;%s&amp;quot; %s`, fName, fType))
  }
  tables = append(tables, fmt.Sprintf(`CREATE TABLE &amp;quot;%s&amp;quot;(%s)`, tName, strings.Join(fNameTypeList, &amp;quot;,&amp;quot;)))
}
for _, tab := range tables {
  t.Log(tab)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据字段值的指针猜字段名，需要提供对象的指针和对象字段的指针，然后通过偏移量计算出StructField&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;structType := reflect.TypeOf(MacApplication{})
offsetmap := map[uintptr]reflect.StructField{}

for i := 0; i &amp;lt; structType.NumField(); i++ {
  field := structType.Field(i)
  offsetmap[field.Offset] = field
}

{
  realFieldName := &amp;quot;Application&amp;quot;
  structVal := reflect.ValueOf(&amp;amp;app)
  ApplicationVal := reflect.ValueOf(&amp;amp;app.Application)
  offset := ApplicationVal.Elem().UnsafeAddr() - structVal.Elem().UnsafeAddr()
  assert.Equal(t, realFieldName, offsetmap[offset].Name)
  t.Logf(&amp;quot;I guess this field is %s, real field is %s&amp;quot;, offsetmap[offset].Name, realFieldName)
}
{
  realFieldName := &amp;quot;AppleStore&amp;quot;
  structVal := reflect.ValueOf(&amp;amp;app)
  AppleStoreVal := reflect.ValueOf(&amp;amp;app.AppleStore)
  offset := AppleStoreVal.Elem().UnsafeAddr() - structVal.Elem().UnsafeAddr()
  assert.Equal(t, realFieldName, offsetmap[offset].Name)
  t.Logf(&amp;quot;I guess this field is %s, real field is %s&amp;quot;, offsetmap[offset].Name, realFieldName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型比对&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;a := MoneyTypeCN
b := 2
aType := reflect.TypeOf(a)
bType := reflect.TypeOf(b)
// 虽然他们的种类一样但类型不一样(kind翻译为种类是为了不和Type混淆)
t.Logf(&amp;quot;a kind is %v, b kind is %v&amp;quot;, aType.Kind(), bType.Kind())
t.Logf(&amp;quot;a Type is %v, b Type is %v&amp;quot;, aType.String(), bType.String())
// 也可以通过转为interface直接比较类型
_, aIsInt := reflect.New(aType).Interface().(int)
t.Logf(&amp;quot;a is int?%v&amp;quot;, aIsInt)
_, bIsMoneyType := reflect.New(bType).Interface().(MoneyType)
t.Logf(&amp;quot;b is MoneyType?%v&amp;quot;, bIsMoneyType)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>gorm简介[前]</title>
      <link>https://bigpigeon.org/post/gorm-tutorial-first/</link>
      <pubDate>Mon, 29 May 2017 15:16:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/gorm-tutorial-first/</guid>
      <description>&lt;p&gt;我们都知道，在正式环境中直接使用sql来查询数据库是很危险的，处理不好就有被注入式攻击的风险&lt;/p&gt;

&lt;p&gt;而且组装sql语句也容易出错和减低代码的可维护性&lt;/p&gt;

&lt;p&gt;所以需要一个工具来管理数据库语句的组装和操作&lt;/p&gt;

&lt;p&gt;gorm是目前比较成熟的go语言数据库管理库,它可以很方便的把go的结构体和数据库表绑定，从而简化获取数据的操作
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所有gorm的内容在它的&lt;a href=&#34;http://jinzhu.me/gorm/&#34;&gt;文档&lt;/a&gt;中已经介绍的很详细，所以我这里写的大部分内容可能只是对原文进行了翻译和个人理解上的补充&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;

&lt;h4 id=&#34;连接数据库&#34;&gt;&lt;strong&gt;连接数据库&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main
import (
	&amp;quot;github.com/jinzhu/gorm&amp;quot;
  //需要连接那个数据库，就import对应的dialect包
	_ &amp;quot;github.com/jinzhu/gorm/dialects/mysql&amp;quot;
	//_ &amp;quot;github.com/jinzhu/gorm/dialects/postgres&amp;quot;
	//_ &amp;quot;github.com/jinzhu/gorm/dialects/sqlite&amp;quot;
  //_ &amp;quot;github.com/jinzhu/gorm/dialects/mssql&amp;quot;
)

func main(){
  db, err := gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;user:password@/dbname?charset=utf8&amp;amp;parseTime=True&amp;amp;loc=Local&amp;quot;)
  defer db.close()
  //db, err := gorm.Open(&amp;quot;postgres&amp;quot;, &amp;quot;host=myhost user=gorm dbname=gorm sslmode=disable password=mypassword&amp;quot;)
  //defer db.Close()
  //db, err := gorm.Open(&amp;quot;sqlite3&amp;quot;, &amp;quot;/tmp/gorm.db&amp;quot;)
  //defer db.Close()
  //db, err = gorm.Open(&amp;quot;mssql&amp;quot;, &amp;quot;sqlserver://username:password@localhost:1433?database=dbname&amp;quot;)
  //defer db.Close()
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建表&#34;&gt;&lt;strong&gt;创建表&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;首先我们来看看如何建立一个和数据库关联的struct&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
type Category struct {
	Name        string `gorm:&amp;quot;primary_key&amp;quot;`
	Description string `gorm:&amp;quot;size:255;default:&#39;nothing in here&#39;&amp;quot;`
}

type Email struct {
	ID         int
	UserId     int
	Email      string `gorm:&amp;quot;type:varchar(100);unique_index&amp;quot;`
	Subscribed bool
}

type Origin struct {
	ID        int
	ProductID uint
	Address1  string `gorm:&amp;quot;not null;unique&amp;quot;`
	Address2  string `gorm:&amp;quot;unique&amp;quot;`
}

type Language struct {
	ID   int
	Name string `gorm:&amp;quot;index:idx_name_code&amp;quot;`
	Code string `gorm:&amp;quot;index:idx_name_code&amp;quot;`
}

type Product struct {
	gorm.Model
	Name string `gorm:&amp;quot;index;size:255&amp;quot;`

	Sid         int        `gorm:&amp;quot;unique_index&amp;quot;`
	Categories  []Category `gorm:&amp;quot;many2many:categories_product;&amp;quot;`
	Emails      []Email    `gorm:&amp;quot;ForeignKey:UserId&amp;quot;`
	Origin      *Origin
	Languages   []Language
	Score       *float64 `gorm:&amp;quot;not null;default:1.0&amp;quot;`
	Description string   `gorm:&amp;quot;size:255;default:&#39;nothing in here&#39;&amp;quot;`
}

type GreekAlphabet struct {
	ID         uint   `gorm:&amp;quot;primary_key&amp;quot;`
	LatinName  string `gorm:&amp;quot;unique_index&amp;quot;`
	UpperCode  rune
	LowerCode  rune
	IsFrequent bool `gorm:&amp;quot;index&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gorm会go的类型自动转成数据库类型，也可以通过type指定数据库类型
以下是默认情况下go类型和数据库类型对照(这里用postgres举例)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;go类型&lt;/th&gt;
&lt;th&gt;数据库类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;uint&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int8-32&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;uint8-32&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;time.Time&lt;/td&gt;
&lt;td&gt;timestamp&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;float32&lt;/td&gt;
&lt;td&gt;numeric&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;float64&lt;/td&gt;
&lt;td&gt;numeric&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;特殊的数组类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用数组类型 默认会当成是一对多模式,可以通过tag修改关系
在一对多模式下，使用数组类型中的类型必须是对应另一个数据表的struct,并且对象struct中要包含名字为&lt;strong&gt;当前表名+ID&lt;/strong&gt;的字段，该字段类型最好对应当前表的primary_key类型&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我们看看Product包含了匿名字段gorm.Model，以下类型都有特殊含义&lt;/p&gt;

&lt;p&gt;gorm会在创建和修改，删除时自动填充CreatedAt和UpdatedAt，DeletedAt时自动填充字段值&lt;/p&gt;

&lt;p&gt;在gorm中匿名struct中的字段中的Field都会被继承，所以&lt;strong&gt;你也可以像gorm.Model这样把常用字段抽象成一个struct&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ID字段也是默认被当成primary_key的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package gorm

...

type Model struct {
	ID        uint `gorm:&amp;quot;primary_key&amp;quot;`
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt *time.Time `sql:&amp;quot;index&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gorm的一大特性就是能用struct的tag来指定栏属性，以下是gorm tag的关键字意义&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;通用&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;索引&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;index:key_name&lt;/td&gt;
&lt;td&gt;自定义索引名，但2个索引名相同时变为组合索引&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unique_index&lt;/td&gt;
&lt;td&gt;唯一索引，组合索引的方法同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;primary_key&lt;/td&gt;
&lt;td&gt;建立主键，组合的方法同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;not null&lt;/td&gt;
&lt;td&gt;指定类型的值不能为空(注意这个not null只是数据库中能否为nil和数据值是否为空没有关系，string一样可以取&amp;rdquo;&amp;ldquo;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;忽略该字段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;数据类型&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;many2many:must_key_name&lt;/td&gt;
&lt;td&gt;建立多对多的关系，需要声明多对多的表名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ForeignKey:must_key_name&lt;/td&gt;
&lt;td&gt;指定外键名(外键名必须是对应struct的所拥有的字段名)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;字符串类型&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;size:255&lt;/td&gt;
&lt;td&gt;指定长度，一般用于字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;type:varchar(100)&lt;/td&gt;
&lt;td&gt;指定类型，不同类型函数的参数不一样&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;整数字段&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AUTO_INCREMENT&lt;/td&gt;
&lt;td&gt;自动增长&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后通过db.CreateTable在数据库中创建对应的数据库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;tables := []interface{}{&amp;amp;Category{}, &amp;amp;Email{}, &amp;amp;Origin{}, &amp;amp;Language{}, &amp;amp;Product{}}
db.DropTableIfExists(tables...)
db.CreateTable(tables...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们可以在数据库看到表的create statement(因为postgres的语法太罗嗦了，所以这里用sqlite举例)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sqlite&#34;&gt;CREATE TABLE &amp;quot;categories&amp;quot; (&amp;quot;name&amp;quot; varchar(255),&amp;quot;description&amp;quot; varchar(255) DEFAULT &#39;nothing in here&#39; , PRIMARY KEY (&amp;quot;name&amp;quot;))
CREATE TABLE &amp;quot;categories_product&amp;quot; (&amp;quot;product_id&amp;quot; integer,&amp;quot;category_name&amp;quot; varchar(255), PRIMARY KEY (&amp;quot;product_id&amp;quot;,&amp;quot;category_name&amp;quot;))
CREATE TABLE &amp;quot;emails&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;user_id&amp;quot; integer,&amp;quot;email&amp;quot; varchar(100),&amp;quot;subscribed&amp;quot; bool )
CREATE TABLE &amp;quot;languages&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;name&amp;quot; varchar(255),&amp;quot;code&amp;quot; varchar(255) )
CREATE TABLE &amp;quot;origins&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;product_id&amp;quot; integer,&amp;quot;address1&amp;quot; varchar(255) NOT NULL UNIQUE,&amp;quot;address2&amp;quot; varchar(255) UNIQUE )
CREATE TABLE &amp;quot;products&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;created_at&amp;quot; datetime,&amp;quot;updated_at&amp;quot; datetime,&amp;quot;deleted_at&amp;quot; datetime,&amp;quot;name&amp;quot; varchar(255),&amp;quot;sid&amp;quot; integer,&amp;quot;score&amp;quot; real NOT NULL  DEFAULT 1.0,&amp;quot;description&amp;quot; varchar(255) DEFAULT &#39;nothing in here&#39; )
CREATE TABLE &amp;quot;greek_alphabets&amp;quot; (&amp;quot;id&amp;quot; integer primary key autoincrement,&amp;quot;latin_name&amp;quot; varchar(255),&amp;quot;upper_code&amp;quot; integer,&amp;quot;lower_code&amp;quot; integer,&amp;quot;is_frequent&amp;quot; bool )
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建数据&#34;&gt;&lt;strong&gt;创建数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;创建数据比创建表简单多了，我们只需要把数据填入结构体，然后通过db.Create(interface{})来初始化,像这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;categories := []Category{
	Category{&amp;quot;mobile phone&amp;quot;, &amp;quot;a hand-held mobile radiotelephone for use in an area divided into small sections, each with its own short-range transmitter/receiver&amp;quot;},
	Category{&amp;quot;apple&amp;quot;, &amp;quot;&amp;quot;},
}
emails := []Email{Email{Email: &amp;quot;example@domain.com&amp;quot;, Subscribed: false}}
origin := Origin{Address1: &amp;quot;apple company address&amp;quot;, Address2: &amp;quot;test&amp;quot;}
languages := []Language{Language{Name: &amp;quot;中国&amp;quot;, Code: &amp;quot;cn&amp;quot;}, Language{Name: &amp;quot;美国&amp;quot;, Code: &amp;quot;us&amp;quot;}}
score := float32(0.0)
product := Product{
	Name:       &amp;quot;iphone7&amp;quot;,
	Sid:        1211,
	Categories: categories,
	Emails:     emails,
	Origin:     &amp;amp;origin,
	Languages:  languages,
	Score:      &amp;amp;score,
}
err := db.Create(&amp;amp;product).Error
if err != nil {
	t.Error(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信细心的人已经注意到，我在创建Product时Score字段设为指针，这是因为gorm在创建表时会自动把所有为0值的值忽略(0值的定义可以看&lt;a href=&#34;https://golang.org/ref/spec#The_zero_value&#34;&gt;go的介绍&lt;/a&gt;),而Score又设置了默认值为1.0。&lt;/p&gt;

&lt;p&gt;也就是说，&lt;strong&gt;如果Score如果不是指针字段，它将永远没法设置为0值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个规则在下面的查询，插入和更新中也会有，在创建struct时一定要注意这些细节&lt;/p&gt;

&lt;h4 id=&#34;查询数据&#34;&gt;&lt;strong&gt;查询数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;为了方便查询，我们这里增加几条数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;categories := []Category{
	Category{&amp;quot;mobile phone&amp;quot;, &amp;quot;a hand-held mobile radiotelephone for use in an area divided into small sections, each with its own short-range transmitter/receiver&amp;quot;},
	Category{&amp;quot;xiaomi&amp;quot;, &amp;quot;&amp;quot;},
}
emails := []Email{Email{Email: &amp;quot;example2@domain.com&amp;quot;, Subscribed: false}}
origin := Origin{Address1: &amp;quot;xiaomi company address&amp;quot;, Address2: &amp;quot;&amp;quot;}
languages := []Language{Language{Name: &amp;quot;中国&amp;quot;, Code: &amp;quot;cn&amp;quot;}}
score := float32(2.0)
product := Product{
	Name:       &amp;quot;xiaomi6&amp;quot;,
	Sid:        1311,
	Categories: categories,
	Emails:     emails,
	Origin:     &amp;amp;origin,
	Languages:  languages,
	Score:      &amp;amp;score,
}
err := db.Create(&amp;amp;product).Error
if err != nil {
	t.Error(err)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;categories := []Category{
  Category{&amp;quot;food&amp;quot;, &amp;quot; sth solid for eating&amp;quot;},
  Category{&amp;quot;meat&amp;quot;, &amp;quot;&amp;quot;},
}
emails := []Email{Email{Email: &amp;quot;example3@domain.com&amp;quot;, Subscribed: false}}
origin := Origin{Address1: &amp;quot;163 company address&amp;quot;, Address2: &amp;quot;163 company address2&amp;quot;}
languages := []Language{Language{Name: &amp;quot;中国&amp;quot;, Code: &amp;quot;cn&amp;quot;}}
score := float32(3.0)
product := Product{
  Name:       &amp;quot;wild boar meat&amp;quot;,
  Sid:        9999,
  Categories: categories,
  Emails:     emails,
  Origin:     &amp;amp;origin,
  Languages:  languages,
  Score:      &amp;amp;score,
}
err := db.Create(&amp;amp;product).Error
if err != nil {
  t.Error(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Where查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果我想查询Product.Name = &amp;ldquo;xiaomi6&amp;rdquo;，可以这样写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
// 因为我知道xiaomi6只有一个结果，所以直接这样写
db.Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where这里的参数和上面Create中提到的规则一样，为空值的字段不会被当成查询条件，所以想查询比如Score为0，字段必须是指针字段&lt;/p&gt;

&lt;p&gt;First就是获取第一个查询结果，下面会讲到&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First函数就是获取第一个查询的结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
db.First(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对的查询最后一个结果,用Last函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
db.Last(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里说明一点，这里调用Last和First所需要的product指针最好是一个内容为空的对象，因为若product.ID不为空，则只会把对象更新为该ID对应的对象，若其他字段不为空就有可能污染查询到的结果&lt;/p&gt;

&lt;p&gt;查询全部则用Find&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var products []Product
db.Find(&amp;amp;products)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gorm默认不会查询外键对象，如果想把结构体字段的内容也查询出来，可以使用Preload函数预加载这个结构体,像下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var product Product
db.Preload(&amp;quot;Origin&amp;quot;).Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;product)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然可以查出Origin字段的数据，不过却使用到了字符串，这样也导致人为拼写错误的可能和增加维护成本，我们可以使用go的反射来解决这个问题，这里就不细说了&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;更新数据&#34;&gt;&lt;strong&gt;更新数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Save&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Save更新不会忽略0值，但每次只能更新一条数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var xiaomi Product
db.Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;xiaomi)
xiaomi.Sid = 0
db.Save(&amp;amp;xiaomi)
var product Product
db.Where(&amp;amp;Product{Name: &amp;quot;xiaomi6&amp;quot;}).First(&amp;amp;product)
//查看product有无更新成功
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用Updates可以进行批量更新，空值依然会被忽略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;db.Model(&amp;amp;Product{}).Updates(&amp;amp;Product{Description: &amp;quot;also nothing here&amp;quot;})
products := []Product{}
db.Find(&amp;amp;products)
for _, p := range products {
	t.Log(p.Name, p.Description)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;删除数据&#34;&gt;&lt;strong&gt;删除数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;删除数据时要保证被删除数据的主键不能为空，不然会吧整个表的数据都删掉&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var meat Product
db.Where(&amp;amp;Product{Name: &amp;quot;wild boar meat&amp;quot;}).First(&amp;amp;meat)

var product Product
db.Where(&amp;amp;Product{Name: &amp;quot;wild boar meat&amp;quot;}).First(&amp;amp;product)
// 这时查到的product应该为空
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为product中包含DeleteAt字段，所以并不会数据并不会真的被删除，只是设置了DeleteAt为当前时间&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;如果数据表没有DeletedAt字段，那么调用Delete会物理删除数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var email Email
db.First(&amp;amp;email)
id := email.ID
db.Delete(&amp;amp;email)
// 打印id
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;支持多种sql数据库&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持struct到数据表的映射&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;知道struct tag的到字段属性的映射&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持Scope自定义操作，以补充该库功能上的不足(以后会讲到)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;受限于go的struct，在gorm的查询无法查询0值，而使用指针会让结构体变的异常丑陋&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;条件查询,嵌套查询等操作还是要借助字符串表达式&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说gorm还是一个不错orm,用来做简单数据的增删改查还是非常方便，在日常请求的逻辑处理基本是够用的&lt;/p&gt;

&lt;h4 id=&#34;链接&#34;&gt;&lt;strong&gt;链接&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://jinzhu.me/gorm/&#34;&gt;gorm官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bigpigeon/Test/tree/master/go/gorm_demo&#34;&gt;测试代码地址&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git错误push与回滚</title>
      <link>https://bigpigeon.org/post/git-push-recover-way/</link>
      <pubDate>Thu, 09 Mar 2017 09:44:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/git-push-recover-way/</guid>
      <description>&lt;p&gt;之前看漏眼把一个zip的文件commit了,然后我又不小心push到远程gitlab上,导致项目直接大了10M。于是我查了下git的资料，发现可以用删除分支来解决这个问题,下面我来讲讲做法&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;本地处理&#34;&gt;本地处理&lt;/h3&gt;

&lt;p&gt;首先需要把checkout到错误分支的前一个分支(假设我的分支名为bate)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout bate^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后checkout到新的分支上,并把正确的文件提交过来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b bate-recover
git checkout bate - file.xx
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后删除bate分支并提交,因为bate分支没合并所以需要强制删除，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch -D bate
git push origin bate --delete
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后把bate-recover分支checkout到bate上再提交，完成！！！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b bate
git push origin bate
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;已pull项目处理&#34;&gt;已pull项目处理&lt;/h3&gt;

&lt;p&gt;如果某个服务器不小心pull了这个带zip文件的分支同样需要删除分支:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 首先checkout到其他分支
git checkout master
# 删除bate分支
git branch -D bate
# 重新pull bate分支
git pull origin bate
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>我的翻墙技术栈</title>
      <link>https://bigpigeon.org/post/my-skip-gfw-stack/</link>
      <pubDate>Tue, 27 Dec 2016 17:07:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/my-skip-gfw-stack/</guid>
      <description>&lt;p&gt;谈到翻墙，很多人第一时间想到的就是shdowsocks，虽然简单的搭建一个shadowsocks服务就可以实现翻墙，不过很快你就会发现代理的速度并不理想，而且有时会发生长时间无法链接的情况。&lt;/p&gt;

&lt;p&gt;这是因为网络有的错误丢包被当成拥塞丢包，所以发送窗口一直没法增大。&lt;/p&gt;

&lt;p&gt;linux kernel 4.9支持BBR拥塞控制算法可以解决这个问题&lt;/p&gt;

&lt;p&gt;也可以通过其他协议工具比如:&lt;a href=&#34;https://github.com/xtaci/kcptun&#34;&gt;kcptun&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;kcptun可以提供双边加速和窗口控制，效果可能比bbr好&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;服务端&#34;&gt;服务端&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;机器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一定要买一台国外的机器(不然翻个毛墙啊),节点推荐日本的(因为地理位置比较近)&lt;/p&gt;

&lt;p&gt;我这里用的是&lt;a href=&#34;https://www.vultr.com/&#34;&gt;vultr&lt;/a&gt;的vps节点是选的日本机房,用这个&lt;a href=&#34;http://www.vultr.com/?ref=7049331-3B&#34;&gt;优惠码&lt;/a&gt;注册可以获取20$抵用现金，推荐&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;操作系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;red hat/centos或者debain/ubuntu 均可&lt;/p&gt;

&lt;p&gt;这是我的操作系统版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /proc/version
Linux version 3.10.0-327.28.3.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.3 20140911 (Red Hat 4.8.3-9) (GCC) ) #1 SMP Thu Aug 18 19:05:49 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装软件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我推荐使用go版本的kcptun和shadowsocks,这样部署和维护都比较方便(如果使用bbr可以忽略kcptun部分,开启bbr可以看&lt;a href=&#34;https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95&#34;&gt;这里&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 下载并解压go的二进制包
wget https://storage.googleapis.com/golang/go1.7.4.linux-amd64.tar.gz
tar -xf go1.7.4.linux-amd64.tar.gz
# 把文件移到库文件夹并创建连接
mv go /usr/local/lib/
ln -s /usr/local/lib/go/bin/* /usr/local/bin/
# 增加go的第三方安装包文件并把go的环境变量加入profile
mkdir /usr/local/lib/go/packages


vim /etc/profile.d/go.sh
# 把一下内容复制进去
export GOROOT=/usr/local/lib/go
export GOPATH=$GOROOT/packages
export PATH=$GOPATH/bin:$PATH

# 加载环境变量
. /etc/profile.d/go.sh

# 安装shadowsocks和kcptun
go get github.com/xtaci/kcptun/server
go get github.com/shadowsocks/shadowsocks-go

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置shadowsocks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;shadowsocks配置文件格式是json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/shadowsocks.json
# 把下面的json数据复制进去
{
  &amp;quot;server&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;method&amp;quot;: &amp;quot;aes-256-cfb&amp;quot;,
  &amp;quot;port_password&amp;quot;: {
    &amp;quot;5501&amp;quot;: &amp;quot;your password&amp;quot;
  },
  &amp;quot;timeout&amp;quot;: 300
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://shadowsocks.org/en/config/advanced.html&#34;&gt;可以通过修改服务端内核参数提升shadowsocks的发包效率&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用supervisor管理进程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安装supervisor(没有pip自行想办法)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置supervisor.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/supervisor.conf
# 把以下内容复制进去
; supervisor config file

[unix_http_server]
file=/var/run/supervisor.sock   ; (the path to the socket file)
chmod=0700                       ; sockef file mode (default 0700)

[supervisord]
logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)
pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)
childlogdir=/var/log/supervisor            ; (&#39;AUTO&#39; child log dir, default $TEMP)

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket

; The [include] section can just contain the &amp;quot;files&amp;quot; setting.  This
; setting can list multiple files (separated by whitespace or
; newlines).  It can also contain wildcards.  The filenames are
; interpreted as relative to this file.  Included files *cannot*
; include files themselves.

[include]
files = /etc/supervisor.d/*.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置kcptun和shadowsocks&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 如果没有创建该文件夹
mkdir /etc/supervisor.d

vim /etc/supervisor.d/proxy.ini
# 把以下内容复制进去
[program:shadowsocks]
directory=/usr/lib/go/packages/bin
command=/usr/lib/go/packages/bin/shadowsocks-server -c /etc/shadowsocks.json
user=root
process_name=%(program_name)s
numprocs=1
autostart=true
autorestart=true
stdout_logfile=/var/log/shadowsocks.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=2
redirect_stderr=true

[program:kcptun]
directory=/usr/lib/go/packages/bin
command=/usr/lib/go/packages/bin/server -t &amp;quot;127.0.0.1:5501&amp;quot; -l &amp;quot;:5501&amp;quot; -mode fast2 --crypt aes-128
user=root
process_name=%(program_name)s
numprocs=1
autostart=true
autorestart=true
stdout_logfile=/var/log/kcptun.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=2
redirect_stderr=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动supervisor&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;supervisord -c /etc/supervisor.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;iptables的filter表配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你的服务器有配iptables，那可能要增加一下规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -I INPUT -p udp -m udp --dport 5501 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把新的配置加入开机启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables-save &amp;gt; /etc/iptables.rule

vim /etc/rc.local
# 在新的一行中添加以下内容
/sbin/iptables-restore &amp;lt; /etc/iptables.rule

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;客户端配置&#34;&gt;客户端配置&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;kcptun客户端&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用bbr可以忽略这部分&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://github.com/xtaci/kcptun/releases/tag/v20161222&#34;&gt;https://github.com/xtaci/kcptun/releases/tag/v20161222&lt;/a&gt; 中下载对应的版本&lt;/p&gt;

&lt;p&gt;启动客户端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;client_darwin_amd64 -r &amp;quot;服务器IP地址:5501&amp;quot; -l &amp;quot;:8388&amp;quot; -mode fast2 --crypt aes-128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;shadowsocks客户端&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;windows的&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-windows/releases&#34;&gt;下载页面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mac OS X的&lt;a href=&#34;https://github.com/shadowsocks/ShadowsocksX-NG/releases&#34;&gt;下载页面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;linux桌面版本的&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation&#34;&gt;下载页面&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;编辑config.json,把以下内容复制进去保存,并把这个文件导入shadowsocks(使用bbr时server和server_port填服务器地址和端口号)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;configs&amp;quot;: [
        {
            &amp;quot;method&amp;quot;: &amp;quot;aes-256-cfb&amp;quot;,
            &amp;quot;password&amp;quot;: &amp;quot;your password&amp;quot;,
            &amp;quot;remarks&amp;quot;: &amp;quot;public_vultr&amp;quot;,
            &amp;quot;server&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
            &amp;quot;server_port&amp;quot;: 8388
        }
    ],
    &amp;quot;localPort&amp;quot;: 1080,
    &amp;quot;shareOverLan&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用SwitchyOmega为chrome代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在chrome商店或者&lt;a href=&#34;https://github.com/FelisCatus/SwitchyOmega/releases&#34;&gt;这里&lt;/a&gt;下载SwitchyOmega&lt;/p&gt;

&lt;p&gt;下载的插件拖入chorme即可安装&lt;/p&gt;

&lt;p&gt;在下载SwitchyOmega设置中增加一个pac profile,并在pac script中加入以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var domains = [
    &amp;quot;google.com&amp;quot;,
    &amp;quot;facebook.com&amp;quot;,
    &amp;quot;twitter.com&amp;quot;,
    &amp;quot;google.co.jp&amp;quot;,
    &amp;quot;gmail.com&amp;quot;,
    &amp;quot;golang.org&amp;quot;,
    &amp;quot;github.com&amp;quot;,
    &amp;quot;s3.amazonaws.com&amp;quot;,
    &amp;quot;twimg.com&amp;quot;,
    &amp;quot;wikipedia.org&amp;quot;,
    &amp;quot;youtube.com&amp;quot;,
    &amp;quot;gstatic.com&amp;quot;,
    &amp;quot;stackoverflow.com&amp;quot;,
    &amp;quot;shadowsocks.org&amp;quot;

];
var domain_dict = {};
for(var i = 0; i &amp;lt; domains.length; i++){
    if(domains[i].endsWith(&amp;quot;.&amp;quot;)){
        domains[i] = domains[i].slice(0, -1)
    }
    var url_list = domains[i].split(&#39;.&#39;);

    var domain_node = domain_dict;
    for(var j = url_list.length; j &amp;gt; 0; j--){
        var node_name = url_list[j-1];
        if (!domain_node.hasOwnProperty(node_name)){
            if (j === 1){
                domain_node[node_name] = true;
                break;
            } else {
                domain_node[node_name] = {};
            }
        } else if(domain_node[node_name] === true) {
            break;
        }
        domain_node = domain_node[node_name];
    }
}

var proxy = &amp;quot;SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT&amp;quot;;

var direct = &#39;DIRECT;&#39;;

function FindProxyForURL(url, host) {
    if( host == &amp;quot;localhost&amp;quot; ||
        host == &amp;quot;127.0.0.1&amp;quot;) {
        return direct;
    }
    var host_list = host.split(&#39;.&#39;)
    var domain_node = domain_dict
    for(var i = host_list.length; i &amp;gt; 0; i--){
        var node_name = host_list[i-1]
        if (domain_node.hasOwnProperty(node_name)){
            if(domain_node[node_name] === true){
                return proxy;
            } else {
                domain_node = domain_node[node_name]
            }

        }
        else {
            return direct;
        }
    }
    return direct;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pac用的是javascript语法，需要代理的域名只要加入domains即可&lt;/p&gt;

&lt;p&gt;父域名会自动匹配所有子域名,比如domains中加入google.com 那www.google.com map.google.com的内容都会被代理&lt;/p&gt;

&lt;p&gt;关于这份pac的更多内容可以看&lt;a href=&#34;https://bigpigeon.org/post/switchy-proxy-pac-optimization&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>从jekyll到hugo，搬运经验总结</title>
      <link>https://bigpigeon.org/post/jekyll-to-hugo/</link>
      <pubDate>Wed, 12 Oct 2016 11:43:37 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/jekyll-to-hugo/</guid>
      <description>&lt;p&gt;因为我对新技术的热爱和向往，我选择博客从jekyll换成hugo了，本来是想记录一下他们之间区别，搬运完才发现它们在功能上竟然是如此的相识,所以我只能讲jekyll如何搬运到hugo.&lt;/p&gt;

&lt;p&gt;hugo和jekyll一样也是静态页面框架，有着和jekyll相似文件结构和配置方法，不过hugo有着更快的生成速度和更好的markdown引擎，支持toml,yaml,json配置文件格式，hugo又从hexo中借鉴了不少特性,比如live reload。而且hugo是go开发的，模板语法中能找到go语言的影子，这也是我使用它的主要原因。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;如何安装&#34;&gt;如何安装&lt;/h3&gt;

&lt;p&gt;先下载&lt;a href=&#34;https://golang.org/dl/&#34;&gt;go&lt;/a&gt;，然后配置GOPATH环境变量，通过&lt;strong&gt;go get&lt;/strong&gt;命令下载的包都会放到GOPATH中，在GOPATH中的包也可以被其他包import&lt;/p&gt;

&lt;p&gt;然后配置PATH,这样通过go安装的命令可以被直接执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=$GOPATH/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装&lt;a href=&#34;https://github.com/spf13/hugo&#34;&gt;hugo&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果下载超时可以尝试挂代理，设置http_proxy和https_proxy就可以使用http(s)代理,如果是socket代理，建议用&lt;a href=&#34;http://www.delegate.org/delegate/&#34;&gt;delegate&lt;/a&gt;转成http(s)代理&lt;/p&gt;

&lt;h3 id=&#34;创建第一个博客&#34;&gt;创建第一个博客&lt;/h3&gt;

&lt;p&gt;hugo可以通过下面的命令快速构建一个hugo的文件结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new site firstblog
Congratulations! Your new Hugo site is created in &amp;quot;/data/work/firstblog&amp;quot;.

Just a few more steps and you’re ready to go:

1. Download a theme into the same-named folder.
   Choose a theme from https://themes.gohugo.io/, or
   create your own with the &amp;quot;hugo new theme &amp;lt;THEMENAME&amp;gt;&amp;quot; command.
2. Perhaps you want to add some content. You can add single files
   with &amp;quot;hugo new &amp;lt;SECTIONNAME&amp;gt;/&amp;lt;FILENAME&amp;gt;.&amp;lt;FORMAT&amp;gt;&amp;quot;.
3. Start the built-in live server via &amp;quot;hugo server&amp;quot;.

Visit https://gohugo.io/ for quickstart guide and full documentation.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看文件结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tree firstblog
firstblog/
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes

6 directories, 1 file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看看各个文件夹的作用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;archetypes&lt;/strong&gt;: 允许自定义post front matter(就是见面开头+++那部分)，并且会在hugo new 时给默认值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;config.toml&lt;/strong&gt;: 主配置文件，hugo也支持也可以使用yaml和json格式，不过默认以config.toml为主配置文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;content&lt;/strong&gt;: 博客的文章，关于，demo等内容都放在这个目录下，使用&lt;strong&gt;hugo new&lt;/strong&gt;命令创建的文件会存放在这个目录下，你可以定义不同的子目录作为sections,文章的默认sections是post&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;data&lt;/strong&gt;: 这个目录存放一个用于生成网站的数据，你可以使用YAML,JSON或者TOML格式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;layouts&lt;/strong&gt;: 用来存放html模板，这些模板将决定你网页的布局，更详细的内容可以查看&lt;a href=&#34;https://gohugo.io/templates/overview/&#34;&gt;templates&lt;/a&gt;章节&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;static&lt;/strong&gt;: 存放网站静态文件的目录，在网站生成后会将该目录的文件放到网站的根目录下，不要和content下的文件有重名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;themes&lt;/strong&gt;: 存放主题，建议用主题来决定网站的风格样式，网站只存放内容&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后按照提示我们去&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;https://themes.gohugo.io/&lt;/a&gt; 找一个主题，并把它下载到
themes目录中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd firstblog/themes
$ git clone https://github.com/fredrikloch/hugo-uno.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改config.toml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;$ cd firstblog
firstblog/$ cat config.toml
baseurl = &amp;quot;http://replace-this-with-your-hugo-site.com/&amp;quot;
title = &amp;quot;My blog&amp;quot;
languageCode = &amp;quot;en-us&amp;quot;
theme = &amp;quot;hugo-uno&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一篇新的文章&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd firstblog
$ hugo new post/start.md
/data/work/firstblog/content/post/start.md created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在content文件夹中找到你刚刚创建的markdown文件然后编辑，编辑好后就可以通过&lt;strong&gt;hugo server&lt;/strong&gt;运行了，然后在本地访问&lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; 就可以看到你的网站了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd firstblog
$ hugo server
Started building sites ...
Built site for language en:
0 draft content
0 future content
0 expired content
1 pages created
0 non-page files copied
0 paginator pages created
2 categories created
2 tags created
total in 34 ms
Watching for changes in /data/work/firstblog/{data,content,layouts,static,themes}
Serving pages from memory
Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)
Press Ctrl+C to stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常见问题&#34;&gt;常见问题&lt;/h3&gt;

&lt;h4 id=&#34;分页问题&#34;&gt;&lt;strong&gt;分页问题&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在模板中使用.Paginate，该页面就会被自动分页
比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;!--拿到当前分页--&amp;gt;
    {{ $paginator := .Paginate (where .Data.Pages &amp;quot;Section&amp;quot; &amp;quot;post&amp;quot;) }}
    ...
    &amp;lt;!--读取分页内容--&amp;gt;
    {{ range $paginator.Pages }}

        {{ .Render &amp;quot;summary&amp;quot;}}
    ...
    {{ end }}
    ...
    &amp;lt;!--增加翻页按钮--&amp;gt;
    {{ if $paginator.HasPrev}}
    &amp;lt;a href=&amp;quot;{{ $paginator.Prev.URL }}&amp;quot;&amp;gt;上一页&amp;lt;/a&amp;gt;
    {{ else }}
    &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
    {{ end }}
    &amp;lt;a href=&amp;quot;{{ .Site.BaseURL }}/post/&amp;quot;&amp;gt;归档&amp;lt;/a&amp;gt;
    {{ if $paginator.HasNext }}
    &amp;lt;a href=&amp;quot;{{ $paginator.Next.URL }}&amp;quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
    {{ else }}
    &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
    {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认分页的对象数是10，可以通过在config中定义Paginate去改变分页数&lt;/p&gt;

&lt;h4 id=&#34;额外的页面&#34;&gt;&lt;strong&gt;额外的页面&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;为了让我的demo页面和文章页面分离开来，需要用到section这个功能，在上面的模板可以看到&lt;strong&gt;where .Data.Pages &amp;ldquo;Section&amp;rdquo; &amp;ldquo;post&amp;rdquo;&lt;/strong&gt;，这个语句就是取所有页面中section位post的页面，那么问题来了:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何判断这个页面是属于那个section&lt;/li&gt;
&lt;li&gt;如何为section添加展示页&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如何判断这个页面是属于那个section&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如我们一开始的是用&lt;strong&gt;hugo new post/start.md&lt;/strong&gt;创建页面的section就是post&lt;/p&gt;

&lt;p&gt;也就是在content中的子文件夹名就是section名，比如我要在网站增加一个名为demo的section&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new demo/first.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时访问&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/demo/first&#34;&gt;http://localhost:1313/demo/first&lt;/a&gt;&lt;/strong&gt;就可以看到该页面了，这个页面是由layouts/_default/single.html模板渲染的，如果你想自定义渲染的模板可以新增layouts/demo/single.html作为demo单页的渲染模板&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何为section添加展示页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在layouts/section/中添加一个html模板，模板名必须和section名一致,比如我们为demo添加一个展示页&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat &amp;gt;&amp;gt; layouts/section/demo.html &amp;lt;&amp;lt;EOF
{{ partial &amp;quot;head.html&amp;quot; . }}
    &amp;lt;!--拿到当前分页--&amp;gt;
    {{ $paginator := .Paginate (where .Data.Pages &amp;quot;Section&amp;quot; &amp;quot;demo&amp;quot;) }}
    ...
    &amp;lt;!--读取分页内容--&amp;gt;
    {{ range $paginator.Pages }}

        {{ .Render &amp;quot;summary&amp;quot;}}
    ...
    {{ end }}
    ...
    &amp;lt;!--增加翻页按钮--&amp;gt;
    {{ if $paginator.HasPrev}}
    &amp;lt;a href=&amp;quot;{{ $paginator.Prev.URL }}&amp;quot;&amp;gt;上一页&amp;lt;/a&amp;gt;
    {{ else }}
    &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
    {{ end }}
    &amp;lt;a href=&amp;quot;{{ .Site.BaseURL }}/post/&amp;quot;&amp;gt;归档&amp;lt;/a&amp;gt;
    {{ if $paginator.HasNext }}
    &amp;lt;a href=&amp;quot;{{ $paginator.Next.URL }}&amp;quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
    {{ else }}
    &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
    {{ end }}
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样访问&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/demo&#34;&gt;http://localhost:1313/demo&lt;/a&gt;&lt;/strong&gt;  就可以看到展示页了&lt;/p&gt;

&lt;p&gt;hugo还有一个summary的功能，可以让你把单页的部分内容放入展示页渲染，添加一个layouts/模板名/summary.html的模板，然后像上面的例子中那样使用&lt;strong&gt;{{ .Render &amp;ldquo;summary&amp;rdquo;}}&lt;/strong&gt;就可以把容内渲染进展示页中&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于template的使用可以翻阅&lt;a href=&#34;https://gohugo.io/templates/overview/&#34;&gt;官方文档&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Iptables学习笔记</title>
      <link>https://bigpigeon.org/post/iptables-study/</link>
      <pubDate>Tue, 28 Jun 2016 16:00:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/iptables-study/</guid>
      <description>&lt;p&gt;以前我也很抵触去配置iptables，当时我觉得iptables这种工具实在是太复杂了，配置的命令超级长，而且只有命令行没有图形化工具，而大多数云服务器都有自己的一套防火墙，比如aws的EC2就有自己的安全组，简单易用并且可以直接在网页上直接配置，非常的方便。&lt;/p&gt;

&lt;h2 id=&#34;hugomore42&#34;&gt;&lt;/h2&gt;

&lt;p&gt;但后来我接触linux运维越来越多才发现，iptables虽然缺点一大堆，但它胜在功能非常强大，并且可以满足大多数网络管理上的需求，在没有更好的代替品出现前iptables绝对是必不可少的工具。&lt;/p&gt;

&lt;p&gt;下面我就简单总结一下iptables的用途&lt;/p&gt;

&lt;h3 id=&#34;什么是iptables&#34;&gt;什么是iptables&lt;/h3&gt;

&lt;p&gt;一提到iptables大部分人想到的估计就是防火墙，但其实防火墙只是iptables的filter表部分,iptables本身还可以做NAT（NAT表）和mangle（mangle表）&lt;/p&gt;

&lt;h3 id=&#34;为什么需要iptables&#34;&gt;为什么需要iptables&lt;/h3&gt;

&lt;p&gt;iptables可以翻译成ip表，可以理解为对ip做一些处理的工具，因为iptables的这些模块，所以这个问题应该为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;为什么需要
  filter
  nat
  mangle
  raw
  security


filter很好理解，因为要防止外网非法访问

SNAT在局域网访问外网的必要工具，而DNAT则是为了把局域网的服务接出去，比如如何让docker的服务端口暴露到本机上

而mangle,raw,secrurity因为我没有接触过，所以不予评价
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;如何查看配置项&#34;&gt;如何查看配置项&lt;/h3&gt;

&lt;p&gt;查看iptables的配置可以用iptables-save [-t table]来查看完整的配置&lt;/p&gt;

&lt;p&gt;有人说可以直接用&lt;strong&gt;iptables -L&lt;/strong&gt;查看，但不建议这样做，因为&lt;strong&gt;iptables -L&lt;/strong&gt;为了格式化输出会忽略掉一些信息比如filter表中的接口信息就无法查看。&lt;/p&gt;

&lt;h3 id=&#34;如何配置表&#34;&gt;如何配置表&lt;/h3&gt;

&lt;h3 id=&#34;filter&#34;&gt;filter&lt;/h3&gt;

&lt;p&gt;filter是iptables中最常用的表,而filter默认有3个链&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;INPUT: 进入linux本机时过滤
OUTPUT: 本机送出时过滤
FORWARD: 这个是访问本机转换的封包时过滤，比如你在本机配置了DNAT或者SNAT，那些被转换后并且目的地不在本地的包不会被INPUT/OUTPUT过滤器过滤，而是就由这个规则过滤
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中最常用的就是INPUT 链，这里我用INPUT 的链做说明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -A INPUT -i eth0 -d 50.24.131.30/32 -p tcp --dport 27017 -J DROP
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-A表示append，就是把规则加到末尾，如果想加到表头可以使用-I

INPUT就是配置到INPUT这个chain

-i 就是包进入的网卡，只能在INPUT链中使用,反之-o就是包出去的网卡，只能在OUTPUT链中使用

-d表示destination,就是**目标网络ip/网域**，如果想匹配**来源Ip/网域**就用-s,但作为服务一般很少限制来源ip

-d/-s 设定支持一下几种格式:
IP : 192.168.0.1
网域: 192.168.0.0/24
xx之外可以使用 ！表示比如
-s ! 192.168.0.1表示匹配除192.168.0.1之外的ip

-p 表示协议，可选的就4种tcp,udp,icmp和all，默认就是all，只有-p等于tcp或udp时才可以使用--dport和--sport

--dport表示destination port,就是目标端口 很好理解，同理还有--sport

-J 表示操作，主要有DROP(丢弃),ACCEPT(接受),REJECT(拒绝)和LOG(记录)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DROP和REJECT的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;REJECT就是你请求过来时会告诉你拒绝消息，而DROP就是你请求过来时直接把包删掉&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预设策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当封包没有被链中的规则匹配时就会被预设策略匹配&lt;/p&gt;

&lt;p&gt;预设策略有3种，分别对应3条链,我的服务器的预设策略是这样配置的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -P INPUT   DROP
iptables -P OUTPUT  ACCEPT
iptables -P FORWARD ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;nat表也有预设策略但用的很少就不说明了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结一下iptables filter的用法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables [-A|-I INPUT|FILTER|OUTPUT ] [-i|-o 网络接口 ] [-s 源ip或网域] [-p tcp|udp [--sport 端口号或端口范围] [--dport 端口号或端口范围] all|icmp] [-d 目标ip或网域] &amp;lt;-j ACCEPT|DROP|REJECT|LOG &amp;gt;

# 预设策略的配置
iptables -P &amp;lt;INPUT|OUTPUT|FORWARD&amp;gt; &amp;lt;ACCEPT|DROP&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PS:filter中还有[-m 外挂模组]对包的内容做进一步匹配和筛选&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;nat&#34;&gt;nat&lt;/h3&gt;

&lt;p&gt;先介绍一下nat表的三个链表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)
POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)
OUTPUT：與發送出去的封包有關
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说道nat大家应该不会陌生，比如路由器的内网转外网用到的就是SNAT，而docker容器的端口转换用的就是DNAT&lt;/p&gt;

&lt;p&gt;iptables的nat表除了SNAT和DNAT外还可以进行路由，ip选择&lt;/p&gt;

&lt;p&gt;下面会介绍几种常用的配置方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SNAT&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -t nat -A POSTROUTING -s 172.19.0.0/16 ! -o docker0 -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令就是把所有源地址属于172.17.0.0/16网段, 目标接口不是docker0的数据包进行伪装&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;docker启动后会为所有network网段增加SNAT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SNAT+ip选择&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设你有好几个ip，你想选择192.168.1.210作为172.19.0.0/16网段的出口ip可以这样写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -t nat -A POSTROUTING -s 172.19.0.0/16 ! -o docker0 -j MASQUERADE --to-source 192.168.1.210

# --to-source也可以指定一定范围内的ip比如192.168.1.210-192.168.1.211
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DNAT&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-A PREROUTING ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.3:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令就是把本地的80端口和172.17.0.3的80端口进行绑定，所有源接口不是docker0的数据包都会进行DNAT然后传给172.19.0.3:80&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在docker run中用-p绑定了本地端口后，会自动增加上面一项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结一下NAT的用法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -t nat [-A|-I POSTROUTING] [--to-source ip或网域]  &amp;lt;-j MASQUERADE&amp;gt;

iptables -t nat [-A|-I PREROUTING] [--to-destination ip或网域]  &amp;lt;-j MASQUERADE&amp;gt;

# filter和nat通用参数:
[-i|-o 网络接口 ] [-s 源ip或网域] [-p tcp|udp [--sport 端口号或端口范围] [--dport 端口号或端口范围] all|icmp] [-d 目标ip或网域]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.vbird.org/linux_server/0250simple_firewall.php&#34;&gt;鳥哥私房菜 第九章 防火牆與 NAT 伺服器&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>react学习笔记</title>
      <link>https://bigpigeon.org/post/react-study/</link>
      <pubDate>Thu, 21 Apr 2016 10:43:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/react-study/</guid>
      <description>&lt;h3 id=&#34;jsx&#34;&gt;JSX&lt;/h3&gt;

&lt;p&gt;React可以使用的是独有的JSX语法,包围它的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签type值为text/babel&lt;/p&gt;

&lt;p&gt;那什么是JSX呢，JSX其实就是JS+XML,在JSX中JS和XML可以同时存在,举个简单例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = &amp;lt;div class=&amp;quot;green&amp;quot;&amp;gt;my color is green&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在JSX中这样的写法是完全合法的,这个a可以当成是一个html的element使用&lt;/p&gt;

&lt;p&gt;也可以使用react.createElement创建element&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var app = React.createElement(
    &amp;quot;div&amp;quot;, //标签名或组件对象
    {class:&amp;quot;green&amp;quot;}, //元素属性集
    &amp;quot;my color is green&amp;quot; //子元素
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;createElement的更多信息&lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html#react.createelement&#34;&gt;看这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hugomore42&#34;&gt;&lt;/h2&gt;

&lt;p&gt;于是乎，我们可以自由组合js和xml了，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var names = [&#39;Alice&#39;, &#39;Emily&#39;, &#39;Kate&#39;];
&amp;lt;div&amp;gt;
  {
    names.map(function (name) {
      return React.createElement(
         &amp;quot;div&amp;quot;, {key: names.id + name},
         &amp;quot;hello &amp;quot; + name
      )
    })
  }
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当React遇到&amp;lt;时就会用xml解析,遇到{时就用js解析&lt;/p&gt;

&lt;h3 id=&#34;render&#34;&gt;render&lt;/h3&gt;

&lt;p&gt;刚才创建的element怎么运用到html中呢,这里就需要用到react的ReactDOM.render函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;把a元素加入到id为example的元素中&lt;/li&gt;
&lt;li&gt;a可以是一个html标签，也可以是组件对象&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;ReactDOM.render(
	a, //标签名或组件对象
	document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;组件&#34;&gt;组件&lt;/h3&gt;

&lt;p&gt;组件就像是一个会动的element,它有自己的方法和状态,并且可以通过一些内置函数控制element的行为.&lt;/p&gt;

&lt;p&gt;可以拿它和c++的类做类比, 赋予的值就是类名,this.props中的就是类的初始化参数,&lt;Message name=&#34;pigeon&#34;/&gt;就是实例化一个类&lt;/p&gt;

&lt;p&gt;先来看看如何创建和使用一个组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Message = React.createClass({
  render: function() {
    return &amp;lt;div&amp;gt;Hello {this.props.name}&amp;lt;/div&amp;gt;;
  }
});

ReactDom.render(
  &amp;lt;Message name=&amp;quot;pigeon&amp;quot;/&amp;gt;,
  document.getElementById(&#39;example&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;propTypes方法可以强制指定属性类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面该例子将会在浏览器画一个矩形,并且指定x和y属性的类型必须为数字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Box = React.createClass({
    propTypes: {
      x: React.PropTypes.number.isRequired,
      y: React.PropTypes.number.isRequired,
    },
    render: function() {
      return &amp;lt;svg&amp;gt;&amp;lt;rect width={this.props.x} height={this.props.y} /&amp;gt;&amp;lt;/svg&amp;gt;
    }
});
ReactDOM.render(
    &amp;lt;Box x={100} y={100}/&amp;gt;,
    document.body
)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;getDefaultProps可以为属性设置默认值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面圆形中的边会变成为绿色&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Circle = React.createClass({
    getDefaultProps : function() {
        return {
            stroke: &amp;quot;green&amp;quot;,
            fill: &amp;quot;yellow&amp;quot;
        }
    },
    render: function() {
        return (
        &amp;lt;svg&amp;gt;
        &amp;lt;circle cx=&amp;quot;50&amp;quot; cy=&amp;quot;50&amp;quot; r={this.props.r} stroke={this.props.stroke} strokeWidth=&amp;quot;4&amp;quot; fill={this.props.fill} /&amp;gt;
        &amp;lt;/svg&amp;gt;);
    }

});
ReactDOM.render(
    &amp;lt;Circle r={50} fill=&amp;quot;red&amp;quot;/&amp;gt;,
    document.getElementById(&amp;quot;example&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;获取真实的DOM节点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;组件并不是真实的DOM,
有时候需要获取真实DOM就必须用到ref属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var MyComponent = React.createClass({
  handleClick: function() {
    this.refs.myTextInput.focus();
  },
  render: function() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; ref=&amp;quot;myTextInput&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Focus the text input&amp;quot; onClick={this.handleClick} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});

ReactDOM.render(
  &amp;lt;MyComponent /&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;组件拥有状态，状态和属性的区别在于，属性表示那些不变的值，而状态会和用户交互&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Circle = React.createClass({
    getInitialState: function() {
        return {fill: &amp;quot;pink&amp;quot;}
    },
    handleClick: function(event) {
        if(this.state.fill === &amp;quot;pink&amp;quot;) {
            this.setState({fill: &amp;quot;blue&amp;quot;});
        } else {
            this.setState({fill: &amp;quot;pink&amp;quot;});
        }
    },
    getDefaultProps : function() {
        return {
            stroke: &amp;quot;green&amp;quot;,
        }
    },
    render: function() {
        return (
            &amp;lt;svg&amp;gt;
                &amp;lt;circle cx=&amp;quot;50&amp;quot; cy=&amp;quot;50&amp;quot; r={this.props.r} stroke={this.props.stroke} fill={this.state.fill} strokeWidth=&amp;quot;4&amp;quot;  onClick={this.handleClick} /&amp;gt;
            &amp;lt;/svg&amp;gt;
        );
    }
});
ReactDOM.render(
    &amp;lt;Circle r={50} /&amp;gt;,
    document.getElementById(&amp;quot;example&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;表单&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用户填入表单的数据react的组件是无法通过this.props读取的，必须通过onChange回调函数等方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var MySelect = React.createClass({
    getInitialState: function(){
      return {
          select: &amp;quot;KFC&amp;quot;
      }
    },
    change: function (event) {
        console.log(&amp;quot;chang once &amp;quot;+ event.target.value);
        this.setState({select: event.target.value});

    },
    render: function() {
        var select_value = this.state.select;
        return (
        &amp;lt;div&amp;gt;
          &amp;lt;select id=&amp;quot;lang&amp;quot; onChange={this.change} defaultValue={select_value}&amp;gt;
            &amp;lt;option value=&amp;quot;KFC&amp;quot;&amp;gt;KFC&amp;lt;/option&amp;gt;
            &amp;lt;option value=&amp;quot;mcdonald&amp;quot;&amp;gt;mcdonald&amp;lt;/option&amp;gt;
          &amp;lt;/select&amp;gt;
          &amp;lt;p&amp;gt;supper: {select_value}&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    )}
});
ReactDOM.render(
    &amp;lt;MySelect /&amp;gt;,
    document.getElementById(&amp;quot;example&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;组件有个生命周期的概念，生命周期分为3部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mounting：已插入真实 DOM
Updating：正在被重新渲染
Unmounting：已移出真实 DOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与之对应的N个函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getInitialState() 初始化state函数
componentWillMount() 当组件将被挂载
componentDidMount() 当组件挂载之后
componentWillReceiveProps(object nextProps) 当挂载的组件接收新的属性时
shouldComponentUpdate(object nextProps, object nextState): boolean  组件是否更新的callback,返回false表示不更新
componentWillUpdate(object nextProps, object nextState) 组件更新之前
componentDidUpdate(object prevProps, object prevState) 组件更新之后
componentWillUnmount() 组件卸载之前
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;一个异步请求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在请求未收到前页面会一直处于loading状态,我们通过让组件挂载后调用componentDidMount方法来异步获取github api上的数据&lt;/p&gt;

&lt;p&gt;在ajax请求完成前一直显示等待信息,ajax请求到达后通过this.setState去触发页面的重新渲染&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var MyList = React.createClass({
    getInitialState: function() {
        return {
            loading: true,
            data: null,
            error: null
        }
    },
    componentDidMount: function(){
        this.props.promise.done(
            msg =&amp;gt; {this.setState({loading: false, data:msg});}
        ).fail(
            (jqXHR, textStatus) =&amp;gt; {this.setState({loading: false, error: textStatus });}
        )
    },
    render: function () {
        if (this.state.loading) {
            return &amp;lt;span&amp;gt;loading...&amp;lt;/span&amp;gt;;
        }
        else if (this.state.error !== null) {
            return &amp;lt;span&amp;gt;Error: {this.state.error}&amp;lt;/span&amp;gt;;
        }
        else {
            var repos = this.state.data.items;
            var repoList = repos.map(function (repo){
                return (
                    &amp;lt;li&amp;gt;
                        &amp;lt;a href={repo.html_url}&amp;gt;{repo.name}&amp;lt;/a&amp;gt;
                        ({repo.stargazers_count} stars)
                        &amp;lt;br/&amp;gt;
                        {repo.description}
                    &amp;lt;/li&amp;gt;
                )
            });
            return (
                &amp;lt;main&amp;gt;
                    &amp;lt;h1&amp;gt;Most Popular JavaScript Projects in Github&amp;lt;/h1&amp;gt;
                    &amp;lt;ol&amp;gt;{repoList}&amp;lt;/ol&amp;gt;
                &amp;lt;/main&amp;gt;
            );
        }
    }
});
ReactDOM.render(
    &amp;lt;MyList promise={$.getJSON(&amp;quot;https://api.github.com/search/repositories?q=golang&amp;amp;sort=stars&amp;quot;)}/&amp;gt;,
    document.body
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;好了-总结一下&#34;&gt;好了,总结一下&lt;/h3&gt;

&lt;p&gt;react想要把元素挂载到真实DOM上必须用&lt;strong&gt;ReactDOM.render&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该函数第一参数是想要挂载的组件或html标签&lt;/p&gt;

&lt;p&gt;第二参数则是被挂载的html标签对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;react的基本函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;createElement 创建一个html的标签
createClass 创建一个React的组件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React的组件和html标签可以互相任意嵌套&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;creactClass中有各种各样的内置函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;render 在组件被挂载或者更新时调用
getDefaultProps 设置组件默认属性值
getInitialState 设置组件默认状态值
组件生命周期 Mounting, Updating, Unmounting 发生变化前后回调的一些函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React的组件无法获取用户的交互信息,必须通过回调函数来通知组件.&lt;/p&gt;

&lt;p&gt;比如按钮点击,表单信息的修改,&lt;/p&gt;

&lt;p&gt;如果React的组件也想触发事件必须先通过this.ref获取真实的DOM,虚拟DOM是无法触发事件的&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>postgresql类型</title>
      <link>https://bigpigeon.org/post/postgresql-type/</link>
      <pubDate>Sun, 13 Mar 2016 10:30:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/postgresql-type/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;postgresql支持的类型相当的多,配合postgresql的函数就已经可以满足很多业务的需求了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;但是繁多的类型也导致了postgresql的学习成本和复杂度的问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这里我来做个笔记简单讲讲postgresql的数据类型有哪些和如何用好这些类型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PS:以下内容都基于postgresql 9.3&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TODO:有些类型的例子和介绍还没写完，以后再补上&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本类型&#34;&gt;基本类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;尺寸&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;smallint&lt;/td&gt;
&lt;td&gt;2bytes&lt;/td&gt;
&lt;td&gt;小范围的整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;td&gt;4bytes&lt;/td&gt;
&lt;td&gt;典型整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;td&gt;8bytes&lt;/td&gt;
&lt;td&gt;大范围的整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;decimal&lt;/td&gt;
&lt;td&gt;可变&lt;/td&gt;
&lt;td&gt;用户指定空间,精确分数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;numeric&lt;/td&gt;
&lt;td&gt;可变&lt;/td&gt;
&lt;td&gt;用户指定空间的精确分数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;real&lt;/td&gt;
&lt;td&gt;4bytes&lt;/td&gt;
&lt;td&gt;不精确浮点数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;double-precision&lt;/td&gt;
&lt;td&gt;8bytes&lt;/td&gt;
&lt;td&gt;不精确浮点数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;smallserial&lt;/td&gt;
&lt;td&gt;2bytes&lt;/td&gt;
&lt;td&gt;小范围自增整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;serial&lt;/td&gt;
&lt;td&gt;4bytes&lt;/td&gt;
&lt;td&gt;普通范围自增整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bigserial&lt;/td&gt;
&lt;td&gt;8bytes&lt;/td&gt;
&lt;td&gt;大范围自增整数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;金融类型&#34;&gt;金融类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;money&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8bytes&lt;/td&gt;
&lt;td&gt;货币类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;字符类型&#34;&gt;字符类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;character varying(n), varchar(n)&lt;/td&gt;
&lt;td&gt;限制内的可变长度类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;character(n), char(n)&lt;/td&gt;
&lt;td&gt;固定长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;可变长度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;二进制类型&#34;&gt;二进制类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;binary&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1-4bytes&lt;/td&gt;
&lt;td&gt;可变长度的二进制字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;时间类型&#34;&gt;时间类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;timestamp[p] [ without time zone ]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8bytes&lt;/td&gt;
&lt;td&gt;包含时间和日期但没时区&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;timestamp[p] with time zone&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8bytes&lt;/td&gt;
&lt;td&gt;包含时间日期和时区&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;date&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4bytes&lt;/td&gt;
&lt;td&gt;日期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;time [ without time zone ]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8bytes&lt;/td&gt;
&lt;td&gt;不包括日期的时间，无时区&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;time with time zone&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12bytes&lt;/td&gt;
&lt;td&gt;不包含日期的时间，有时区&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;interval&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16bytes&lt;/td&gt;
&lt;td&gt;时间区间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;布尔类型&#34;&gt;布尔类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;枚举类型&#34;&gt;枚举类型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 创建一个枚举类型并作为person表的current_mood字段
CREATE TYPE mood AS ENUM (&#39;sad&#39;, &#39;ok&#39;, &#39;happy&#39;);
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES (&#39;Moe&#39;, &#39;happy&#39;);
SELECT * FROM person WHERE current_mood = &#39;happy&#39;;
 name | current_mood
------+--------------
 Moe  | happy
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;几何学图形类型&#34;&gt;几何学图形类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;point&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;平面坐标 (x, y)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;line&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;直线 ((x1,y1), (x2,y2))&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lseg&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;线段 ((x1,y1), (x2,y2))&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;box&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一个方形盒子 ((x1,y1), (x2,y2))&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;path&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16+16n bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;闭合路径(类似于多边形) ((x1,y1),&amp;hellip;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;path&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16+16n bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;开放路径 [(x1,y1),&amp;hellip;]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;polygon&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;40+16n bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;多边形（类似于闭合路径） ((x1,y1),&amp;hellip;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;circle&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;24 bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;圆 &amp;lt;(x,y),r&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;网络地址类型&#34;&gt;网络地址类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;尺寸&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cidr&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7 or 19 bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;ipv4或ipv6网络&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;inet&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7 or 19 bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;ipv4或ipv6地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;macaddr&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6bytes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;MAC地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;比特类型&#34;&gt;比特类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;只接受2进制数&lt;/li&gt;
&lt;li&gt;有2种模式 BIT(n) 和BIT VARYING(n)
官方例子:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B&#39;101&#39;, B&#39;00&#39;);
INSERT INTO test VALUES (B&#39;10&#39;, B&#39;101&#39;);
ERROR:  bit string length 2 does not match type bit(3)
INSERT INTO test VALUES (B&#39;10&#39;::bit(3), B&#39;101&#39;);
SELECT * FROM test;
  a  |  b
-----+-----
 101 | 00
 100 | 101
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文本查询类型&#34;&gt;文本查询类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;tsvector&lt;/li&gt;
&lt;li&gt;tsquery&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;uuid-类型&#34;&gt;UUID 类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;UUID 可用来作为唯一标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;xml-类型&#34;&gt;XML 类型&lt;/h3&gt;

&lt;p&gt;xml data是用来存储xml格式的数据的，用text领域来存xml数据，想要使用该数据类型需要在安装时 configure &amp;ndash;with-libxml
- xml用text领域来存xml数据&lt;/p&gt;

&lt;h3 id=&#34;json格式&#34;&gt;json格式&lt;/h3&gt;

&lt;p&gt;json 也是用text来存储, 但json数据类型的好处在存储时会进行检测，保证每一个值都是一个有效的json值，它还能相对的支持一些函数
在用json时最好保证数据的编码和postgresql的一致&lt;/p&gt;

&lt;h3 id=&#34;数组类型&#34;&gt;数组类型&lt;/h3&gt;

&lt;p&gt;演示创建一个带数组类型的表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO sal_emp
    VALUES (&#39;Bill&#39;,
    &#39;{10000, 10000, 10000, 10000}&#39;,
    &#39;\{\{&amp;quot;meeting&amp;quot;, &amp;quot;lunch&amp;quot;\}, \{&amp;quot;training&amp;quot;, &amp;quot;presentation&amp;quot;\}\}&#39;);

INSERT INTO sal_emp
    VALUES (&#39;Carol&#39;,
    &#39;{20000, 25000, 25000, 25000}&#39;,
    &#39;\{\{&amp;quot;breakfast&amp;quot;, &amp;quot;consulting&amp;quot;\}, {&amp;quot;meeting&amp;quot;, &amp;quot;lunch&amp;quot;\}\}&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM sal_emp;
 name  |      pay_by_quarter       |                 schedule
-------+---------------------------+-------------------------------------------
 Bill  | {10000,10000,10000,10000} | \{\{meeting,lunch\},\{training,presentation\}\}
 Carol | {20000,25000,25000,25000} | \{\{breakfast,consulting\},\{meeting,lunch\}\}
(2 rows)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多重数据的尺寸必须是相同的，一个错误的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO sal_emp
    VALUES (&#39;Bill&#39;,
    &#39;{10000, 10000, 10000, 10000}&#39;,
    &#39;\{\{&amp;quot;meeting&amp;quot;, &amp;quot;lunch&amp;quot;\}, \{&amp;quot;meeting&amp;quot;\}\}&#39;);
ERROR:  multidimensional arrays must have array expressions with matching dimensions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用 ARRAY构造语法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO sal_emp
    VALUES (&#39;Bill&#39;,
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[[&#39;meeting&#39;, &#39;lunch&#39;], [&#39;training&#39;, &#39;presentation&#39;]]);

INSERT INTO sal_emp
    VALUES (&#39;Carol&#39;,
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[[&#39;breakfast&#39;, &#39;consulting&#39;], [&#39;meeting&#39;, &#39;lunch&#39;]]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询pay_by_quarter的第一个值和第二个值不相等的条目的名字&lt;/p&gt;

&lt;p&gt;这里要注意 array的索引是从1开始的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT name FROM sal_emp WHERE pay_by_quarter[1] &amp;lt;&amp;gt; pay_by_quarter[2];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询pay_by_quarter的第三个值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT pay_by_quarter[3] FROM sal_emp;
 pay_by_quarter
----------------
          10000
          25000
(2 rows)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询schedule的多个值
&amp;gt; 这里注意postgresql的array中的切片和其他语言的也是不同的，它会返回[n:m]中的值并包括m的值
&amp;gt; 多重数组切片要全是切片不能[2][1:2]这种写法，而[1:2][2]这种写法会自动转成[1:2][1:2]&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = &#39;Bill&#39;;
        schedule
-------------------------
 \{\{breakfast\},\{meeting\}\}
(1 row)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用postgresql的内置函数查看某条数据的数组的长度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT array_dims(schedule) FROM sal_emp WHERE name = &#39;Carol&#39;;
 array_dims
------------
 [1:2][1:2]
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用array_upper和array_lower查看数组索引的最大值和最小值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = &#39;Carol&#39;;

 array_upper
-------------
           2
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;array_length函数则是查看数组长度和上面那几类函数的使用方法一样&lt;/p&gt;

&lt;p&gt;array_prepend/array_append 在数组前/后面加入元素&lt;/p&gt;

&lt;h3 id=&#34;array-cat&#34;&gt;&lt;strong&gt;array_cat:&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;|| 或修饰符 也能用于SELECT ，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT pay_by_quarter[1:2] || pay_by_quarter[4],name FROM sal_emp
      ?column?       |   name
---------------------+----------
 {10000,10000,10000} | Bill
 {27000,27000,25000} | Carol
(2 rows)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;修改数组&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;语法和SELECT中的差不多&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 在数组第1和第2元素之间插入数据
# 和查询一样，array的索引是从1开始的
UPDATE sal_emp SET pay_by_quarter[1:2] = &#39;{27000,27000}&#39;
    WHERE name = &#39;Carol&#39;;
UPDATE 1
SELECT pay_by_quarter FROM sal_emp WHERE name = &#39;Carol&#39;;
      pay_by_quarter
---------------------------
 {27000,27000,25000,25000}
(1 row)


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ANY 和 ALL 语法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;//先加一条数据
INSERT INTO sal_emp VALUES(&#39;bigpigeo&#39;, ARRAY[10000,20000,30000,40000], ARRAY[[&#39;cookie&#39;, &#39;html&#39;, &#39;head&#39;], [&#39;jia&#39;, &#39;the&#39;, &#39;nine&#39;]]);
INSERT 0 1
SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);
   name   |      pay_by_quarter       |                 schedule
----------+---------------------------+------------------------------------------
 Bill     | {10000,10000,10000,10000} | \{\{breakfast,consulting},\{meeting,lunch\}\}
 bigpigeo | {10000,20000,30000,40000} | \{\{cookie,html,head\},\{jia,the,nine\}\}

SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);
 name |      pay_by_quarter       |                 schedule
------+---------------------------+------------------------------------------
 Bill | {10000,10000,10000,10000} | \{\{breakfast,consulting\},\{meeting,lunch\}\}
(1 row)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;组合类型&#34;&gt;组合类型&lt;/h3&gt;

&lt;p&gt;postgresql 还支持组合类型个人感觉这种比JSON类型好，因为JSON相当于是弱类型的数据，不能很好的对数据做类型检查，使用时容易出问题&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先是创建复合类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TYPE complex AS (
    r       double precision,
    i       double precision
);

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是包含复合类型的表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE on_hand (
    item      inventory_item,
    count     integer
);

INSERT INTO on_hand VALUES (ROW(&#39;fuzzy dice&#39;, 42, 1.99), 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;当你创建一个表的同时也会创建一个和表名一样的复合类型&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;写入复合类型表达式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有2种写入方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;(val1, val2, ...)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或ROW语法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ROW(val1, val2, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;访问复合类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;访问复合类型的成员必须带括号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 查询价格大于9.99的数据
SELECT (item).name FROM on_hand WHERE (item).price &amp;gt; 9.99;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用函数访问也一样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;SELECT (my_func(...)).field FROM ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;修改复合类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Insert一个复合类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO on_hand (item) VALUES((&#39;fat pigeon&#39;, 43, 2.1));
INSERT 0 1
SELECT * FROM on_hand WHERE (item).name = &#39;fat pigeon&#39;;
         item          | count
-----------------------+-------
 (&amp;quot;fat pigeon&amp;quot;,43,2.1) |
(1 row)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update一个复合类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE on_hand SET item = ROW(&#39;fuzzy dice&#39;, 42, 2.99) WHERE (item).name = &#39;fuzzy dice&#39;;
UPDATE 1
SELECT * FROM on_hand WHERE (item).name = &#39;fuzzy dice&#39;;
          item          | count
------------------------+-------
 (&amp;quot;fuzzy dice&amp;quot;,42,2.99) |  1000
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update复合类型中子域的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE on_hand SET item.price = 2.5 WHERE (item).name = &#39;fuzzy dice&#39;;
UPDATE 1
SELECT * FROM on_hand WHERE item.name = &#39;fuzzy dice&#39;;
                                    ^
postgres=# SELECT * FROM on_hand WHERE (item).name = &#39;fuzzy dice&#39;;
         item          | count
-----------------------+-------
 (&amp;quot;fuzzy dice&amp;quot;,42,2.5) |  1000
(1 row)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;range类型&#34;&gt;Range类型&lt;/h3&gt;

&lt;p&gt;range类型可以表示一个值的范围，比如tsrange 可以表示timestamp 的范围&lt;/p&gt;

&lt;p&gt;以下是postgresSQL内置的range类型，你也可以&lt;a href=&#34;http://www.postgresql.org/docs/9.3/static/sql-createtype.html&#34;&gt;自定义&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int4range&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示整数的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int8range&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示大整数的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;numrange&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示numeric的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tsrange&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示为没有时区的timestamp的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tstzrange&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示为有时区的timestamp的范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;daterange&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;表示日期的范围&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;@&amp;gt;和*的注解可以查&lt;a href=&#34;http://www.postgresql.org/docs/9.3/static/functions-range.html#RANGE-OPERATORS-TABLE&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
    (1108, &#39;[2010-01-01 14:30, 2010-01-01 15:30)&#39;);


SELECT * FROM reservation WHERE during @&amp;gt; &#39;2010-01-01 14:50&#39;::timestamp;
 room |                    during
------+-----------------------------------------------
 1108 | [&amp;quot;2010-01-01 14:30:00&amp;quot;,&amp;quot;2010-01-01 15:30:00&amp;quot;)
(1 row)

--下面就是一些官方例子，自己也可以发挥想象力去尝试一下

-- Overlaps
SELECT numrange(11.1, 22.2) &amp;amp;&amp;amp; numrange(20.0, 30.0);

-- Extract the upper bound
SELECT upper(int8range(15, 25));

-- Compute the intersection
SELECT int4range(10, 20) * int4range(15, 25);

-- Is the range empty?
SELECT isempty(numrange(1, 5));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造一个range类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先range类型有2种表示范围的符号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[]表示包含范围符
()表示不包含范围符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是range类型也可其他类型一下可以字符串构造&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;SELECT &#39;[3,7)&#39;::int4range;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是构造函数构造&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT numrange(1.0, 14.0, &#39;(]&#39;);
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>在python上操作postgresql</title>
      <link>https://bigpigeon.org/post/python-and-postgresql/</link>
      <pubDate>Mon, 07 Mar 2016 10:30:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/python-and-postgresql/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本文使用的是postgresql 9.3 基于docker ubuntu&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首先postgresql的安装,这里我使用了自己build一个Dockerfile&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的Dockerfile:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM ubuntu:latest
MAINTAINER bigpigeon &amp;lt;3283273530@qq.com&amp;gt;

RUN apt-get -yqq update
RUN apt-get install -y postgresql-9.3

USER postgres
RUN touch /var/lib/postgresql/.psql_history
RUN /etc/init.d/postgresql start &amp;amp;&amp;amp;\
    psql --command &amp;quot;ALTER USER postgres WITH SUPERUSER PASSWORD &#39;123456&#39;;&amp;quot; &amp;amp;&amp;amp;\
    createdb -O postgres postgres
RUN echo &amp;quot;host all  all    0.0.0.0/0  md5&amp;quot; &amp;gt;&amp;gt; /etc/postgresql/9.3/main/pg_hba.conf
RUN echo &amp;quot;listen_addresses=&#39;*&#39;&amp;quot; &amp;gt;&amp;gt; /etc/postgresql/9.3/main/postgresql.conf

VOLUME  [&amp;quot;/etc/postgresql&amp;quot;, &amp;quot;/var/log/postgresql&amp;quot;, &amp;quot;/var/lib/postgresql&amp;quot;]
CMD [&amp;quot;/usr/lib/postgresql/9.3/bin/postgres&amp;quot;, &amp;quot;-D&amp;quot;, &amp;quot;/var/lib/postgresql/9.3/main&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;config_file=/etc/postgresql/9.3/main/postgresql.conf&amp;quot;]

EXPOSE 5432
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为postgresql不能用root启动，所以我们要改用postgres帐户，该帐户是在postgresql安装时自动创建的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;build docker&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t postgres:own .
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;跑一个docker 进程&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --name postgres -d -p 15432:5432 postgres:own
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入该进程&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -i -t postgres /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;之后来查看一下postgres启动的进程和端口&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//在docker中比较环境干净，所以没必要用grep筛选
# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
postgres     1  0.0  2.0 244920 20576 ?        Ss   06:05   0:00 /usr/lib/postgresql/9.3/bin/postgres -D /var/lib/pos
postgres     9  0.0  0.3 244920  3456 ?        Ss   06:05   0:00 postgres: checkpointer process
postgres    10  0.0  0.4 244920  4608 ?        Ss   06:05   0:00 postgres: writer process
postgres    11  0.0  0.3 244920  3456 ?        Ss   06:05   0:00 postgres: wal writer process
postgres    12  0.0  0.5 245672  5904 ?        Ss   06:05   0:00 postgres: autovacuum launcher process
postgres    13  0.0  0.3 100596  3396 ?        Ss   06:05   0:00 postgres: stats collector process
postgres    14  0.0  0.3  18228  3228 ?        Ss   06:09   0:00 /bin/bash
postgres    22  0.0  0.2  15572  2084 ?        R+   06:14   0:00 ps aux
# netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 127.0.0.1:5432          0.0.0.0:*               LISTEN
tcp6       0      0 ::1:5432                :::*                    LISTEN
udp6       0      0 ::1:59218               ::1:59218               ESTABLISHED
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ACC ]     STREAM     LISTENING     26950    /var/run/postgresql/.s.PGSQL.5432
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;连接控制台&#34;&gt;连接控制台&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用psql来连接postgresql服务端(记得第一时间改密码)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ psql -U postgres -h 127.0.0.1 -p 15432
=# \password postgres
=# \q
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;-U 指定登录用户 -d 指定数据库 -h -p 指定登录的主机和端口，更详细的参数可用&amp;ndash;help查询&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;通过postgresql控制台创建用户&#34;&gt;通过postgresql控制台创建用户&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ psql -U postgres -h 127.0.0.1 -p 15432
=# \password postgres
=# CREATE USER dbuser WITH PASSWORD &#39;password&#39;;
=# CREATE DATABASE exampledb OWNER dbuser;
=# GRANT ALL PRIVILEGES ON DATABASE exampledb to dbuser;
=# \q
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据库命令&#34;&gt;数据库命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# psql -U dbuser -d exampledb -h 127.0.0.1 -p 15432
// \password [username]: 修改[某用户]密码,只有超级用户才可以改其他人的密码
=&amp;gt; \password
Enter new password:
Enter it again:

// \encoding [ENCODING]: 显示[修改]客户端的编码
=&amp;gt; \encoding
UTF8

// \h [NAME]: 查看 所有[某条] SQL命令的解释，比如\h select。
=&amp;gt; \h select
Command:     SELECT
Description: retrieve rows from a table or view
Syntax:
[ WITH [ RECURSIVE ] with_query [, ...] ]
...
// \l [PATTERN]: 列出所有[某条] 数据库
=&amp;gt; \l
                             List of databases
   Name    |  Owner   | Encoding  | Collate | Ctype |   Access privileges
-----------+----------+-----------+---------+-------+-----------------------
 exampledb | dbuser   | SQL_ASCII | C       | C     | =Tc/dbuser           +
           |          |           |         |       | dbuser=CTc/dbuser
 postgres  | postgres | SQL_ASCII | C       | C     |
 template0 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
 template1 | postgres | SQL_ASCII | C       | C     | =c/postgres          +
           |          |           |         |       | postgres=CTc/postgres
(4 rows)

// \c [database_name]：连接其他数据库。
=&amp;gt; \c postgres
SSL connection (cipher: DHE-RSA-AES256-GCM-SHA384, bits: 256)
You are now connected to database &amp;quot;postgres&amp;quot; as user &amp;quot;dbuser&amp;quot;.

// \d [table_name]：列出所有[某一张]表格的结构。
// 因为目前还没建表，所以只有一句告警
=&amp;gt; \d
No relations found.
// \du[+] [PATTERN]：列出所有[某]用户。
=&amp;gt; \du
                             List of roles
 Role name |                   Attributes                   | Member of
-----------+------------------------------------------------+-----------
 dbuser    |                                                | {}
 postgres  | Superuser, Create role, Create DB, Replication | {}

// \conninfo：列出当前数据库和连接的信息。
=&amp;gt; \conninfo
You are connected to database &amp;quot;postgres&amp;quot; as user &amp;quot;dbuser&amp;quot; on host &amp;quot;127.0.0.1&amp;quot; at port &amp;quot;15432&amp;quot;.
SSL connection (cipher: DHE-RSA-AES256-GCM-SHA384, bits: 256)

// 更多命令可以通过\?查看
=&amp;gt; \?
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数据库操作&#34;&gt;数据库操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法和mysql相似,可通过\h去查看&lt;/li&gt;
&lt;li&gt;下面我将操作数据库语法去建表，插数据等操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;=&amp;gt; CREATE TABLE user_person(name VARCHAR(20), entry DATE);
CREATE TABLE
=&amp;gt; INSERT INTO user_person(name, entry) VALUES(&#39;jia&#39;, &#39;2016-2-28&#39;);
INSERT 0 1
=&amp;gt; ALTER TABLE user_person ADD job VARCHAR(100);
ALTER TABLE
=&amp;gt; INSERT INTO user_person(name, entry) VALUES(&#39;jib&#39;, &#39;2016-2-29&#39;);
INSERT 0 1
=&amp;gt; UPDATE user_person set job = &#39;backend develop&#39; WHERE name = &#39;jia&#39;;
UPDATE 1
=&amp;gt; UPDATE user_person set job = &#39;frontend develop&#39; WHERE name = &#39;jib&#39;;
UPDATE 1
=&amp;gt; ALTER TABLE user_person ALTER COLUMN job SET NOT NULL ;
ALTER TABLE
=&amp;gt; INSERT INTO user_person(name, entry) VALUES(&#39;jic&#39;, &#39;2016-3-1&#39;);
ERROR:  null value in column &amp;quot;job&amp;quot; violates not-null constraint
DETAIL:  Failing row contains (jic, 2016-03-01, null).
=&amp;gt; SELECT * FROM user_person;
 name |   entry    |       job
------+------------+------------------
 jia  | 2016-02-28 | backend develop
 jib  | 2016-02-29 | frontend develop
(2 rows)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;如何在python上操作postgresql&#34;&gt;如何在python上操作postgresql&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.postgresql.org/wiki/Python&#34;&gt;官网wiki&lt;/a&gt; 给出了6种python 版本的客户端&lt;/li&gt;
&lt;li&gt;我这里用的是&lt;a href=&#34;http://initd.org/psycopg/docs/&#34;&gt;Psycopg2&lt;/a&gt;因为它是这6个客户端中唯二使用LGPL许可证的，并且最近还有更新维护&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;第一部分-安装&#34;&gt;第一部分 安装&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;ubuntu:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只需要apt-get install python-psycopg2就ok&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;windows:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pip install psycopg2&lt;/p&gt;

&lt;p&gt;官网建议用easy_install 但这种安装方法在import是会提示缺少DLL&lt;/p&gt;

&lt;h4 id=&#34;第二部分-操作数据库&#34;&gt;第二部分 操作数据库&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import psycopg2
&amp;gt;&amp;gt;&amp;gt; import datetime

# 连接数据库
&amp;gt;&amp;gt;&amp;gt; conn = psycopg2.connect(
    host=&amp;quot;192.168.56.102&amp;quot;,
    port=&amp;quot;15432&amp;quot;,
    password=&#39;passwd&#39;,
    dbname=&amp;quot;exampledb&amp;quot;,
    user=&amp;quot;dbuser&amp;quot;
)
# 创建一个游标去执行数据库操作
&amp;gt;&amp;gt;&amp;gt; cur = conn.cursor()

# 插入一条数据到user_person表
&amp;gt;&amp;gt;&amp;gt; cur.execute(
    &amp;quot;INSERT INTO user_person(name, entry, job) VALUES (%s, %s, %s)&amp;quot;,
    (&amp;quot;jic&amp;quot;, datetime.date(2016, 3, 1), &amp;quot;full-stack develop&amp;quot;)
)

# 执行查询语句
&amp;gt;&amp;gt;&amp;gt; cur.execute(&amp;quot;SELECT * FROM user_person;&amp;quot;)

# 把查询的结果取出来
&amp;gt;&amp;gt;&amp;gt; cur.fetchall()
[(&#39;jia&#39;, datetime.date(2016, 2, 28), &#39;backend develop&#39;), (&#39;jib&#39;, datetime.date(2016, 2, 29), &#39;frontend develop&#39;), (&#39;jic&#39;, datetime.date(2016, 3, 1), &#39;full-stack develop&#39;)]

# 确保所有命令执行完成
&amp;gt;&amp;gt;&amp;gt; conn.commit()

# 关闭游标和数据库连接
&amp;gt;&amp;gt;&amp;gt; cur.close()
&amp;gt;&amp;gt;&amp;gt; conn.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;上面就是一次完整的数据库操作流程,这里有几点需要注意:

&lt;ul&gt;
&lt;li&gt;execute的 VALUES 后面必须使用(%s,&amp;hellip;)的格式&lt;/li&gt;
&lt;li&gt;VALUES后面的占位符支持 (%(name)s,&amp;hellip;) 参数则为{&amp;lsquo;name&amp;rsquo;: value,&amp;hellip;}这种格式,这样可以保证不用在输入重复的参数&lt;/li&gt;
&lt;li&gt;占位符必须是 %s，不能是%d 或%f&lt;/li&gt;
&lt;li&gt;参数的数据结构必须是list或tuple&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python类型和SQL类型对照
&lt;a href=&#34;http://initd.org/psycopg/docs/usage.html#adaptation-of-python-values-to-sql-types&#34;&gt;http://initd.org/psycopg/docs/usage.html#adaptation-of-python-values-to-sql-types&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用docker部署jekyll</title>
      <link>https://bigpigeon.org/post/docker-and-jekyll/</link>
      <pubDate>Sat, 06 Feb 2016 14:06:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/docker-and-jekyll/</guid>
      <description>&lt;p&gt;关于在docker部署jekyll在&lt;a href=&#34;http://books.linuxfocus.net/files/books/James.Turnbull.The.Docker.Book.Containerization.is.the.new.virtualization.B00LRROTI4.pdf&#34;&gt;The.Docker.Book&lt;/a&gt;中也有详细说明，但主要是自从jekyll升级到需要ruby2.0+版本后就没那么容易了&lt;/p&gt;

&lt;p&gt;所以我在这记录一下部署过程以免将来再次踩坑&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;首先-为什么要用docker&#34;&gt;首先，为什么要用docker&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;docker提供了基于操作系统的虚拟化技术，可以让你很方便的把应用的环境独立出来并且可以重用&lt;/p&gt;

&lt;p&gt;并且 docker提供了一套完善的工具去管理docker推出的进程&lt;/p&gt;

&lt;p&gt;所以 docker相当于是supervisor + 容器的组合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;编辑jekyll的dockerfile和nginx的dockerfile&#34;&gt;编辑jekyll的Dockerfile和nginx的Dockerfile&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;jekyll的目录结构&#34;&gt;jekyll的目录结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;|-base
    |-Dockerfile
|-create
    |-Dockerfile
|-push
    |-Dockerfile
    |-Rakefile
    |-key
       |-id_rsa
       |-id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;jekyll-base目录下的dockerfile&#34;&gt;jekyll base目录下的Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM ubuntu:latest
MAINTAINER bigpigeon0 &amp;lt;bigpigeon0@gmail.com&amp;gt;
ENV REFRESHED_AT 2016-02-13

RUN apt-get -yqq update
RUN apt-get -yqq install ruby2.0 ruby2.0-dev ruby-dev make nodejs git

RUN for i in {1..100};\
      do \
        gem2.0 install --source=http://rubygems.org jekyll;\
        if [ &amp;quot;$?&amp;quot; -eq 0 ];\
          then break;\
        fi;\
      done;
RUN gem2.0 install redcarpet
RUN gem2.0 install --source=http://rubygems.org rake
RUN gem2.0 install bundler
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;apt-get 增加了 ruby-dev(ruby某些库需要用到ruby-dev)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gem2.0 使用源是http的rubugems.org(某些下载文件过大使用https会出现connection reset)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;耐性等待jekyll的安装非常非常慢可能需要1个小时，而且没提示(想要提示可以用Bundler(gem install bundler)，但不知道为何bundler经常装到一半失败，并且缓存失败。。。)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;总的来说就是ruby坑爹，gem更坑爹&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rake的作用是把jekyll生成的网页推到github的master分支上，因为github上的jekyll不支持插件，所以只能本地生产完推上去&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;jekyll-create目录下的dockerfile&#34;&gt;jekyll create目录下的Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM bigpigeon0/jekyll:latest
MAINTAINER bigpigeon0 &amp;lt;bigpigeon0@gmail.com&amp;gt;

VOLUME [&amp;quot;/data&amp;quot;, &amp;quot;/var/www/html&amp;quot;]
WORKDIR /data

ENTRYPOINT [ &amp;quot;jekyll&amp;quot;, &amp;quot;build&amp;quot;, &amp;quot;--destination=/var/www/html&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;jekyll-push目录下的dockerfile&#34;&gt;jekyll push目录下的Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM bigpigeon0/jekyll:latest
MAINTAINER bigpigeon0 &amp;lt;bigpigeon0@gmail.com&amp;gt;

RUN mkdir -p /data/rakedata /data/blog
RUN git config --global user.email bigpigeon0@gmail.com
RUN git config --global user.name bigpigeon

ADD Rakefile /data/rakedata/
COPY key/    /root/.ssh/

WORKDIR /data/rakedata

ENTRYPOINT [&amp;quot;rake&amp;quot;, &amp;quot;publish&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;jekyll-push目录下的rakefile&#34;&gt;jekyll push目录下的Rakefile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &amp;quot;rubygems&amp;quot;
require &amp;quot;tmpdir&amp;quot;

require &amp;quot;bundler/setup&amp;quot;
require &amp;quot;jekyll&amp;quot;


# Change your GitHub reponame
GITHUB_REPONAME = &amp;quot;bigpigeon/bigpigeon.github.io&amp;quot;


desc &amp;quot;Generate blog files&amp;quot;
task :generate do
  Jekyll::Site.new(Jekyll.configuration({
    &amp;quot;source&amp;quot;      =&amp;gt; &amp;quot;../blog/.&amp;quot;,
    &amp;quot;destination&amp;quot; =&amp;gt; &amp;quot;_site&amp;quot;
  })).process
end


desc &amp;quot;Generate and publish blog to master&amp;quot;
task :publish =&amp;gt; [:generate] do
  Dir.mktmpdir do |tmp|
    cp_r &amp;quot;_site/.&amp;quot;, tmp

    pwd = Dir.pwd
    Dir.chdir tmp

    system &amp;quot;git init&amp;quot;
    system &amp;quot;git add .&amp;quot;
    message = &amp;quot;Site updated at #{Time.now.utc}&amp;quot;
    system &amp;quot;git commit -m #{message.inspect}&amp;quot;
    system &amp;quot;git remote add origin git@github.com:#{GITHUB_REPONAME}.git&amp;quot;
    system &amp;quot;git push origin master --force&amp;quot;

    Dir.chdir pwd
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;nginx-image的目录结构&#34;&gt;nginx image的目录结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;|-Dockerfile
|-nginx
    |-static.conf
    |-nginx.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;nginx-image的dockerfile&#34;&gt;nginx image的Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM ubuntu:latest
MAINTAINER bigpigeon &amp;lt;bigpigeon0@gmail.com&amp;gt;

ENV REFRESHED_AT 2016-02-06

RUN apt-get -yqq update
RUN apt-get install -yqq nginx
RUN mkdir -p /var/www/html

ADD nginx/nginx.conf /etc/nginx/nginx.conf
ADD nginx/static.conf /etc/nginx/conf.d/static.conf

VOLUME [&amp;quot;/var/www/html&amp;quot;]
WORKDIR /var/www/html

EXPOSE 80

ENTRYPOINT [&amp;quot;nginx&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;nginx-conf&#34;&gt;nginx.conf&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;user www-data;
worker_processes 4;
pid /run/nginx.pid;
daemon off;
events { }
http {
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;
  include /etc/nginx/mime.types;
  default_type application/octet-stream;
  access_log /var/log/nginx/access.log;
  error_log /var/log/nginx/error.log;
  gzip on;
  gzip_disable &amp;quot;msie6&amp;quot;;
  include /etc/nginx/conf.d/*.conf;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;static-conf&#34;&gt;static.conf&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
  listen 0.0.0.0:80;
  server_name _;
  root /var/www/html/;
  index index.html index.htm;
  access_log /var/log/nginx/default_access.log;
  error_log /var/log/nginx/default_error.log;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker的image就build好了，这里简单讲讲Dockerfile的语法&lt;/p&gt;

&lt;p&gt;FROM: Dockerfile的第一行必须是FROM，表示基于那个基础Docker image&lt;/p&gt;

&lt;p&gt;ENV: 设置环境变量&lt;/p&gt;

&lt;p&gt;MAINTAINER: 告诉docker该image的作者和他的邮箱地址，也是很有必要的&lt;/p&gt;

&lt;p&gt;RUN: 用shell执行一条命令，可以写成RUN xxx &amp;hellip; 或者RUN [&amp;ldquo;xxx&amp;rdquo;, &amp;hellip;]&lt;/p&gt;

&lt;p&gt;CMD: 执行一条命令，当image被运行(推出)时，用法和RUN相识&lt;/p&gt;

&lt;p&gt;ENTRYPOINT: 执行一条命令，当image被运行(推出)时，并且可以在运行时对该命令附加参数&lt;/p&gt;

&lt;p&gt;WORKDIR: 设置工作目录，相当于bash下的cd dir&lt;/p&gt;

&lt;p&gt;USER: 设置在docker build下执行命令的用户&lt;/p&gt;

&lt;p&gt;VOLUME: 方便容器之间挂载目录，可以在image被运行时配合&amp;ndash;volumes-from使用&lt;/p&gt;

&lt;p&gt;ADD: 把文件复制到image中，第一参数可填写网址，但不可访问当前目录以外的路径&lt;/p&gt;

&lt;p&gt;COPY: 把文件夹复制到image中&lt;/p&gt;

&lt;p&gt;ONBUILD: 在该image作为FROM基本容器再次build时执行&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;build-nginx和jekyll的image&#34;&gt;build nginx和jekyll的image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# build jekyll base image
cd Dockerfile存放目录
sudo docker build -t bigpigeon0/jekyll .

# build jekyll create image
cd Dockerfile存放目录
sudo docker build -t bigpigeon0/blog_create .

# build jekyll create image
cd Dockerfile存放目录
sudo docker build -t bigpigeon0/blog_push .

# build nginx image
cd Dockerfile存放目录
sudo docker build -t bigpigeon0/nginx .
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;运行docker&#34;&gt;运行Docker&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 把jekyll的模板下载下来
mkdir -p /data/work/ &amp;amp;&amp;amp; cd /data/work/
git clone https://github.com/bigpigeon/bigpigeon.github.io

# 运行一个博客生成的镜像
sudo docker run  -v /data/work/bigpigeon.github.io:/data --name blog_create bigpigeon0/blog_create

# 运行nginx的镜像
sudo docker run -p 8080:80 -d --name nginx --volumes-from blog_create bigpigeon0/nginx

# 生成博客提交到github
# 记得把key/id_rsa.pub中的内容添加到github.com/settings/ssh中
sudo docker run -t -i -v /data/work/bigpigeon.github.io:/data/blog --name blog_push bigpigeon0/blog_push

# 更新模板后重新生成网页和提交网页
docker start blog_create
docker start -a blog_push
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试网站&#34;&gt;测试网站&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;在浏览器输入&lt;a href=&#34;http://serveraddr:8080&#34;&gt;http://serveraddr:8080&lt;/a&gt; 查看博客&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;The.Docker.Book有&lt;a href=&#34;http://www.amazon.cn/%E7%AC%AC%E4%B8%80%E6%9C%ACDocker%E4%B9%A6-%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E7%89%B9%E6%81%A9%E5%B8%83%E5%B0%94/dp/B00RBEIFMI/&#34;&gt;中文版&lt;/a&gt;，然而我觉得价格太坑爹，还是不推荐大家买(电子书比实体书还贵)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gin框架介绍</title>
      <link>https://bigpigeon.org/post/gin-framework/</link>
      <pubDate>Thu, 24 Dec 2015 06:25:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/gin-framework/</guid>
      <description>&lt;h3 id=&#34;为何用gin&#34;&gt;为何用gin&lt;/h3&gt;

&lt;p&gt;它是一个轻量级框架，框架简单而且速度很快，它的功能用来做rust api开发已经足够&lt;/p&gt;

&lt;p&gt;而因为它的简单我们也能很好的在它上面增加功能或再开发&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;gin的特性&#34;&gt;gin的特性&lt;/h3&gt;

&lt;p&gt;支持中间层&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一个请求过来经过 global middleware,group middleware 最后到该path的middleware处理
我们可以把处理函数放入global/middleware/group middleware的中
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于Radix tree&lt;/p&gt;

&lt;p&gt;灾难恢复&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;处理请求崩溃后会在Recover函数中恢复然后返回500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多特性请看&lt;a href=&#34;https://gin-gonic.github.io/gin/&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本用法&#34;&gt;基本用法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;

func pingPath(c *gin.Context) {
	c.String(200, &amp;quot;pong&amp;quot;)
}

func main() {
    r := gin.Default()
	r.GET(&amp;quot;ping&amp;quot;, pingPath)
	r.Run(&amp;quot;:80&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;上面的代码是什么意思呢&#34;&gt;上面的代码是什么意思呢？&lt;/h3&gt;

&lt;h4 id=&#34;先看看gin-default的源码&#34;&gt;先看看gin.Default的源码&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Default() *Engine {
	engine := New()
	engine.Use(Recovery(), Logger())
	return engine
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;New()是用默认参数构造一个engine&lt;/li&gt;
&lt;li&gt;engine.Use(&amp;hellip;)把Recovery() 和Logger()生成的函数增加值全局handler列&lt;/li&gt;
&lt;li&gt;engine.Use要在所有handle的middleware绑定之前使用，否则某些绑定的path会不生效(在group的middleware之后加是可以的)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;然后我们来看看recovery干了什么&#34;&gt;然后我们来看看Recovery干了什么&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.
func Recovery() HandlerFunc {
	return RecoveryWithWriter(DefaultWriter)
}

func RecoveryWithWriter(out io.Writer) HandlerFunc {
	var logger *log.Logger
	if out != nil {
		logger = log.New(out, &amp;quot;&amp;quot;, log.LstdFlags)
	}
	return func(c *Context) {
		defer func() {
			if err := recover(); err != nil {
				if logger != nil {
					stack := stack(3)
					logger.Printf(&amp;quot;Panic recovery -&amp;gt; %s\n%s\n&amp;quot;, err, stack)
				}
				c.AbortWithStatus(500)
			}
		}()
		c.Next()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;关于recover的使用可以看&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34;&gt;http://blog.golang.org/defer-panic-and-recover&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;defer的函数会在函数结束后返回前调用&lt;/li&gt;
&lt;li&gt;c.Next()就是调用下一个handler 就和Nodejs中的http库差不多&lt;/li&gt;
&lt;li&gt;大致流程就是 FuncBody -&amp;gt; c.Next -&amp;gt; defer func (一个灾难恢复就这样简单的实现了)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;再然后来看看logger&#34;&gt;再然后来看看Logger&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Instances a Logger middleware that will write the logs to gin.DefaultWriter
// By default gin.DefaultWriter = os.Stdout
func Logger() HandlerFunc {
	return LoggerWithWriter(DefaultWriter)
}

// Instance a Logger middleware with the specified writter buffer.
// Example: os.Stdout, a file opened in write mode, a socket...
func LoggerWithWriter(out io.Writer) HandlerFunc {
	return func(c *Context) {
		// Start timer
		start := time.Now()
		path := c.Request.URL.Path

		// Process request
		c.Next()

		// Stop timer
		end := time.Now()
		latency := end.Sub(start)

		clientIP := c.ClientIP()
		method := c.Request.Method
		statusCode := c.Writer.Status()
		statusColor := colorForStatus(statusCode)
		methodColor := colorForMethod(method)
		comment := c.Errors.ByType(ErrorTypePrivate).String()

		fmt.Fprintf(out, &amp;quot;[GIN] %v |%s %3d %s| %13v | %s |%s  %s %-7s %s\n%s&amp;quot;,
			end.Format(&amp;quot;2006/01/02 - 15:04:05&amp;quot;),
			statusColor, statusCode, reset,
			latency,
			clientIP,
			methodColor, reset, method,
			path,
			comment,
		)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;大致就是输出请求头的数据和处理请求所花费的时间&lt;/li&gt;
&lt;li&gt;但听说获取系统时间会有阻塞&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;再来看看r-get之后发生了什么&#34;&gt;再来看看r.GET之后发生了什么&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// routergroup file
func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {
	return group.handle(&amp;quot;GET&amp;quot;, relativePath, handlers)
}

func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {
	absolutePath := group.calculateAbsolutePath(relativePath)
	handlers = group.combineHandlers(handlers)
	group.engine.addRoute(httpMethod, absolutePath, handlers)
	return group.returnObj()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;这里的类是RouterGroup但上面gin.Default()返回的却是是Engine&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;于是我们看看engine的定义&#34;&gt;于是我们看看Engine的定义&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Engine is the framework&#39;s instance, it contains the muxer, middleware and configuration settings.
// Create an instance of Engine, by using New() or Default()
Engine struct {
	RouterGroup
	HTMLRender  render.HTMLRender
	allNoRoute  HandlersChain
	allNoMethod HandlersChain
	noRoute     HandlersChain
	noMethod    HandlersChain
	pool        sync.Pool
	trees       methodTrees
	//忽略一些太长的数据
	...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Engine 是继承于RouteGroup的&lt;/li&gt;
&lt;li&gt;其实可以把Engine当成是RouteGroup节点，Group是可以嵌套的&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;最后看一下handler函数的context参数&#34;&gt;最后看一下handler函数的Context参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Context is the most important part of gin. It allows us to pass variables between middleware,
// manage the flow, validate the JSON of a request and render a JSON response for example.
type Context struct {
	writermem responseWriter
	Request   *http.Request
	Writer    ResponseWriter

	Params   Params
	handlers HandlersChain
	index    int8

	engine   *Engine
	Keys     map[string]interface{}
	Errors   errorMsgs
	Accepted []string
}

// Next should be used only inside middleware.
// It executes the pending handlers in the chain inside the calling handler.
// See example in github.
func (c *Context) Next() {
	c.index++
	s := int8(len(c.handlers))
	for ; c.index &amp;lt; s; c.index++ {
		c.handlers[c.index](c)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这里只展示了Context的定义和Next函数的实现,&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/context.go&#34;&gt;详细看源码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gin的运作原理大概就是这样了,之后讲gin的一些example和&lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;gin的github page&lt;/a&gt;上的一样&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;包含参数的路径&#34;&gt;包含参数的路径&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;
import &amp;quot;net/http&amp;quot;

func main() {
	r := gin.Default()
	// 这种写法只会匹配/user/pigeon ,/user/ 和/user就不会被匹配
	r.GET(&amp;quot;/user/:name&amp;quot;, func(c *gin.Context) {
		name := c.Param(&amp;quot;name&amp;quot;)
		c.String(http.StatusOK, &amp;quot;Hello %s&amp;quot;, name)
	})
	//这种写法会匹配 /user/pigeon/ 和/user/pigeon/enter 或 /user/pigeon/to/doing/something
	r.GET(&amp;quot;/user/:name/*action&amp;quot;, func(c *gin.Context) {
		name := c.Param(&amp;quot;name&amp;quot;)
		action := c.Param(&amp;quot;action&amp;quot;)
		message := name + &amp;quot; is &amp;quot; + action
		c.String(http.StatusOK, message)
	})
	r.Run(&amp;quot;:80&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;query字符串参数&#34;&gt;Query字符串参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;

func main() {
    router := gin.Default()
	// 注:Query函数获取的值都必定是字符串
    router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) {
        firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;)
        lastname := c.Query(&amp;quot;lastname&amp;quot;) // shortcut for c.Request.URL.Query().Get(&amp;quot;lastname&amp;quot;)

        c.String(http.StatusOK, &amp;quot;Hello %s %s&amp;quot;, firstname, lastname)
    })
    router.Run(&amp;quot;:80&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;请尝试用如下请求路径来请求:  /welcome?firstname=Jane&amp;amp;lastname=Doe&lt;/li&gt;
&lt;li&gt;然后查看请求结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;model-binding-and-validation&#34;&gt;Model binding and validation&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;
import &amp;quot;net/http&amp;quot;

// Binding from JSON
type Login struct {
    User     string `form:&amp;quot;user&amp;quot; json:&amp;quot;user&amp;quot; binding:&amp;quot;required&amp;quot;`
    Password string `form:&amp;quot;password&amp;quot; json:&amp;quot;password&amp;quot; binding:&amp;quot;required&amp;quot;`
}

func main() {
    router := gin.Default()

    // 该例子将绑定一个拥有 user 和 password 键的JSON数据
    router.POST(&amp;quot;/loginJSON&amp;quot;, func(c *gin.Context) {
        var json Login
        if c.BindJSON(&amp;amp;json) == nil {
            if json.User == &amp;quot;manu&amp;quot; &amp;amp;&amp;amp; json.Password == &amp;quot;123&amp;quot; {
                c.JSON(http.StatusOK, gin.H{&amp;quot;status&amp;quot;: &amp;quot;you are logged in&amp;quot;})
            } else {
                c.JSON(http.StatusUnauthorized, gin.H{&amp;quot;status&amp;quot;: &amp;quot;unauthorized&amp;quot;})
            }
        }
    })

    // Example for binding a HTML form (user=manu&amp;amp;password=123)
    router.POST(&amp;quot;/loginForm&amp;quot;, func(c *gin.Context) {
        var form Login
        // 用http头中Content-Type 的值去判定数据类型
        if c.Bind(&amp;amp;form) == nil {
            if form.User == &amp;quot;manu&amp;quot; &amp;amp;&amp;amp; form.Password == &amp;quot;123&amp;quot; {
                c.JSON(http.StatusOK, gin.H{&amp;quot;status&amp;quot;: &amp;quot;you are logged in&amp;quot;})
            } else {
                c.JSON(http.StatusUnauthorized, gin.H{&amp;quot;status&amp;quot;: &amp;quot;unauthorized&amp;quot;})
            }
        }
    })

    router.Run(&amp;quot;:80&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;在中间层中使用goroute&#34;&gt;在中间层中使用goroute&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;
import &amp;quot;time&amp;quot;
import &amp;quot;log&amp;quot;

func main() {
    r := gin.Default()

    r.GET(&amp;quot;/long_async&amp;quot;, func(c *gin.Context) {
        // create copy to be used inside the goroutine
        c_cp := c.Copy()
        go func() {
            // simulate a long task with time.Sleep(). 5 seconds
            time.Sleep(5 * time.Second)

            // note than you are using the copied context &amp;quot;c_cp&amp;quot;, IMPORTANT
            log.Println(&amp;quot;Done! in path &amp;quot; + c_cp.Request.URL.Path)
        }()
    })


    r.GET(&amp;quot;/long_sync&amp;quot;, func(c *gin.Context) {
        // simulate a long task with time.Sleep(). 5 seconds
        time.Sleep(5 * time.Second)

        // since we are NOT using a goroutine, we do not have to copy the context
        log.Println(&amp;quot;Done! in path &amp;quot; + c.Request.URL.Path)
    })

    r.Run(&amp;quot;:80&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;goroute 中请使用只读的Context,用Context.Copy可以返回一个只读的Context&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;更多gin的信息可看这&lt;a href=&#34;https://gin-gonic.github.io/gin/&#34;&gt;https://gin-gonic.github.io/gin/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>pac脚本优化</title>
      <link>https://bigpigeon.org/post/switchy-proxy-pac-optimization/</link>
      <pubDate>Sat, 19 Dec 2015 22:00:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/switchy-proxy-pac-optimization/</guid>
      <description>&lt;p&gt;最近发现lantern和shadowsocks client自生成pac都一定的性能问题，在url数目上升到一定程度的时候加载速度明显慢了很多.&lt;/p&gt;

&lt;p&gt;于是我翻看了它们的实现&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lantern

&lt;ul&gt;
&lt;li&gt;把所有需要代理的domain组合成一个RegExp，然后在FindProxyForURL时对host做RegExp.exec的操作来判断是否需要代理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;shadowsocks

&lt;ul&gt;
&lt;li&gt;把domain做成一个{domain:1,&amp;hellip;}的字典，然后在FindProxyForURL时对host做domains.hasOwnProperty判断是否在字典内，若不在，则去掉最前面的&amp;rsquo;.&amp;lsquo;和之前的内容 继续做domains.hasOwnProperty判断&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看出lantern的pac会严重影响网页的加载速度，shadowsocks的稍微好点，但在遇到不需要代理的网页时则会消耗更多无谓的判断

于是我自己实现一个pac优化FindProxyForURL匹配速度&lt;/p&gt;

&lt;p&gt;我的思路是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;把所有需要代理的url以 &amp;lsquo;.&amp;rsquo; 分割成节点&lt;/li&gt;
&lt;li&gt;然后存入一个dict 格式如下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;com&amp;quot;: {
    &amp;quot;google&amp;quot;: true,
    &amp;quot;blogspot&amp;quot;: {
      &amp;quot;www&amp;quot;: true  
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在FindProxyForURL中把host也split成list与这个dict match一下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var domains = [
    &amp;quot;google.com&amp;quot;,
    &amp;quot;www.blogspot.com&amp;quot;,
    ...
];
var domain_dict = {};
for(var i = 0; i &amp;lt; domains.length; i++){
    if(domains[i].endsWith(&amp;quot;.&amp;quot;)){
        domains[i] = domains[i].slice(0, -1)
    }
    var url_list = domains[i].split(&#39;.&#39;);

    var domain_node = domain_dict;
    for(var j = url_list.length; j &amp;gt; 0; j--){
        var node_name = url_list[j-1];
        if (!domain_node.hasOwnProperty(node_name)){
            if (j === 1){
                domain_node[node_name] = true;
                break;
            } else {
                domain_node[node_name] = {};
            }
        } else if(domain_node[node_name] === true) {
            break;
        }
        domain_node = domain_node[node_name];
    }
}

var proxy = &amp;quot;SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT&amp;quot;;

var direct = &#39;DIRECT;&#39;;

function FindProxyForURL(url, host) {
    if( host == &amp;quot;localhost&amp;quot; ||
        host == &amp;quot;127.0.0.1&amp;quot;) {
        return direct;
    }
    var host_list = host.split(&#39;.&#39;)
    var domain_node = domain_dict
    for(var i = host_list.length; i &amp;gt; 0; i--){
        var node_name = host_list[i-1]
        if (domain_node.hasOwnProperty(node_name)){
            if(domain_node[node_name] === true){
                return proxy;
            } else {
                domain_node = domain_node[node_name]
            }

        }
        else {
            return direct;
        }
    }
    return direct;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;以下是我在nodejs下的性能测试结果 &lt;a href=&#34;https://bigpigeon.org/static/testdata/pac_benchmark.zip&#34;&gt;测试js下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
&lt;canvas id=&#34;bench-chart-10k&#34; width=&#34;860&#34; height=&#34;500&#34;&gt;&lt;/canvas&gt;
&lt;canvas id=&#34;bench-chart-100k&#34; width=&#34;860&#34; height=&#34;500&#34;&gt;&lt;/canvas&gt;
&lt;canvas id=&#34;bench-chart-1m&#34; width=&#34;860&#34; height=&#34;500&#34;&gt;&lt;/canvas&gt;
&lt;script src=&#34;../../js/Chart.min.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;
var benck10kData = {
  shadowsocks: [3, 2, 6, 3, 5, 4],
  lantern: [4, 32, 2, 39, 18, 47],
  owner: [3, 3, 11, 3, 3, 3]
};
var benck100kData = {
  shadowsocks: [24, 22, 37, 37, 47, 51],
  lantern: [29, 279, 27, 373, 163, 441],
  owner: [27, 23, 29, 24, 29, 24]
};
var benck1mData = {
  shadowsocks: [136, 130, 287, 309, 401, 460],
  lantern: [222, 2776, 258, 3698, 1631, 4420],
  owner: [224, 220, 285, 218, 287, 220]
};

function renderChart(ctx, data) {
  var chart_obj = new Chart(ctx, {
    type: &#39;bar&#39;,
    data: {
      labels: [&#39;proxy_2_node&#39;, &#39;noproxy_2_node&#39;, &#39;proxy_3_node&#39;, &#39;noproxy_3_node&#39;, &#39;proxy_4_node&#39;, &#39;noproxy_4_node&#39;],
      datasets: [
        {
          type: &#39;bar&#39;,
          label: &#39;shadowsocks&#39;,
          data: data.shadowsocks,
          backgroundColor: &#34;#1C9b47&#34;,
        },
        {
          type: &#39;bar&#39;,
          label: &#39;lantern&#39;,
          data: data.lantern,
          backgroundColor: &#34;#00BCD4&#34;,
        },
        {
          type: &#39;bar&#39;,
          label: &#39;owner&#39;,
          data: data.owner,
          backgroundColor: &#34;#FF4088&#34;,
        }
      ]
    },
    options: {
        title: {
            display: true,
            text: ctx.id
        }
    }
  });
  return chart_obj;
}

renderChart(document.getElementById(&#34;bench-chart-10k&#34;), benck10kData);
renderChart(document.getElementById(&#34;bench-chart-100k&#34;), benck100kData);
renderChart(document.getElementById(&#34;bench-chart-1m&#34;), benck1mData);



&lt;/script&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>jekyll部署总结</title>
      <link>https://bigpigeon.org/post/jekyll-deploy/</link>
      <pubDate>Wed, 09 Dec 2015 16:00:00 +0800</pubDate>
      
      <guid>https://bigpigeon.org/post/jekyll-deploy/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;在网络并不好的情况下用gem install jeskll 代替 bundle install ，bundle install 总会出现 各种connection reset的情况&lt;/li&gt;
&lt;li&gt;把博客上传github的时候主要不要把_site里的内容上传上去，不然会你的邮箱会收到一个Page build failure的邮件&lt;/li&gt;
&lt;li&gt;这个博客的模板我是fork &lt;a href=&#34;https://github.com/Gaohaoyang&#34;&gt;浩阳 Gaohaoyang&lt;/a&gt; 的 &lt;a href=&#34;https://github.com/Gaohaoyang/gaohaoyang.github.io&#34;&gt;博客模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;其实我还是希望设计一个有特色点的博客，但毕竟我前端技能很烂，只能先用别人的了.
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
