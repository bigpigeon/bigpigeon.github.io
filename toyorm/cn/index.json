[
{
	"uri": "https://bigpigeon.org/toyorm/cn/2_engine/toy_toolkit/",
	"title": "toy工具",
	"tags": [],
	"description": "",
	"content": " SetDebug 设置默认的Debug模式\ntoy.SetDebug(true) // 设置默认debug模式 \tbrick := toy.Model(\u0026amp;User{}) // 现在这个ToyBrick对象的debug为true \t"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/1_getting_started/",
	"title": "开始",
	"tags": [],
	"description": "",
	"content": " 安装 go get github.com/bigpigeon/toyorm  一个简单例子 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/bigpigeon/toyorm\u0026#34; \u0026#34;reflect\u0026#34; . \u0026#34;unsafe\u0026#34; // when database is mysql \t//_ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; \t// when database is sqlite3 \t_ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; // when database is postgres \t//_ \u0026#34;github.com/lib/pq\u0026#34; ) /* ---------------------- 定义数据结构 ------------------------- */ func JsonEncode(v interface{}) string { jsonData, err := json.MarshalIndent(v, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { panic(err) } return string(jsonData) } type Product struct { toyorm.ModelDefault Name string `toyorm:\u0026#34;index\u0026#34;` Price float64 `toyorm:\u0026#34;index\u0026#34;` Count int Tag string `toyorm:\u0026#34;index\u0026#34;` } // 用于GroupBy操作 type ProductGroup struct { Tag string KindCount int `toyorm:\u0026#34;column:COUNT(*)\u0026#34;` } // 实现 toyorm.tabler接口用以自定义表名 func (p ProductGroup) TableName() string { return toyorm.ModelName(reflect.TypeOf(Product{})) } func main() { var err error var toy *toyorm.Toy var result *toyorm.Result // when database is mysql, make sure your mysql have toyorm_example schema \t//toy, err = toyorm.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:@tcp(localhost:3306)/toyorm_example?charset=utf8\u0026amp;parseTime=True\u0026#34;) \t// when database is sqlite3 \ttoy, err = toyorm.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;toyorm_test.db\u0026#34;) // when database is postgres \t//toy, err = toyorm.Open(\u0026#34;postgres\u0026#34;, \u0026#34;user=postgres dbname=toyorm sslmode=disable\u0026#34;)  // brick is basic \u0026#34;sql builder\u0026#34; \tbrick := toy.Model(\u0026amp;Product{}).Debug() // 使用删表操作来清楚旧数据 \tresult, err = brick.DropTableIfExist() if err != nil { panic(err) } // print sql error if exist \tif resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } // create table \tresult, err = brick.CreateTableIfNotExist() if err != nil { panic(err) } // print sql error if exist \tif resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } // Insert will set id to source data when primary key is auto_increment \tresult, err = brick.Insert(\u0026amp;[]Product{ {Name: \u0026#34;food one\u0026#34;, Price: 1, Count: 4, Tag: \u0026#34;food\u0026#34;}, {Name: \u0026#34;food two\u0026#34;, Price: 2, Count: 3, Tag: \u0026#34;food\u0026#34;}, {Name: \u0026#34;food three\u0026#34;, Price: 3, Count: 2, Tag: \u0026#34;food\u0026#34;}, {Name: \u0026#34;food four\u0026#34;, Price: 4, Count: 1, Tag: \u0026#34;food\u0026#34;}, {Name: \u0026#34;toolkit one\u0026#34;, Price: 1, Count: 8, Tag: \u0026#34;toolkit\u0026#34;}, {Name: \u0026#34;toolkit two\u0026#34;, Price: 2, Count: 6, Tag: \u0026#34;toolkit\u0026#34;}, {Name: \u0026#34;toolkit one\u0026#34;, Price: 3, Count: 4, Tag: \u0026#34;toolkit\u0026#34;}, {Name: \u0026#34;toolkit two\u0026#34;, Price: 4, Count: 2, Tag: \u0026#34;toolkit\u0026#34;}, }) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } // find one with the tag=food condition \t{ var product Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Tag), \u0026#34;food\u0026#34;).Find(\u0026amp;product) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;food %s\\n\u0026#34;, JsonEncode(product)) } // find all tag=food \t{ var products []Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Tag), \u0026#34;food\u0026#34;).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;foods %s\\n\u0026#34;, JsonEncode(products)) } // find count = 2 \t{ var products []Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;count \u0026gt; 2 products %s\\n\u0026#34;, JsonEncode(products)) } // find count = 2 and price \u0026gt; 3 \t{ var products []Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).And(). Condition(toyorm.ExprGreater, Offsetof(Product{}.Price), 3).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;count = 2 and price \u0026gt; 3 products %s\\n\u0026#34;, JsonEncode(products)) } // find count = 2 and price \u0026gt; 3 or count = 4 \t{ var products []Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).And(). Condition(toyorm.ExprGreater, Offsetof(Product{}.Price), 3).Or(). Condition(toyorm.ExprEqual, Offsetof(Product{}.Count), 4).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;count = 2 and price \u0026gt; 3 or count = 4 products %s\\n\u0026#34;, JsonEncode(products)) } // find price \u0026gt; 3 and (count = 2 or count = 1) \t{ var products []Product result, err := brick.Where(toyorm.ExprGreater, Offsetof(Product{}.Price), 3).And().Conditions( brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).Or(). Condition(toyorm.ExprEqual, Offsetof(Product{}.Count), 1).Search, ).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;price \u0026gt; 3 and (count = 2 or count = 1) products %s\\n\u0026#34;, JsonEncode(products)) } // find (count = 2 or count = 1) and (price = 3 or price = 4) \t{ var products []Product result, err := brick.Conditions( brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).Or(). Condition(toyorm.ExprEqual, Offsetof(Product{}.Count), 1).Search, ).And().Conditions( brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Price), 3).Or(). Condition(toyorm.ExprEqual, Offsetof(Product{}.Price), 4).Search, ).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;(count = 2 or count = 1) and (price = 3 or price = 4) products %s\\n\u0026#34;, JsonEncode(products)) } // find offset 2 limit 2 \t{ var products []Product result, err := brick.Offset(2).Limit(2).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;offset 1 limit 2 products %s\\n\u0026#34;, JsonEncode(products)) } // order by \t{ var products []Product result, err := brick.OrderBy(Offsetof(Product{}.Name)).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;order by name products %s\\n\u0026#34;, JsonEncode(products)) } { var products []Product result, err := brick.OrderBy(brick.ToDesc(Offsetof(Product{}.Name))).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;order by name desc products %s\\n\u0026#34;, JsonEncode(products)) } // update to count = 4 \t{ result, err := brick.Update(\u0026amp;Product{ Count: 4, }) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } var Counters []struct { Name string Count int } result, err = brick.Find(\u0026amp;Counters) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } for _, counter := range Counters { fmt.Printf(\u0026#34;product name %s, count %d\\n\u0026#34;, counter.Name, counter.Count) } } // use bind fields to update a zero value \t{ { var p Product result, err := brick.BindDefaultFields(Offsetof(p.Price), Offsetof(p.UpdatedAt)).Update(\u0026amp;Product{ Price: 0, }) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } } var products []Product result, err = brick.Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } for _, p := range products { fmt.Printf(\u0026#34;product name %s, price %v\\n\u0026#34;, p.Name, p.Price) } } // delete with element \t{ // make a transaction, because I do not really delete a data \tbrick := brick.Begin() var product Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Name), \u0026#34;food four\u0026#34;).Find(\u0026amp;product) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } result, err = brick.Delete(\u0026amp;product) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } var disappearProduct Product result, err = brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Name), \u0026#34;food four\u0026#34;).Find(\u0026amp;disappearProduct) if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;error(%s)\\n\u0026#34;, err) brick.Rollback() } // delete with condition \t{ // make a transaction, because I am not really delete a data \tbrick := brick.Begin() result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Name), \u0026#34;food four\u0026#34;).DeleteWithConditions() if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } var product Product _, err = brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Name), \u0026#34;food four\u0026#34;).Find(\u0026amp;product) fmt.Printf(\u0026#34;error(%s)\\n\u0026#34;, err) brick.Rollback() } // group by \t{ var tab ProductGroup brick := toy.Model(\u0026amp;tab).Debug().GroupBy(Offsetof(tab.Tag)) var groups []ProductGroup result, err := brick.Find(\u0026amp;groups) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } for _, g := range groups { fmt.Printf(\u0026#34;group %#v\\n\u0026#34;, g) } } // custom insert \t{ data := Product{ Name: \u0026#34;bag\u0026#34;, Price: 9999, Count: 2, Tag: \u0026#34;container\u0026#34;, } result, err := brick.Template(\u0026#34;INSERT INTO $ModelName($Columns) Values($Values)\u0026#34;).Insert(\u0026amp;data) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } } // custom find \t{ var data Product // if driver is mysql use \u0026#34;USE INDEX\u0026#34; replace \u0026#34;INDEXED BY\u0026#34; \tresult, err := brick.Template(\u0026#34;SELECT $Columns FROM $ModelName INDEXED BY idx_product_name $Conditions\u0026#34;). Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Find(\u0026amp;data) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;find where name = bag %v\\n\u0026#34;, data) } // custom update \t{ fmt.Printf(\u0026#34;the template source %s\\n\u0026#34;, fmt.Sprintf(\u0026#34;UPDATE $ModelName SET $Values,$FN-Count = $0x%x + ? $Conditions\u0026#34;, Offsetof(Product{}.Count))) result, err := brick.Template(fmt.Sprintf(\u0026#34;UPDATE $ModelName SET $Values,$FN-Count = $0x%x + ? $Conditions\u0026#34;, Offsetof(Product{}.Count)), 2). Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Update(\u0026amp;Product{Price: 200}) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } var data Product result, err = brick.Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Find(\u0026amp;data) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;now bag product count is %d\\n\u0026#34;, data.Count) } }"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/2_engine/",
	"title": "引擎",
	"tags": [],
	"description": "如何创建一个Toy对象",
	"content": "toyorm 需要使用 \u0026ldquo;database/sql\u0026rdquo; 库去操作数据库\n它为SQL(或者 类SQL)数据库提供了一个通用的接口\n所以这个库必须和以下库一并使用database driver\n而toyorm 只支持以下几种 database driver, 让我们看看如何使用它\nimport driver // if database is mysql _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; // if database is sqlite3 _ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; // when database is postgres _ \u0026#34;github.com/lib/pq\u0026#34;  创建Toy对象 // if database is mysql, make sure your mysql have toyorm_example schema toy, err = toyorm.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:@tcp(localhost:3306)/toyorm_example?charset=utf8\u0026amp;parseTime=True\u0026#34;) // if database is sqlite3 toy,err = toyorm.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;toyorm_test.db\u0026#34;) // when database is postgres toy, err = toyorm.Open(\u0026#34;postgres\u0026#34;, \u0026#34;user=postgres dbname=toyorm sslmode=disable\u0026#34;)  "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/3_data_definition/type_translation/",
	"title": "类型转换",
	"tags": [],
	"description": "how to connection database",
	"content": "如果sql类型为空，toyorm在操作操作数据库时会忽略它\n你可以使用 \u0026lt;type:sql_type\u0026gt; tag去声明字段的 sql 类型\n下面这些go类型会自动声明它的sql类型\n   Go Type sql type     bool BOOLEAN   int8,int16,int32,uint8,uint16,uint32 INTEGER   int64,uint64,int,uint BIGINT   float32,float64 FLOAT   string VARCHAR(255)   time.Time TIMESTAMP   []byte VARCHAR(255)   sql.NullBool BOOLEAN   sql.NullInt64 BIGINT   sql.NullFloat64 FLOAT   sql.NullString VARCHAR(255)   sql.RawBytes VARCHAR(255)    "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/3_data_definition/tag/",
	"title": "Tag声明",
	"tags": [],
	"description": "tag declaration2",
	"content": "声明格式可以是 \u0026lt;key:value\u0026gt; 或 \u0026lt;key\u0026gt;\ntype User struct { toyorm.ModelDefault Name uint `toyorm:\u0026#34;index\u0026#34;` // 只有key的声明  FullName string `toyorm:\u0026#34;column:fullname\u0026#34;` // 键值声明 }  下面这些是特殊tag声明     键 值 说明     index void or string 为字段增加索引,如果你想声明一个组合索引，只要在字段之间使用相同的索引名即可   unique index void or string 唯一索引声明, 用法同上   primary key void 主键声明,允许但不建议多主键，因为一些操作可能不支持   - void 在sql操作中忽略该字段   type string 声明sql字段类型   column string 声明sql字段名   auto_increment void 如果你的主键有 auto_increment 属性，请添加它   autoincrement void 和auto_increment一样   foreign key void 外键声明，不推荐使用   alias string 声明字段名   join string 用于选择Join容器的关联字段   belong to string 用于选择BelongTo预加载的关联字段   one to one string 用于选择OneToOne预加载的关联字段   one to many string 用于选择OneToMany预加载的关联字段    额外的tag声明会在创建表时附加到字段末尾\ntype User struct { toyorm.ModelDefault Born time.Time `toyorm:\u0026#34;NULL\u0026#34;` } // when call CreateTable the born field have \u0026#34;null\u0026#34; attribute at the end // CREATE TABLE `user` (... , born TIMESTAMP null, ...)"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/3_data_definition/",
	"title": "数据定义",
	"tags": [],
	"description": "data definition",
	"content": "toyorm 使用struct类型来声明表信息\n继承 toyorm.ModelDefault 结构体会为表自动增加 ID,CreatedAt,UpdatedAt,DeletedAt 字段\nlike this\ntype Blog struct { toyorm.ModelDefault UserID uint `toyorm:\u0026#34;index\u0026#34;` Title string `toyorm:\u0026#34;index\u0026#34;` Content string } 如果你想在sql中使用自定义字段, 在字段类型中实现sql.Scan and sql.Value 接口，然后在tag中声明它的sql类型\n// e.g create custom field type Extra map[string]interface{} // implement sql.Scaner interface{} func (e Extra) Scan(value interface{}) error { switch v := value.(type) { case string: return json.Unmarshal([]byte(v), e) case []byte: return json.Unmarshal(v, e) default: return errors.New(\u0026#34;not support type\u0026#34;) } } // implement sql.Valuer interface{} func (e Extra) Value() (driver.Value, error) { return json.Marshal(e) } type UserDetail struct { ID int `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` UserID uint `toyorm:\u0026#34;index\u0026#34;` MainPage string Extra Extra `toyorm:\u0026#34;type:VARCHAR(1024)\u0026#34;`// field with map type was not match in sql, need declaration its type } 定义用于group by 操作的struct\n// use by group by type ProductGroup struct { Tag string KindCount int `toyorm:\u0026#34;column:COUNT(*)\u0026#34;` } // implement toyorm.tabler for custom table name func (p ProductGroup) TableName() string { return toyorm.ModelName(reflect.TypeOf(Product{})) } 定义struct和它的预加载数据\ntype User struct { toyorm.ModelDefault Name string `toyorm:\u0026#34;unique index\u0026#34;` Age int Sex string Detail *UserDetail // UserDetail type has UserId field ,it match OneToOne auto-preload condition  Friends []*User // Friends is slice object,and it element type have UserId field, it match OneToMany auto-preload condition  Blog []Blog // same as Detail field, toyorm will preload it\u0026#39;s data when call ToyBrick.Preload }"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/",
	"title": "ToyBrick",
	"tags": [],
	"description": "ToyBrick usage",
	"content": " ToyBrick 是数据库操作的入口, 使用Toy.Model()创建它\n如果你不知道如何创建 Toy 对象, 请看 [engine] 章节\nInit 使用 Toy.Model 去创建 ToyBrick, 它的第一个参数必须是struct类型或者它的指针类型\ninit // User declaration in database connection section brick := toy.Model(\u0026amp;User{}) // or brick := toy.Model(User{})  构建Sql 所有构建方法都会返回一个新的 *ToyBrick 对象 , 它不会改变当前对象的任意数据\n构建where条件 brick = brick.Where(toyorm.ExprEqual, Offsetof(User{}.Sex), \u0026#34;male\u0026#34;) or use string brick = brick.Where(\u0026#34;=\u0026#34;, Offsetof(User{}.Sex), \u0026#34;male\u0026#34;) // WHERE tag = \u0026#34;male\u0026#34;  事务 // start a transaction brick = brick.Begin() // do sth result, err := brick.Insert(user) ... // if have error rollback else commit if err != nil { err := brick.Rollback() if err != nil { panic(err) } }else { brick.Commit() }  数据操作 创建表 _, err = toy.Model(\u0026amp;User{}).Debug().CreateTable() // CREATE TABLE user (id BIGINT AUTO_INCREMENT,created_at TIMESTAMP NULL,updated_at TIMESTAMP NULL,deleted_at TIMESTAMP NULL,name VARCHAR(255),age BIGINT ,sex VARCHAR(255) , PRIMARY KEY(id)) // CREATE INDEX idx_user_deletedat ON user(deleted_at) // CREATE UNIQUE INDEX udx_user_name ON user(name)  删除表 var err error _, err =toy.Model(\u0026amp;User{}).Debug().DropTable() // DROP TABLE user  插入数据 user := \u0026amp;User{ Name: \u0026#34;bigpigeon\u0026#34;, Age: 18, Sex: \u0026#34;male\u0026#34;, } _, err = toy.Model(\u0026amp;User{}).Debug().Insert(\u0026amp;user) // INSERT INTO user(created_at,updated_at,name,age,sex) VALUES(?,?,?,?,?) , args:[]interface {}{time.Time{wall:0xbe8df5112e7f07c8, ext:210013499, loc:(*time.Location)(0x141af80)}, time.Time{wall:0xbe8df5112e7f1768, ext:210017044, loc:(*time.Location)(0x141af80)}, \u0026#34;bigpigeon\u0026#34;, 18, \u0026#34;male\u0026#34;} // print user format with json /* { \u0026#34;ID\u0026#34;: 1, \u0026#34;CreatedAt\u0026#34;: \u0026#34;2018-01-11T20:47:00.780077+08:00\u0026#34;, \u0026#34;UpdatedAt\u0026#34;: \u0026#34;2018-01-11T20:47:00.780081+08:00\u0026#34;, \u0026#34;DeletedAt\u0026#34;: null, \u0026#34;Name\u0026#34;: \u0026#34;bigpigeon\u0026#34;, \u0026#34;Age\u0026#34;: 18, \u0026#34;Sex\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;Detail\u0026#34;: null, \u0026#34;Friends\u0026#34;: null, \u0026#34;Blog\u0026#34;: null }*/  如果主键记录已经存在，保存操作可能会覆盖原有数据\n保存数据 users := []User{ { ModelDefault: toyorm.ModelDefault{ID: 1}, Name: \u0026#34;bigpigeon\u0026#34;, Age: 18, Sex: \u0026#34;male\u0026#34;, }, { Name: \u0026#34;fatpigeon\u0026#34;, Age: 27, Sex: \u0026#34;male\u0026#34;, }, } _, err = toy.Model(\u0026amp;User{}).Debug().Save(\u0026amp;user) // SELECT id,created_at FROM user WHERE id IN (?), args:[]interface {}{0x1} // REPLACE INTO user(id,created_at,updated_at,name,age,sex) VALUES(?,?,?,?,?,?) , args:[]interface {}{0x1, time.Time{wall:0x0, ext:63651278036, loc:(*time.Location)(nil)}, time.Time{wall:0xbe8dfb5511465918, ext:302600558, loc:(*time.Location)(0x141af80)}, \u0026#34;bigpigeon\u0026#34;, 18, \u0026#34;male\u0026#34;} // INSERT INTO user(created_at,updated_at,name,age,sex) VALUES(?,?,?,?,?) , args:[]interface {}{time.Time{wall:0xbe8dfb551131b7d8, ext:301251230, loc:(*time.Location)(0x141af80)}, time.Time{wall:0xbe8dfb5511465918, ext:302600558, loc:(*time.Location)(0x141af80)}, \u0026#34;fatpigeon\u0026#34;, 27, \u0026#34;male\u0026#34;}  更新 toy.Model(\u0026amp;User{}).Debug().Update(\u0026amp;User{ Age: 4, }) // UPDATE user SET updated_at=?,age=? WHERE deleted_at IS NULL, args:[]interface {}{time.Time{wall:0xbe8df4eb81b6c050, ext:233425327, loc:(*time.Location)(0x141af80)}, 4}  查询一条记录 var user User _, err = toy.Model(\u0026amp;User{}).Debug().Find(\u0026amp;user} // SELECT id,created_at,updated_at,deleted_at,name,age,sex FROM user WHERE deleted_at IS NULL LIMIT 1, args:[]interface {}(nil) // print user format with json /* { \u0026#34;ID\u0026#34;: 1, \u0026#34;CreatedAt\u0026#34;: \u0026#34;2018-01-11T12:47:01Z\u0026#34;, \u0026#34;UpdatedAt\u0026#34;: \u0026#34;2018-01-11T12:47:01Z\u0026#34;, \u0026#34;DeletedAt\u0026#34;: null, \u0026#34;Name\u0026#34;: \u0026#34;bigpigeon\u0026#34;, \u0026#34;Age\u0026#34;: 4, \u0026#34;Sex\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;Detail\u0026#34;: null, \u0026#34;Friends\u0026#34;: null, \u0026#34;Blog\u0026#34;: null }*/  查询多条记录 var users []User _, err = brick.Debug().Find(\u0026amp;users) fmt.Printf(\u0026#34;find users %s\\n\u0026#34;, JsonEncode(\u0026amp;users)) // SELECT id,created_at,updated_at,deleted_at,name,age,sex FROM user WHERE deleted_at IS NULL, args:[]interface {}(nil)  根据主键删除 _, err = brick.Debug().Delete(\u0026amp;user) // UPDATE user SET deleted_at=? WHERE id IN (?), args:[]interface {}{(*time.Time)(0xc4200f0520), 0x1}  根据条件删除 _, err = brick.Debug().Where(toyorm.ExprEqual, Offsetof(User{}.Name), \u0026#34;bigpigeon\u0026#34;).DeleteWithConditions() // UPDATE user SET deleted_at=? WHERE name = ?, args:[]interface {}{(*time.Time)(0xc4200dbfa0), \u0026#34;bigpigeon\u0026#34;}  "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/toy_doctor/",
	"title": "toy-doctor",
	"tags": [],
	"description": "",
	"content": " 一个参数检查工具\nExample main.go中的代码\npackage main import ( \u0026#34;github.com/bigpigeon/toyorm\u0026#34; . \u0026#34;unsafe\u0026#34; ) type Detail struct { ID uint32 `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` ProductID uint32 `toyorm:\u0026#34;index\u0026#34;` Name string } type Product struct { toyorm.ModelDefault Name string `toyorm:\u0026#34;index\u0026#34;` Detail *Detail } func main() { toy, err := toyorm.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;\u0026#34;) if err != nil { panic(err) } brick := toy.Model(\u0026amp;Product{}) // to preload detail \tbrick = brick.OrderBy(Offsetof(Product{}.CreatedAt)).Preload(Offsetof(Product{}.Detail)).Enter() var tab []Product result, err := brick.Find(\u0026amp;tab) if err != nil { panic(err) } if err := result.Err();err != nil { // sql error record it \t} // have error \tbrick = brick.OrderBy(Offsetof(Detail{}.Name)) result, err = brick.Find(\u0026amp;tab) if err != nil { panic(err) } if err := result.Err();err != nil { // sql error record it \t} } 使用 toy-doctor 去检查它的错误\ntoy-doctor main.go // Output: // main.go:37:33 type must same as main.go:20:6  生成 coverprofile\ntoy-doctor -coverprofile=a.out main.go // view corverage in browser go tool cover -html=a.out  "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/9_join/",
	"title": "Join",
	"tags": [],
	"description": "",
	"content": " 是用Join查询可以保证所有记录都只需要一条查询\nModel Define 使用join的tag声明关联关联字段, join tag 的值必须和容器字段的名一样\ntype Extra map[string]interface{} func (e *Extra) Scan(value interface{}) error { switch v := value.(type) { case string: return json.Unmarshal([]byte(v), e) case []byte: return json.Unmarshal(v, e) default: return errors.New(\u0026#34;not support type\u0026#34;) } } func (e Extra) Value() (driver.Value, error) { return json.Marshal(e) } type Color struct { Name string `toyorm:\u0026#34;primary key;join:ColorDetail\u0026#34;` Code int32 } type Comment struct { toyorm.ModelDefault ProductDetailProductID uint32 `toyorm:\u0026#34;index\u0026#34;` Data string `toyorm:\u0026#34;type:VARCHAR(1024)\u0026#34;` } type ProductDetail struct { ProductID uint32 `toyorm:\u0026#34;primary key;join:Detail\u0026#34;` Title string CustomPage string `toyorm:\u0026#34;type:text\u0026#34;` Extra Extra `toyorm:\u0026#34;type:VARCHAR(2048)\u0026#34;` Color string `toyorm:\u0026#34;join:ColorDetail\u0026#34;` ColorJoin Color `toyorm:\u0026#34;alias:ColorDetail\u0026#34;` Comment []Comment } type Product struct { ID uint32 `toyorm:\u0026#34;primary key;auto_increment;join:Detail\u0026#34;` CreatedAt time.Time `toyorm:\u0026#34;NULL\u0026#34;` DeletedAt *time.Time `toyorm:\u0026#34;NULL\u0026#34;` Name string Count int Price float64 Detail *ProductDetail } Join in Find 使用Swap方法可以回到上一个ToyBrick，和Preload中的Enter类似\nbrick := toy.Model(\u0026amp;tab).Debug(). Join(Offsetof(tab.Detail)). Join(Offsetof(detailTab.ColorJoin)).Swap().Swap() var scanData []Product result, err = brick.Find(\u0026amp;scanData) // SELECT m.id,m.created_at,m.deleted_at,m.name,m.count,m.price,m_0.product_id,m_0.title,m_0.custom_page,m_0.extra,m_0.color,m_0_0.name,m_0_0.code FROM `product` as `m` JOIN `product_detail` AS `m_0` ON m.id = m_0.product_id JOIN `color` AS `m_0_0` ON m_0.color = m_0_0.name WHERE m.deleted_at IS NULL 使用Join交换当前的Model并增加一些Where条件\n// where Product.Name = \u0026#34;clean stick\u0026#34; or Color.Name = \u0026#34;black\u0026#34; brick := toy.Model(\u0026amp;tab).Debug().Where(\u0026#34;=\u0026#34;, Offsetof(tab.Name), \u0026#34;clean stick\u0026#34;). Join(Offsetof(tab.Detail)). Join(Offsetof(detailTab.ColorJoin)).Or().Condition(\u0026#34;=\u0026#34;, Offsetof(colorTab.Name), \u0026#34;black\u0026#34;). Swap().Swap() var scanData []Product result, err = brick.Find(\u0026amp;scanData) // SELECT m.id,m.created_at,m.deleted_at,m.name,m.count,m.price,m_0.product_id,m_0.title,m_0.custom_page,m_0.extra,m_0.color,m_0_0.name,m_0_0.code FROM `product` as `m` JOIN `product_detail` AS `m_0` ON m.id = m_0.product_id JOIN `color` AS `m_0_0` ON m_0.color = m_0_0.name WHERE m.deleted_at IS NULL AND (m.name = ? OR m_0_0.name = ?) args:[\u0026#34;clean stick\u0026#34;,\u0026#34;black\u0026#34;] 增加一些OrderBy\n// where Product.Name = \u0026#34;clean stick\u0026#34; or Color.Name = \u0026#34;black\u0026#34; brick := toy.Model(\u0026amp;tab).Debug(). Join(Offsetof(tab.Detail)). Join(Offsetof(detailTab.ColorJoin)).OrderBy(Offsetof(colorTab.Name)). Swap().Swap() var scanData []Product result, err = brick.Find(\u0026amp;scanData) // SELECT m.id,m.created_at,m.deleted_at,m.name,m.count,m.price,m_0.product_id,m_0.title,m_0.custom_page,m_0.extra,m_0.color,m_0_0.name,m_0_0.code FROM `product` as `m` JOIN `product_detail` AS `m_0` ON m.id = m_0.product_id JOIN `color` AS `m_0_0` ON m_0.color = m_0_0.name WHERE m.deleted_at IS NULL ORDER BY m_0_0.name 也可以使用GroupBy，这里不做演示了\nPreload On Join Preload 方法也可以工作在Join之下，这2个方法是对称的\nbrick := toy.Model(\u0026amp;tab).Debug(). Join(Offsetof(tab.Detail)).Preload(Offsetof(detailTab.Comment)).Enter(). Join(Offsetof(detailTab.ColorJoin)).Swap().Swap() var scanData []Product result, err = brick.Find(\u0026amp;scanData) // SELECT m.id,m.created_at,m.deleted_at,m.name,m.count,m.price,m_0.product_id,m_0.title,m_0.custom_page,m_0.extra,m_0.color,m_0_0.name,m_0_0.code FROM `product` as `m` JOIN `product_detail` AS `m_0` ON m.id = m_0.product_id JOIN `color` AS `m_0_0` ON m_0.color = m_0_0.name WHERE m.deleted_at IS NULL // SELECT id,created_at,updated_at,deleted_at,product_detail_product_id,data FROM `comment` WHERE deleted_at IS NULL AND product_detail_product_id IN (?,?,?) args:[1,2,3]"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/10_result/",
	"title": "Result",
	"tags": [],
	"description": "",
	"content": "使用 Report 去查看Sql执行\nreport 格式\n插入操作的report\nuser := User{ Detail: \u0026amp;UserDetail{ MainPage: \u0026#34;some html code with you page\u0026#34;, Extra: Extra{\u0026#34;title\u0026#34;: \u0026#34;my blog\u0026#34;}, }, Blog: []Blog{ {Title: \u0026#34;how to write a blog\u0026#34;, Content: \u0026#34;first ...\u0026#34;}, {Title: \u0026#34;blog introduction\u0026#34;, Content: \u0026#34;...\u0026#34;}, }, Friends: []*User{ { Detail: \u0026amp;UserDetail{ MainPage: \u0026#34;some html code with you page\u0026#34;, Extra: Extra{}, }, Blog: []Blog{ {Title: \u0026#34;some python tech\u0026#34;, Content: \u0026#34;first ...\u0026#34;}, {Title: \u0026#34;my eleme_union_meal usage\u0026#34;, Content: \u0026#34;...\u0026#34;}, }, Name: \u0026#34;fatpigeon\u0026#34;, Age: 18, Sex: \u0026#34;male\u0026#34;, }, }, Name: \u0026#34;bigpigeon\u0026#34;, Age: 18, Sex: \u0026#34;male\u0026#34;, } result, err = brick.Save(\u0026amp;user) // error process ... fmt.Printf(\u0026#34;report:\\n%s\\n\u0026#34;, result.Report()) /* // [0, ] means affected the 0 element // [0-0, ] means affected the 0 element the 0 sub element report: [0, ] INSERT INTO user(created_at,updated_at,deleted_at,name,age,sex) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.012285+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.012285+08:00\u0026#34;,null,\u0026#34;bigpigeon\u0026#34;,18,\u0026#34;male\u0026#34;] preload Detail [0-, ] INSERT INTO user_detail(user_id,main_page,extra) VALUES(?,?,?) args:[1,\u0026#34;some html code with you page\u0026#34;,{\u0026#34;title\u0026#34;:\u0026#34;my blog\u0026#34;}] preload Blog [0-0, ] INSERT INTO blog(created_at,updated_at,deleted_at,user_id,title,content) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.013968+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.013968+08:00\u0026#34;,null,1,\u0026#34;how to write a blog\u0026#34;,\u0026#34;first ...\u0026#34;] [0-1, ] INSERT INTO blog(created_at,updated_at,deleted_at,user_id,title,content) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.013968+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.013968+08:00\u0026#34;,null,1,\u0026#34;blog introduction\u0026#34;,\u0026#34;...\u0026#34;] preload Friends [0-0, ] INSERT INTO user(created_at,updated_at,deleted_at,name,age,sex) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.015207+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.015207+08:00\u0026#34;,null,\u0026#34;fatpigeon\u0026#34;,18,\u0026#34;male\u0026#34;] preload Detail [0-0-, ] INSERT INTO user_detail(user_id,main_page,extra) VALUES(?,?,?) args:[2,\u0026#34;some html code with you page\u0026#34;,{}] preload Blog [0-0-0, ] INSERT INTO blog(created_at,updated_at,deleted_at,user_id,title,content) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.016389+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.016389+08:00\u0026#34;,null,2,\u0026#34;some python tech\u0026#34;,\u0026#34;first ...\u0026#34;] [0-0-1, ] INSERT INTO blog(created_at,updated_at,deleted_at,user_id,title,content) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.016389+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.016389+08:00\u0026#34;,null,2,\u0026#34;my eleme_union_meal usage\u0026#34;,\u0026#34;...\u0026#34;] */ 查询操作的report\nbrick := brick.Preload(Offsetof(User{}.Friends)). Preload(Offsetof(User{}.Detail)).Enter(). Preload(Offsetof(User{}.Blog)).Enter(). Enter() var users []User result, err = brick.Find(\u0026amp;users) // some error process ... // print the report fmt.Printf(\u0026#34;report:\\n%s\\n\u0026#34;, result.Report()) // report log /* report: [0, 1, ] SELECT id,created_at,updated_at,deleted_at,name,age,sex FROM user WHERE deleted_at IS NULL args:null preload Detail [0-, 1-, ] SELECT id,user_id,main_page,extra FROM user_detail WHERE user_id IN (?,?) args:[2,1] preload Blog [0-0, 0-1, 1-0, 1-1, ] SELECT id,created_at,updated_at,deleted_at,user_id,title,content FROM blog WHERE deleted_at IS NULL AND user_id IN (?,?) args:[1,2] preload Friends [0-0, ] SELECT id,created_at,updated_at,deleted_at,name,age,sex FROM user WHERE deleted_at IS NULL AND id IN (?) args:[2] preload Detail [0-0-, ] SELECT id,user_id,main_page,extra FROM user_detail WHERE user_id IN (?) args:[2] preload Blog [0-0-0, 0-0-1, ] SELECT id,created_at,updated_at,deleted_at,user_id,title,content FROM blog WHERE deleted_at IS NULL AND user_id IN (?) args:[2] */ 使用 Err去查看Sql执行的错误\nvar users []struct { ID uint32 Age bool Detail *UserDetail Blog []Blog } result, err = brick.Find(\u0026amp;users) if err != nil { panic(err) } if err := result.Err(); err != nil { fmt.Printf(\u0026#34;error:\\n%s\\n\u0026#34;, err) } /* error: SELECT id,age FROM user WHERE deleted_at IS NULL args:null errors( [0]sql: Scan error on column index 1: sql/driver: couldn\u0026#39;t convert \u0026#34;18\u0026#34; into type bool [1]sql: Scan error on column index 1: sql/driver: couldn\u0026#39;t convert \u0026#34;18\u0026#34; into type bool ) */"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/5_scope/",
	"title": "Scope",
	"tags": [],
	"description": "",
	"content": "使用 scope 创建一个自定义的构建函数\n// desc 所有 order by 字段 brick.Scope(func(t *ToyBrick) *ToyBrick{ newOrderBy := make([]*ModelFields, len(t.orderBy)) for i, f := range t.orderBy { newOrderBy = append(newOrderBy, t.ToDesc(f)) } newt := *t newt.orderBy = newOrderBy return \u0026amp;newt })"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/",
	"title": "Toyorm",
	"tags": [],
	"description": "powerful toyorm",
	"content": " Toyorm  一个功能强大的go语言orm\n Overview  数据迁移 (CreateTable/DropTable) 操作数据 (Insert/Save/Update/Find/Delete) 预加载操作(BelongTo/OneToOne/OneToMany/ManyToMany mode) Join操作 事务 空值忽略 (toyorm允许你只忽略指定的空值) 字段绑定 (绑定后，操作表时只对绑定字段操作) 软删除 (更新 DeletedAt 字段值代替物理删除) Scope (自定义中间层) 线程安全(但必须准守协定) 查询模板 (自定义你的查询/执行语句) 返回值和错误记录 (记录数据库的操作记录和返回的错误) 集合 (多数据库操作) toy-doctor(检查FieldSelection参数错误)  Go 版本 version \u0026gt; 1.9\n支持数据库  sqlite3  mysql  postgresql  "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/1_codition/",
	"title": "Where条件",
	"tags": [],
	"description": "where usage",
	"content": " where 会删除旧的条件并创建新的\nbrick.Where(\u0026lt;expr\u0026gt;, \u0026lt;Key\u0026gt;, [value])  whereGroup同上，它可以同时增加多个条件并用And/Or相连\nbrick.WhereGroup(\u0026lt;expr\u0026gt;, \u0026lt;group\u0026gt;)  conditions也会把整个条件复制过来并删除旧的条件\nbrick.Conditions(\u0026lt;toyorm.Search\u0026gt;)  可以使用And/Or方法去链接新的条件\nbrick.Or().Condition(\u0026lt;expr\u0026gt;, \u0026lt;Key\u0026gt;, [value]) brick.Or().ConditionGroup(\u0026lt;expr\u0026gt;, \u0026lt;group\u0026gt;) brick.And().Condition(\u0026lt;expr\u0026gt;, \u0026lt;Key\u0026gt;, [value]) brick.And().ConditionGroup(\u0026lt;expr\u0026gt;, \u0026lt;group\u0026gt;)  And/Or方法 后置 conditions 将会使用And/Or方法去链接新的条件\nbrick.Or().Conditions(\u0026lt;toyorm.Search\u0026gt;) brick.And().Conditions(\u0026lt;toyorm.Search\u0026gt;)  表达式和数据库的关系    SearchExpr to sql example     ExprAnd AND brick.WhereGroup(ExprAnd, Product{Name:\u0026ldquo;food one\u0026rdquo;, Count: 4}) // WHERE name = \u0026ldquo;food one\u0026rdquo; AND Count = 4   ExprOr OR brick.WhereGroup(ExprOr, Product{Name:\u0026ldquo;food one\u0026rdquo;, Count: 4}) // WHERE name = \u0026ldquo;food one\u0026rdquo; OR Count = \u0026ldquo;4\u0026rdquo;   ExprEqual = brick.Where(ExprEqual, OffsetOf(Product{}.Name), \u0026ldquo;food one\u0026rdquo;) // WHERE name = \u0026ldquo;find one\u0026rdquo;   ExprNotEqual \u0026lt;\u0026gt; brick.Where(ExprNotEqual, OffsetOf(Product{}.Name), \u0026ldquo;food one\u0026rdquo;) // WHERE name \u0026lt;\u0026gt; \u0026ldquo;find one\u0026rdquo;   ExprGreater \u0026gt; brick.Where(ExprGreater, OffsetOf(Product{}.Count), 3) // WHERE count \u0026gt; 3   ExprGreaterEqual \u0026gt;= brick.Where(ExprGreaterEqual, OffsetOf(Product{}.Count), 3) // WHERE count \u0026gt;= 3   ExprLess \u0026lt; brick.Where(ExprLess, OffsetOf(Product{}.Count), 3) // WHERE count \u0026lt; 3   ExprLessEqual \u0026lt;= brick.Where(ExprLessEqual, OffsetOf(Product{}.Count), 3) // WHERE count \u0026lt;= 3   ExprBetween Between brick.Where(ExprBetween, OffsetOf(Product{}.Count), [2]int{2,3}) // WHERE count BETWEEN 2 AND 3   ExprNotBetween NOT Between brick.Where(ExprNotBetween, OffsetOf(Product{}.Count), [2]int{2,3}) // WHERE count NOT BETWEEN 2 AND 3   ExprIn IN brick.Where(ExprIn, OffsetOf(Product{}.Count), []int{1, 2, 3}) // WHERE count IN (1,2,3)   ExprNotIn NOT IN brick.Where(ExprNotIn, OffsetOf(Product{}.Count), []int{1, 2, 3}) // WHERE count NOT IN (1,2,3)   ExprLike LIKE brick.Where(ExprLike, OffsetOf(Product{}.Name), \u0026ldquo;one\u0026rdquo;) // WHERE name LIKE \u0026ldquo;one\u0026rdquo;   ExprNotLike NOT LIKE brick.Where(ExprNotLike, OffsetOf(Product{}.Name), \u0026ldquo;one\u0026rdquo;) // WHERE name NOT LIKE \u0026ldquo;one\u0026rdquo;   ExprNull IS NULL brick.Where(ExprNull, OffsetOf(Product{}.DeletedAt)) // WHERE DeletedAt IS NULL   ExprNotNull IS NOT NULL brick.Where(ExprNotNull, OffsetOf(Product{}.DeletedAt)) // WHERE DeletedAt IS NOT NULL    limit \u0026amp; offset\nbrick := brick.Offset(2).Limit(2) // LIMIT 2 OFFSET 2 order by\nbrick = brick.OrderBy(Offsetof(Product{}.Name)) // ORDER BY name order by desc\nbrick = brick.OrderBy(brick.ToDesc(Offsetof(Product{}.Name))) // ORDER BY name DESC group by\n// 定义用于group by 的结构体 type ProductGroup struct { Tag string KindCount int `toyorm:\u0026#34;column:COUNT(*)\u0026#34;` } // implement toyorm.tabler for custom table name func (p ProductGroup) TableName() string { return toyorm.ModelName(reflect.TypeOf(Product{})) } ... var tab ProductGroup brick := toy.Model(\u0026amp;tab).Debug().GroupBy(Offsetof(tab.Tag)) var data []ProductGroup brick.Find(\u0026amp;data) // SELECT tag,COUNT(*) FROM `product` GROUP BY tag "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/2_transaction/",
	"title": "事务",
	"tags": [],
	"description": "transaction",
	"content": "开启一个事务\nbrick = brick.Begin() 回滚所有sql事件\nerr = brick.Rollback() 提交所有sql事件\nerr = brick.Commit()"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/4_bind_field/",
	"title": "字段绑定",
	"tags": [],
	"description": "",
	"content": "使用字段绑定方法去选择哪些字段会被接下来的操作用到\n如果使用了字段绑定，IgnoreMode将失效\nBindDefaultFields 工作与所有场景下\n{ var p Product result, err := brick.BindDefaultFields(Offsetof(p.Price), Offsetof(p.UpdatedAt)).Update(\u0026amp;Product{ Price: 0, }) // UPDATE `product` SET price=?,updated_at=? WHERE deleted_at IS NULL args:[0,\u0026#34;2018-05-14T12:16:21.731031534+08:00\u0026#34;]  // process error  ... } var products []Product result, err = brick.Find(\u0026amp;products) // process error ... for _, p := range products { fmt.Printf(\u0026#34;product name %s, price %v\\n\u0026#34;, p.Name, p.Price) }"
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/11_field_selector/",
	"title": "字段选择器",
	"tags": [],
	"description": "",
	"content": "toyorm 支持多种方式去获取Model的字段：通过struct,字段名或者字段偏移量\n你可以通过任意一种方式去获取它 e.g\ninsert // use struct // insert with struct product := Product{ Name: \u0026#34;sth\u0026#34;, Price: 22, } brick.Insert(\u0026amp;product) // or insert with name map product := map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;sth\u0026#34;, \u0026#34;Price\u0026#34;: 22, } brick.Insert(\u0026amp;product) // or insert with offsetof map, in this method, you need import \u0026#34;unsafe\u0026#34; to get it\u0026#39;s Offsetof function product := map[uintptr]interface{}{ Offsetof(Product{}.Name): \u0026#34;sth\u0026#34;, Offsetof(Product{}.Price): 22, } brick.Insert(\u0026amp;product)  where // select field with name string brick = brick.Where(\u0026#34;\u0026gt;\u0026#34;, \u0026#34;Price\u0026#34;, 22) // select field with with offsetof, you need import \u0026#34;unsafe\u0026#34; to get it\u0026#39;s Offsetof function brick = brick.Where(\u0026#34;\u0026gt;\u0026#34;, Offsetof(Product{}.Price), 22)  数据操作支持的字段\n   operation \\ selector OffsetOf Name string map[OffsetOf]interface{} map[string]interface{} struct     Update no no yes yes yes   Insert no no yes yes yes   Save no no yes yes yes   Where \u0026amp; Conditions yes yes no no no   WhereGroup \u0026amp; ConditionGroup no no yes yes yes   BindFields yes yes no no no   Preload \u0026amp; Custom Preload yes yes no no no   OrderBy yes yes no no no   Find no no no no yes    "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/6_template/",
	"title": "模板",
	"tags": [],
	"description": "",
	"content": " 使用 template 语句代替默认SQL语句\n目前模板只支持 Insert/Save/Update/Find\n自定义插入 data := Product{ Name: \u0026#34;bag\u0026#34;, Price: 9999, Count: 2, Tag: \u0026#34;container\u0026#34;, } result, err := brick.Template(\u0026#34;INSERT INTO $ModelName($Columns) Values($Values)\u0026#34;).Insert(\u0026amp;data) // INSERT INTO product(created_at,updated_at,deleted_at,name,price,count,tag) Values(?,?,?,?,?,?,?) args:[\u0026#34;2018-04-01T17:05:48.927499+08:00\u0026#34;,\u0026#34;2018-04-01T17:05:48.927499+08:00\u0026#34;,null,\u0026#34;bag\u0026#34;,9999,2,\u0026#34;container\u0026#34;] 自定义查找 var data Product // if driver is mysql use \u0026#34;USE INDEX\u0026#34; replace \u0026#34;INDEXED BY\u0026#34; result, err := brick.Template(\u0026#34;SELECT $Columns FROM $ModelName INDEXED BY idx_product_name $Conditions\u0026#34;). Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Find(\u0026amp;data) // SELECT id,created_at,updated_at,deleted_at,name,price,count,tag FROM product INDEXED BY idx_product_name WHERE deleted_at IS NULL AND name = ? LIMIT 1 args:[\u0026#34;bag\u0026#34;] 自定义更新 set count = count + 2\nresult, err := brick.Template(fmt.Sprintf(\u0026#34;UPDATE $ModelName SET $Values,$FN-Count = $0x%x + ? $Conditions\u0026#34;, Offsetof(Product{}.Count)), 2). Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Update(\u0026amp;Product{Price: 200}) // UPDATE product SET updated_at = ?,price = ?,count = count + ? WHERE deleted_at IS NULL AND name = ? args:[\u0026#34;2018-04-01T17:50:35.205377+08:00\u0026#34;,200,2,\u0026#34;bag\u0026#34;] 占位符 以下占位符将会在模板中使用\n2种字段相关占位符\n $FN- 会把字段名转换成表字段名 e.g $FN-Name =\u0026gt; name $0x 会把字段偏移量转换成表字段名 e.g $0x58 =\u0026gt; Count     action \\ placeholder $ModelName $Columns $Values $Conditions     Find product id,data,\u0026hellip; - WHERE \u0026hellip; ORDER BY \u0026hellip; GROUP BY \u0026hellip; LIMIT \u0026hellip; OFFSET \u0026hellip;   Insert product id,data,\u0026hellip; ?,?,\u0026hellip; WHERE \u0026hellip; ORDER BY \u0026hellip; GROUP BY \u0026hellip; LIMIT \u0026hellip; OFFSET \u0026hellip;   Save product id,data,\u0026hellip; ?,?,\u0026hellip; WHERE \u0026hellip; ORDER BY \u0026hellip; GROUP BY \u0026hellip; LIMIT \u0026hellip; OFFSET \u0026hellip;   Update product id,data,\u0026hellip; id = ?,data = ?,\u0026hellip; WHERE \u0026hellip; ORDER BY \u0026hellip; GROUP BY \u0026hellip; LIMIT \u0026hellip; OFFSET \u0026hellip;    "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/3_ignore_mode/",
	"title": "空值忽略",
	"tags": [],
	"description": "",
	"content": "当我使用struct参数去Update或Where操作是，是否应该忽略它的空值？\n使用 IgnoreMode方法去确认哪些空值需要被更新\nbrick = brick.IgnoreMode(toyorm.Mode(\u0026#34;Update\u0026#34;), toyorm.IgnoreZero ^ toyorm.IgnoreZeroLen) // 忽略所有空值但不包括len为0的容器 // []int(nil) 字段会被忽略 // []int{} 字段不会被忽略 // map[int]int(nil) 字段会被忽略 // map[int]int{} 字段不会被忽略 默认空值忽略模式\n   Operation Mode affect     Insert IgnoreNo brick.Insert()   Replace IgnoreNo brick.Replace()   Condition IgnoreZero brick.WhereGroup(ExprAnd/ExprOr, )   Update IgnoreZero brick.Update()    所有空值忽略模式\n   mode effective     IgnoreFalse 忽略所有bool类型中的false   IgnoreZeroInt 忽略所有int/uint/uintptr(incloud their 16,32,64 bit type)中的0   IgnoreZeroFloat 忽略所有float32/float64 类型中的0.0   IgnoreZeroComplex 忽略所有complex64/complex128 中的0 + 0i   IgnoreNilString 忽略所有string类型中的 \u0026ldquo;\u0026rdquo;   IgnoreNilPoint 忽略所有 point/map/slice类型中的nil   IgnoreZeroLen 忽略所有 map/array/slice类型中的len=0的值   IgnoreNullStruct 忽略所有 struct 中的空结构体 e.g type A struct{A string,B int}, A{\u0026ldquo;\u0026rdquo;, 0} 将被忽略   IgnoreNil 忽略 IgnoreNilPoint 和 IgnoreZeroLen   IgnoreZero 忽略以上所有模式    "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/7_thread_safe/",
	"title": "线程安全",
	"tags": [],
	"description": "",
	"content": "如果你准守一下协定可以保证使用toyorm时的线程安全\n 确保 ToyBrick 对象是只读的, 如果你想修改它，创建一个新的\n 不要使用 append 去改变 ToyBrick中的slice字段,使用 make 和 copy 函数去克隆一个新的slice\n  "
},
{
	"uri": "https://bigpigeon.org/toyorm/cn/4_toy_brick/8_preload/",
	"title": "预加载",
	"tags": [],
	"description": "",
	"content": " 预加载需要一个关联字段和一个容器字段(ManyToMany只需要容器字段)\n关联字段用来关联主记录和子记录的数据\n关联字段可以是一个外键，但不推荐这么做\n容器字段用来保存查询出来的子记录，它本身不属于表的任何字段\nOne to one 关联字段在子Model中\n关联字段的名字必须是主Model类型名+主Model的主键名\ntype User struct { toyorm.ModelDefault // container field  Detail *UserDetail } type UserDetail struct { ID int `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` // relation field  UserID uint `toyorm:\u0026#34;index\u0026#34;` MainPage string `toyorm:\u0026#34;type:Text\u0026#34;` } // load preload brick = toy.Model(\u0026amp;User{}).Debug().Preload(OffsetOf(User.Detail)).Enter() Belong to 关联字段在主Model中\n关联字段的名字必须是容器字段名+子Model的主键名\ntype User struct { toyorm.ModelDefault // container field  Detail *UserDetail // relation field  DetailID int `toyorm:\u0026#34;index\u0026#34;` } type UserDetail struct { ID int `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` MainPage string `toyorm:\u0026#34;type:Text\u0026#34;` } One to many 关联字段在子Model中\n关联字段的名字必须是主Model类型名+主Model的主键名\ntype User struct { toyorm.ModelDefault // container field  Blog []Blog } type Blog struct { toyorm.ModelDefault // relation field  UserID uint `toyorm:\u0026#34;index\u0026#34;` Title string `toyorm:\u0026#34;index\u0026#34;` Content string } Many to many ManyToMany中不需要指定关联字段，它的关联字段在中间表\ntype User struct { toyorm.ModelDefault // container field Friends []*User }  Load preload 如果你完成了数据的定义，是时候开始构建预加载的数据了\n// create a main brick brick = toy.Model(\u0026amp;User{}) // create a sub brick subBrick := brick.Preload(OffsetOf(User.Blog)) // you can editing any attribute what you want, just like editing it on main model subBrick = subBrick.Where(ExprEqual, OffsetOf(Blog.Title), \u0026#34;my blog\u0026#34;) // finished change ,use Enter() go back the main brick brick = subBrick.Enter() 如果你不喜欢这种关联字段的命名，也可以手动指定它的关系\n// one to one custom brick.CustomOneToOnePreload(\u0026lt;main container\u0026gt;, \u0026lt;sub relation\u0026gt;, [sub model struct]) // belong to custom brick.CustomBelongToPreload(\u0026lt;main container\u0026gt;, \u0026lt;main relation\u0026gt;, [sub model struct]) // one to many brick.CustomOneToManyPreload(\u0026lt;main container\u0026gt;, \u0026lt;sub relation\u0026gt;, [sub model struct]) // many to many brick.CustomManyToManyPreload(\u0026lt;middle model struct\u0026gt;, \u0026lt;main container\u0026gt;, \u0026lt;main relation\u0026gt;, \u0026lt;sub relation\u0026gt;, [sub model struct]) 或者使用tag声明来自定义关联字段\ntype UserDetail struct { ID int `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` MainID uint32 `toyorm:\u0026#34;index;one to one:Detail\u0026#34;` // declaration the container field  MainPage string `toyorm:\u0026#34;type:Text\u0026#34;` Extra Extra `toyorm:\u0026#34;type:VARCHAR(1024)\u0026#34;` } type Blog struct { toyorm.ModelDefault MainID uint32 `toyorm:\u0026#34;index;one to many:Blog\u0026#34;` // declaration the container field  Title string `toyorm:\u0026#34;index\u0026#34;` Content string } type User struct { toyorm.ModelDefault Name string `toyorm:\u0026#34;unique index\u0026#34;` Age int Sex string Detail *UserDetail Friends []*User Blog []Blog } // now custom relation field is MainID brick = brick.Preload(Offsetof(User{}.Blog)).Enter() brick = brick.Preload(Offsetof(User{}.Detail)).Enter()"
}]