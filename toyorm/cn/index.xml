<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Toyorm on toyorm 文档</title>
    <link>https://bigpigeon.org/toyorm/cn/</link>
    <description>Recent content in Toyorm on toyorm 文档</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://bigpigeon.org/toyorm/cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>toy工具</title>
      <link>https://bigpigeon.org/toyorm/cn/2_engine/toy_toolkit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/2_engine/toy_toolkit/</guid>
      <description> SetDebug 设置默认的Debug模式
toy.SetDebug(true) // 设置默认debug模式 	brick := toy.Model(&amp;amp;User{}) // 现在这个ToyBrick对象的debug为true 	</description>
    </item>
    
    <item>
      <title>类型转换</title>
      <link>https://bigpigeon.org/toyorm/cn/3_data_definition/type_translation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/3_data_definition/type_translation/</guid>
      <description>如果sql类型为空，toyorm在操作操作数据库时会忽略它
你可以使用 &amp;lt;type:sql_type&amp;gt; tag去声明字段的 sql 类型
下面这些go类型会自动声明它的sql类型
   Go Type sql type     bool BOOLEAN   int8,int16,int32,uint8,uint16,uint32 INTEGER   int64,uint64,int,uint BIGINT   float32,float64 FLOAT   string VARCHAR(255)   time.Time TIMESTAMP   []byte VARCHAR(255)   sql.NullBool BOOLEAN   sql.NullInt64 BIGINT   sql.NullFloat64 FLOAT   sql.NullString VARCHAR(255)   sql.RawBytes VARCHAR(255)    </description>
    </item>
    
    <item>
      <title>Tag声明</title>
      <link>https://bigpigeon.org/toyorm/cn/3_data_definition/tag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/3_data_definition/tag/</guid>
      <description>声明格式可以是 &amp;lt;key:value&amp;gt; 或 &amp;lt;key&amp;gt;
type User struct { toyorm.ModelDefault Name uint `toyorm:&amp;#34;index&amp;#34;` // 只有key的声明  FullName string `toyorm:&amp;#34;column:fullname&amp;#34;` // 键值声明 }  下面这些是特殊tag声明     键 值 说明     index void or string 为字段增加索引,如果你想声明一个组合索引，只要在字段之间使用相同的索引名即可   unique index void or string 唯一索引声明, 用法同上   primary key void 主键声明,允许但不建议多主键，因为一些操作可能不支持   - void 在sql操作中忽略该字段   type string 声明sql字段类型   column string 声明sql字段名   auto_increment void 如果你的主键有 auto_increment 属性，请添加它   autoincrement void 和auto_increment一样   foreign key void 外键声明，不推荐使用   alias string 声明字段名   join string 用于选择Join容器的关联字段   belong to string 用于选择BelongTo预加载的关联字段   one to one string 用于选择OneToOne预加载的关联字段   one to many string 用于选择OneToMany预加载的关联字段    额外的tag声明会在创建表时附加到字段末尾</description>
    </item>
    
    <item>
      <title>Join</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/9_join/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/9_join/</guid>
      <description>是用Join查询可以保证所有记录都只需要一条查询
Model Define 使用join的tag声明关联关联字段, join tag 的值必须和容器字段的名一样
type Extra map[string]interface{} func (e *Extra) Scan(value interface{}) error { switch v := value.(type) { case string: return json.Unmarshal([]byte(v), e) case []byte: return json.Unmarshal(v, e) default: return errors.New(&amp;#34;not support type&amp;#34;) } } func (e Extra) Value() (driver.Value, error) { return json.Marshal(e) } type Color struct { Name string `toyorm:&amp;#34;primary key;join:ColorDetail&amp;#34;` Code int32 } type Comment struct { toyorm.ModelDefault ProductDetailProductID uint32 `toyorm:&amp;#34;index&amp;#34;` Data string `toyorm:&amp;#34;type:VARCHAR(1024)&amp;#34;` } type ProductDetail struct { ProductID uint32 `toyorm:&amp;#34;primary key;join:Detail&amp;#34;` Title string CustomPage string `toyorm:&amp;#34;type:text&amp;#34;` Extra Extra `toyorm:&amp;#34;type:VARCHAR(2048)&amp;#34;` Color string `toyorm:&amp;#34;join:ColorDetail&amp;#34;` ColorJoin Color `toyorm:&amp;#34;alias:ColorDetail&amp;#34;` Comment []Comment } type Product struct { ID uint32 `toyorm:&amp;#34;primary key;auto_increment;join:Detail&amp;#34;` CreatedAt time.</description>
    </item>
    
    <item>
      <title>Result</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/10_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/10_result/</guid>
      <description>使用 Report 去查看Sql执行
report 格式
插入操作的report
user := User{ Detail: &amp;amp;UserDetail{ MainPage: &amp;#34;some html code with you page&amp;#34;, Extra: Extra{&amp;#34;title&amp;#34;: &amp;#34;my blog&amp;#34;}, }, Blog: []Blog{ {Title: &amp;#34;how to write a blog&amp;#34;, Content: &amp;#34;first ...&amp;#34;}, {Title: &amp;#34;blog introduction&amp;#34;, Content: &amp;#34;...&amp;#34;}, }, Friends: []*User{ { Detail: &amp;amp;UserDetail{ MainPage: &amp;#34;some html code with you page&amp;#34;, Extra: Extra{}, }, Blog: []Blog{ {Title: &amp;#34;some python tech&amp;#34;, Content: &amp;#34;first ...&amp;#34;}, {Title: &amp;#34;my eleme_union_meal usage&amp;#34;, Content: &amp;#34;...&amp;#34;}, }, Name: &amp;#34;fatpigeon&amp;#34;, Age: 18, Sex: &amp;#34;male&amp;#34;, }, }, Name: &amp;#34;bigpigeon&amp;#34;, Age: 18, Sex: &amp;#34;male&amp;#34;, } result, err = brick.</description>
    </item>
    
    <item>
      <title>Scope</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/5_scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/5_scope/</guid>
      <description>使用 scope 创建一个自定义的构建函数
// desc 所有 order by 字段 brick.Scope(func(t *ToyBrick) *ToyBrick{ newOrderBy := make([]*ModelFields, len(t.orderBy)) for i, f := range t.orderBy { newOrderBy = append(newOrderBy, t.ToDesc(f)) } newt := *t newt.orderBy = newOrderBy return &amp;amp;newt })</description>
    </item>
    
    <item>
      <title>Where条件</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/1_codition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/1_codition/</guid>
      <description>where 会删除旧的条件并创建新的
brick.Where(&amp;lt;expr&amp;gt;, &amp;lt;Key&amp;gt;, [value])  whereGroup同上，它可以同时增加多个条件并用And/Or相连
brick.WhereGroup(&amp;lt;expr&amp;gt;, &amp;lt;group&amp;gt;)  conditions也会把整个条件复制过来并删除旧的条件
brick.Conditions(&amp;lt;toyorm.Search&amp;gt;)  可以使用And/Or方法去链接新的条件
brick.Or().Condition(&amp;lt;expr&amp;gt;, &amp;lt;Key&amp;gt;, [value]) brick.Or().ConditionGroup(&amp;lt;expr&amp;gt;, &amp;lt;group&amp;gt;) brick.And().Condition(&amp;lt;expr&amp;gt;, &amp;lt;Key&amp;gt;, [value]) brick.And().ConditionGroup(&amp;lt;expr&amp;gt;, &amp;lt;group&amp;gt;)  And/Or方法 后置 conditions 将会使用And/Or方法去链接新的条件
brick.Or().Conditions(&amp;lt;toyorm.Search&amp;gt;) brick.And().Conditions(&amp;lt;toyorm.Search&amp;gt;)  表达式和数据库的关系    SearchExpr to sql example     ExprAnd AND brick.WhereGroup(ExprAnd, Product{Name:&amp;ldquo;food one&amp;rdquo;, Count: 4}) // WHERE name = &amp;ldquo;food one&amp;rdquo; AND Count = 4   ExprOr OR brick.WhereGroup(ExprOr, Product{Name:&amp;ldquo;food one&amp;rdquo;, Count: 4}) // WHERE name = &amp;ldquo;food one&amp;rdquo; OR Count = &amp;ldquo;4&amp;rdquo;   ExprEqual = brick.</description>
    </item>
    
    <item>
      <title>事务</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/2_transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/2_transaction/</guid>
      <description>开启一个事务
brick = brick.Begin() 回滚所有sql事件
err = brick.Rollback() 提交所有sql事件
err = brick.</description>
    </item>
    
    <item>
      <title>字段绑定</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/4_bind_field/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/4_bind_field/</guid>
      <description>使用字段绑定方法去选择哪些字段会被接下来的操作用到
如果使用了字段绑定，IgnoreMode将失效
BindDefaultFields 工作与所有场景下
{ var p Product result, err := brick.BindDefaultFields(Offsetof(p.Price), Offsetof(p.UpdatedAt)).Update(&amp;amp;Product{ Price: 0, }) // UPDATE `product` SET price=?,updated_at=? WHERE deleted_at IS NULL args:[0,&amp;#34;2018-05-14T12:16:21.731031534+08:00&amp;#34;]  // process error  ... } var products []Product result, err = brick.Find(&amp;amp;products) // process error ... for _, p := range products { fmt.Printf(&amp;#34;product name %s, price %v\n&amp;#34;, p.Name, p.Price) }</description>
    </item>
    
    <item>
      <title>字段选择器</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/11_field_selector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/11_field_selector/</guid>
      <description>toyorm 支持多种方式去获取Model的字段：通过struct,字段名或者字段偏移量
你可以通过任意一种方式去获取它 e.g
insert // use struct // insert with struct product := Product{ Name: &amp;#34;sth&amp;#34;, Price: 22, } brick.Insert(&amp;amp;product) // or insert with name map product := map[string]interface{}{ &amp;#34;Name&amp;#34;: &amp;#34;sth&amp;#34;, &amp;#34;Price&amp;#34;: 22, } brick.Insert(&amp;amp;product) // or insert with offsetof map, in this method, you need import &amp;#34;unsafe&amp;#34; to get it&amp;#39;s Offsetof function product := map[uintptr]interface{}{ Offsetof(Product{}.Name): &amp;#34;sth&amp;#34;, Offsetof(Product{}.Price): 22, } brick.Insert(&amp;amp;product)  where // select field with name string brick = brick.</description>
    </item>
    
    <item>
      <title>模板</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/6_template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/6_template/</guid>
      <description>使用 template 语句代替默认SQL语句
目前模板只支持 Insert/Save/Update/Find
自定义插入 data := Product{ Name: &amp;#34;bag&amp;#34;, Price: 9999, Count: 2, Tag: &amp;#34;container&amp;#34;, } result, err := brick.Template(&amp;#34;INSERT INTO $ModelName($Columns) Values($Values)&amp;#34;).Insert(&amp;amp;data) // INSERT INTO product(created_at,updated_at,deleted_at,name,price,count,tag) Values(?,?,?,?,?,?,?) args:[&amp;#34;2018-04-01T17:05:48.927499+08:00&amp;#34;,&amp;#34;2018-04-01T17:05:48.927499+08:00&amp;#34;,null,&amp;#34;bag&amp;#34;,9999,2,&amp;#34;container&amp;#34;] 自定义查找 var data Product // if driver is mysql use &amp;#34;USE INDEX&amp;#34; replace &amp;#34;INDEXED BY&amp;#34; result, err := brick.Template(&amp;#34;SELECT $Columns FROM $ModelName INDEXED BY idx_product_name $Conditions&amp;#34;). Where(&amp;#34;=&amp;#34;, Offsetof(Product{}.Name), &amp;#34;bag&amp;#34;).Find(&amp;amp;data) // SELECT id,created_at,updated_at,deleted_at,name,price,count,tag FROM product INDEXED BY idx_product_name WHERE deleted_at IS NULL AND name = ?</description>
    </item>
    
    <item>
      <title>空值忽略</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/3_ignore_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/3_ignore_mode/</guid>
      <description>当我使用struct参数去Update或Where操作是，是否应该忽略它的空值？
使用 IgnoreMode方法去确认哪些空值需要被更新
brick = brick.IgnoreMode(toyorm.Mode(&amp;#34;Update&amp;#34;), toyorm.IgnoreZero ^ toyorm.IgnoreZeroLen) // 忽略所有空值但不包括len为0的容器 // []int(nil) 字段会被忽略 // []int{} 字段不会被忽略 // map[int]int(nil) 字段会被忽略 // map[int]int{} 字段不会被忽略 默认空值忽略模式
   Operation Mode affect     Insert IgnoreNo brick.Insert()   Replace IgnoreNo brick.Replace()   Condition IgnoreZero brick.WhereGroup(ExprAnd/ExprOr, )   Update IgnoreZero brick.Update()    所有空值忽略模式
   mode effective     IgnoreFalse 忽略所有bool类型中的false   IgnoreZeroInt 忽略所有int/uint/uintptr(incloud their 16,32,64 bit type)中的0   IgnoreZeroFloat 忽略所有float32/float64 类型中的0.</description>
    </item>
    
    <item>
      <title>线程安全</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/7_thread_safe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/7_thread_safe/</guid>
      <description>如果你准守一下协定可以保证使用toyorm时的线程安全
 确保 ToyBrick 对象是只读的, 如果你想修改它，创建一个新的
 不要使用 append 去改变 ToyBrick中的slice字段,使用 make 和 copy 函数去克隆一个新的slice
  </description>
    </item>
    
    <item>
      <title>预加载</title>
      <link>https://bigpigeon.org/toyorm/cn/4_toy_brick/8_preload/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bigpigeon.org/toyorm/cn/4_toy_brick/8_preload/</guid>
      <description>预加载需要一个关联字段和一个容器字段(ManyToMany只需要容器字段)
关联字段用来关联主记录和子记录的数据
关联字段可以是一个外键，但不推荐这么做
容器字段用来保存查询出来的子记录，它本身不属于表的任何字段
One to one 关联字段在子Model中
关联字段的名字必须是主Model类型名+主Model的主键名
type User struct { toyorm.ModelDefault // container field  Detail *UserDetail } type UserDetail struct { ID int `toyorm:&amp;#34;primary key;auto_increment&amp;#34;` // relation field  UserID uint `toyorm:&amp;#34;index&amp;#34;` MainPage string `toyorm:&amp;#34;type:Text&amp;#34;` } // load preload brick = toy.Model(&amp;amp;User{}).Debug().Preload(OffsetOf(User.Detail)).Enter() Belong to 关联字段在主Model中
关联字段的名字必须是容器字段名+子Model的主键名
type User struct { toyorm.ModelDefault // container field  Detail *UserDetail // relation field  DetailID int `toyorm:&amp;#34;index&amp;#34;` } type UserDetail struct { ID int `toyorm:&amp;#34;primary key;auto_increment&amp;#34;` MainPage string `toyorm:&amp;#34;type:Text&amp;#34;` } One to many 关联字段在子Model中</description>
    </item>
    
  </channel>
</rss>