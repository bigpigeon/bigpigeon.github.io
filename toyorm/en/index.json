[
{
	"uri": "https://bigpigeon.org/toyorm/en/1_getting_started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": " Install go get github.com/bigpigeon/toyorm  Simple Example package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/bigpigeon/toyorm\u0026#34; \u0026#34;reflect\u0026#34; . \u0026#34;unsafe\u0026#34; // when database is mysql \t//_ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; \t// when database is sqlite3 \t_ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; // when database is postgres \t//_ \u0026#34;github.com/lib/pq\u0026#34; ) /* ---------------------- data definition ------------------------- */ func JsonEncode(v interface{}) string { jsonData, err := json.MarshalIndent(v, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { panic(err) } return string(jsonData) } type Product struct { toyorm.ModelDefault Name string `toyorm:\u0026#34;index\u0026#34;` Price float64 `toyorm:\u0026#34;index\u0026#34;` Count int Tag string `toyorm:\u0026#34;index\u0026#34;` } // use by group by type ProductGroup struct { Tag string KindCount int `toyorm:\u0026#34;column:COUNT(*)\u0026#34;` } // implement toyorm.tabler for custom table name func (p ProductGroup) TableName() string { return toyorm.ModelName(reflect.TypeOf(Product{})) } func main() { var err error var toy *toyorm.Toy var result *toyorm.Result // when database is mysql, make sure your mysql have toyorm_example schema \t//toy, err = toyorm.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:@tcp(localhost:3306)/toyorm_example?charset=utf8\u0026amp;parseTime=True\u0026#34;) \t// when database is sqlite3 \ttoy, err = toyorm.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;toyorm_test.db\u0026#34;) // when database is postgres \t//toy, err = toyorm.Open(\u0026#34;postgres\u0026#34;, \u0026#34;user=postgres dbname=toyorm sslmode=disable\u0026#34;)  // brick is basic \u0026#34;sql builder\u0026#34; \tbrick := toy.Model(\u0026amp;Product{}).Debug() // use drop table operation to clear old data \tresult, err = brick.DropTableIfExist() if err != nil { panic(err) } // print sql error if exist \tif resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } // create table \tresult, err = brick.CreateTableIfNotExist() if err != nil { panic(err) } // print sql error if exist \tif resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } // Insert will set id to source data when primary key is auto_increment \tresult, err = brick.Insert(\u0026amp;[]Product{ {Name: \u0026#34;food one\u0026#34;, Price: 1, Count: 4, Tag: \u0026#34;food\u0026#34;}, {Name: \u0026#34;food two\u0026#34;, Price: 2, Count: 3, Tag: \u0026#34;food\u0026#34;}, {Name: \u0026#34;food three\u0026#34;, Price: 3, Count: 2, Tag: \u0026#34;food\u0026#34;}, {Name: \u0026#34;food four\u0026#34;, Price: 4, Count: 1, Tag: \u0026#34;food\u0026#34;}, {Name: \u0026#34;toolkit one\u0026#34;, Price: 1, Count: 8, Tag: \u0026#34;toolkit\u0026#34;}, {Name: \u0026#34;toolkit two\u0026#34;, Price: 2, Count: 6, Tag: \u0026#34;toolkit\u0026#34;}, {Name: \u0026#34;toolkit one\u0026#34;, Price: 3, Count: 4, Tag: \u0026#34;toolkit\u0026#34;}, {Name: \u0026#34;toolkit two\u0026#34;, Price: 4, Count: 2, Tag: \u0026#34;toolkit\u0026#34;}, }) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } // find one with the tag=food condition \t{ var product Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Tag), \u0026#34;food\u0026#34;).Find(\u0026amp;product) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;food %s\\n\u0026#34;, JsonEncode(product)) } // find all tag=food \t{ var products []Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Tag), \u0026#34;food\u0026#34;).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;foods %s\\n\u0026#34;, JsonEncode(products)) } // find count = 2 \t{ var products []Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;count \u0026gt; 2 products %s\\n\u0026#34;, JsonEncode(products)) } // find count = 2 and price \u0026gt; 3 \t{ var products []Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).And(). Condition(toyorm.ExprGreater, Offsetof(Product{}.Price), 3).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;count = 2 and price \u0026gt; 3 products %s\\n\u0026#34;, JsonEncode(products)) } // find count = 2 and price \u0026gt; 3 or count = 4 \t{ var products []Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).And(). Condition(toyorm.ExprGreater, Offsetof(Product{}.Price), 3).Or(). Condition(toyorm.ExprEqual, Offsetof(Product{}.Count), 4).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;count = 2 and price \u0026gt; 3 or count = 4 products %s\\n\u0026#34;, JsonEncode(products)) } // find price \u0026gt; 3 and (count = 2 or count = 1) \t{ var products []Product result, err := brick.Where(toyorm.ExprGreater, Offsetof(Product{}.Price), 3).And().Conditions( brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).Or(). Condition(toyorm.ExprEqual, Offsetof(Product{}.Count), 1).Search, ).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;price \u0026gt; 3 and (count = 2 or count = 1) products %s\\n\u0026#34;, JsonEncode(products)) } // find (count = 2 or count = 1) and (price = 3 or price = 4) \t{ var products []Product result, err := brick.Conditions( brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Count), 2).Or(). Condition(toyorm.ExprEqual, Offsetof(Product{}.Count), 1).Search, ).And().Conditions( brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Price), 3).Or(). Condition(toyorm.ExprEqual, Offsetof(Product{}.Price), 4).Search, ).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;(count = 2 or count = 1) and (price = 3 or price = 4) products %s\\n\u0026#34;, JsonEncode(products)) } // find offset 2 limit 2 \t{ var products []Product result, err := brick.Offset(2).Limit(2).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;offset 1 limit 2 products %s\\n\u0026#34;, JsonEncode(products)) } // order by \t{ var products []Product result, err := brick.OrderBy(Offsetof(Product{}.Name)).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;order by name products %s\\n\u0026#34;, JsonEncode(products)) } { var products []Product result, err := brick.OrderBy(brick.ToDesc(Offsetof(Product{}.Name))).Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;order by name desc products %s\\n\u0026#34;, JsonEncode(products)) } // update to count = 4 \t{ result, err := brick.Update(\u0026amp;Product{ Count: 4, }) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } var Counters []struct { Name string Count int } result, err = brick.Find(\u0026amp;Counters) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } for _, counter := range Counters { fmt.Printf(\u0026#34;product name %s, count %d\\n\u0026#34;, counter.Name, counter.Count) } } // use bind fields to update a zero value \t{ { var p Product result, err := brick.BindDefaultFields(Offsetof(p.Price), Offsetof(p.UpdatedAt)).Update(\u0026amp;Product{ Price: 0, }) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } } var products []Product result, err = brick.Find(\u0026amp;products) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } for _, p := range products { fmt.Printf(\u0026#34;product name %s, price %v\\n\u0026#34;, p.Name, p.Price) } } // delete with element \t{ // make a transaction, because I do not really delete a data \tbrick := brick.Begin() var product Product result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Name), \u0026#34;food four\u0026#34;).Find(\u0026amp;product) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } result, err = brick.Delete(\u0026amp;product) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } var disappearProduct Product result, err = brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Name), \u0026#34;food four\u0026#34;).Find(\u0026amp;disappearProduct) if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;error(%s)\\n\u0026#34;, err) brick.Rollback() } // delete with condition \t{ // make a transaction, because I am not really delete a data \tbrick := brick.Begin() result, err := brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Name), \u0026#34;food four\u0026#34;).DeleteWithConditions() if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } var product Product _, err = brick.Where(toyorm.ExprEqual, Offsetof(Product{}.Name), \u0026#34;food four\u0026#34;).Find(\u0026amp;product) fmt.Printf(\u0026#34;error(%s)\\n\u0026#34;, err) brick.Rollback() } // group by \t{ var tab ProductGroup brick := toy.Model(\u0026amp;tab).Debug().GroupBy(Offsetof(tab.Tag)) var groups []ProductGroup result, err := brick.Find(\u0026amp;groups) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } for _, g := range groups { fmt.Printf(\u0026#34;group %#v\\n\u0026#34;, g) } } // custom insert \t{ data := Product{ Name: \u0026#34;bag\u0026#34;, Price: 9999, Count: 2, Tag: \u0026#34;container\u0026#34;, } result, err := brick.Template(\u0026#34;INSERT INTO $ModelName($Columns) Values($Values)\u0026#34;).Insert(\u0026amp;data) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } } // custom find \t{ var data Product // if driver is mysql use \u0026#34;USE INDEX\u0026#34; replace \u0026#34;INDEXED BY\u0026#34; \tresult, err := brick.Template(\u0026#34;SELECT $Columns FROM $ModelName INDEXED BY idx_product_name $Conditions\u0026#34;). Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Find(\u0026amp;data) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;find where name = bag %v\\n\u0026#34;, data) } // custom update \t{ fmt.Printf(\u0026#34;the template source %s\\n\u0026#34;, fmt.Sprintf(\u0026#34;UPDATE $ModelName SET $Values,$FN-Count = $0x%x + ? $Conditions\u0026#34;, Offsetof(Product{}.Count))) result, err := brick.Template(fmt.Sprintf(\u0026#34;UPDATE $ModelName SET $Values,$FN-Count = $0x%x + ? $Conditions\u0026#34;, Offsetof(Product{}.Count)), 2). Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Update(\u0026amp;Product{Price: 200}) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } var data Product result, err = brick.Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Find(\u0026amp;data) if err != nil { panic(err) } if resultErr := result.Err(); resultErr != nil { fmt.Print(resultErr) } fmt.Printf(\u0026#34;now bag product count is %d\\n\u0026#34;, data.Count) } }"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/2_engine/toy_toolkit/",
	"title": "toy toolkit",
	"tags": [],
	"description": "",
	"content": " SetDebug set default debug mode\ntoy.SetDebug(true) // set default debug mode \tbrick := toy.Model(\u0026amp;User{}) // now ToyBrick debug mode is true \t"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/2_engine/",
	"title": "Engine",
	"tags": [],
	"description": "toyorm engine",
	"content": "toyorm need use \u0026ldquo;database/sql\u0026rdquo; package to operation database\nit\u0026rsquo;s provides a generic interface around SQL (or SQL-like) databases.\nthis package must be used in conjunction with a database driver\ntoyorm only support following database driver, let\u0026rsquo;s see how to use it\nimport driver // if database is mysql _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; // if database is sqlite3 _ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; // when database is postgres _ \u0026#34;github.com/lib/pq\u0026#34;  create Toy object // if database is mysql, make sure your mysql have toyorm_example schema toy, err = toyorm.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:@tcp(localhost:3306)/toyorm_example?charset=utf8\u0026amp;parseTime=True\u0026#34;) // if database is sqlite3 toy,err = toyorm.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;toyorm_test.db\u0026#34;) // when database is postgres toy, err = toyorm.Open(\u0026#34;postgres\u0026#34;, \u0026#34;user=postgres dbname=toyorm sslmode=disable\u0026#34;)  "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/3_data_definition/type_translation/",
	"title": "Type Translate",
	"tags": [],
	"description": "how to connection database",
	"content": "if sql type is null, toyorm will ignore it in Sql Operation\nyou can use \u0026lt;type:sql_type\u0026gt; tag to declaration field sql type\nthe following Go type will auto declaration it\u0026rsquo;s sql type\n   Go Type sql type     bool BOOLEAN   int8,int16,int32,uint8,uint16,uint32 INTEGER   int64,uint64,int,uint BIGINT   float32,float64 FLOAT   string VARCHAR(255)   time.Time TIMESTAMP   []byte VARCHAR(255)   sql.NullBool BOOLEAN   sql.NullInt64 BIGINT   sql.NullFloat64 FLOAT   sql.NullString VARCHAR(255)   sql.RawBytes VARCHAR(255)    "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/3_data_definition/",
	"title": "Data Definition",
	"tags": [],
	"description": "data definition",
	"content": "toyorm use struct type to declaration table infomation\ninherit toyorm.ModelDefault will add ID,CreatedAt,UpdatedAt,DeletedAt field\nlike this\ntype Blog struct { toyorm.ModelDefault UserID uint `toyorm:\u0026#34;index\u0026#34;` Title string `toyorm:\u0026#34;index\u0026#34;` Content string } if you want define custom field, implement sql.Scan and sql.Value interface{} in field type and declaration its sql type in type tag\n// e.g create custom field type Extra map[string]interface{} // implement sql.Scaner interface{} func (e Extra) Scan(value interface{}) error { switch v := value.(type) { case string: return json.Unmarshal([]byte(v), e) case []byte: return json.Unmarshal(v, e) default: return errors.New(\u0026#34;not support type\u0026#34;) } } // implement sql.Valuer interface{} func (e Extra) Value() (driver.Value, error) { return json.Marshal(e) } type UserDetail struct { ID int `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` UserID uint `toyorm:\u0026#34;index\u0026#34;` MainPage string Extra Extra `toyorm:\u0026#34;type:VARCHAR(1024)\u0026#34;`// field with map type was not match in sql, need declaration its type } define struct with group by\n// use by group by type ProductGroup struct { Tag string KindCount int `toyorm:\u0026#34;column:COUNT(*)\u0026#34;` } // implement toyorm.tabler for custom table name func (p ProductGroup) TableName() string { return toyorm.ModelName(reflect.TypeOf(Product{})) } define struct with its preload data\ntype User struct { toyorm.ModelDefault Name string `toyorm:\u0026#34;unique index\u0026#34;` Age int Sex string Detail *UserDetail // UserDetail type has UserId field ,it match OneToOne auto-preload condition  Friends []*User // Friends is slice object,and it element type have UserId field, it match OneToMany auto-preload condition  Blog []Blog // same as Detail field, toyorm will preload it\u0026#39;s data when call ToyBrick.Preload }"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/3_data_definition/tag/",
	"title": "Tag declaration",
	"tags": [],
	"description": "tag declaration2",
	"content": "declaration format can be \u0026lt;key:value\u0026gt; or \u0026lt;key\u0026gt;\ntype User struct { toyorm.ModelDefault Name uint `toyorm:\u0026#34;index\u0026#34;` // key only tag declaration  FullName string `toyorm:\u0026#34;column:fullname\u0026#34;` // key:value tag declaration }  the following is special tag declaration     Key Value Description     index void or string use for optimization when search condition have this field,if you want make a combined,just set same index name with fields   unique index void or string have unique limit index, other same as index   primary key void allow multiple primary key,but some operation not support   - void ignore this field in sql   type string sql type   column string sql column name   auto_increment void recommend, if your table primary key have auto_increment attribute must add it   autoincrement void same as auto_increment   foreign key void to add foreign key feature when create table   alias string change field name with toyorm   join string to select related field when call brick.Join   belong to string to select related field when call brick.Preload with BelongTo container   one to one string to select related field when call brick.Preload with OneToOne container   one to many string to select related field when call brick.Preload with OneToMany container    other custom tag declaration will append to end of CREATE TABLE field\ntype User struct { toyorm.ModelDefault Born time.Time `toyorm:\u0026#34;NULL\u0026#34;` } // when call CreateTable the born field have \u0026#34;null\u0026#34; attribute at the end // CREATE TABLE `user` (... , born TIMESTAMP null, ...)"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/",
	"title": "ToyBrick",
	"tags": [],
	"description": "ToyBrick usage",
	"content": " ToyBrick is portal for operation sql, create it with Toy.Model()\nif you not know how to create Toy Object, goto [engine] section\nInit use Toy.Model to create ToyBrick, the first args must be struct type or its point type\ninit // User declaration in database connection section brick := toy.Model(\u0026amp;User{}) // or brick := toy.Model(User{})  Sql Build all build method will return new *ToyBrick object , it don\u0026rsquo;t change attribute with current object\nwhere condition brick = brick.Where(toyorm.ExprEqual, Offsetof(User{}.Sex), \u0026#34;male\u0026#34;) or use string brick = brick.Where(\u0026#34;=\u0026#34;, Offsetof(User{}.Sex), \u0026#34;male\u0026#34;) // WHERE tag = \u0026#34;male\u0026#34;  transcation // start a transaction brick = brick.Begin() // do sth result, err := brick.Insert(user) ... // if have error rollback else commit if err != nil { err := brick.Rollback() if err != nil { panic(err) } }else { brick.Commit() }  Data Operation create table _, err = toy.Model(\u0026amp;User{}).Debug().CreateTable() // CREATE TABLE user (id BIGINT AUTO_INCREMENT,created_at TIMESTAMP NULL,updated_at TIMESTAMP NULL,deleted_at TIMESTAMP NULL,name VARCHAR(255),age BIGINT ,sex VARCHAR(255) , PRIMARY KEY(id)) // CREATE INDEX idx_user_deletedat ON user(deleted_at) // CREATE UNIQUE INDEX udx_user_name ON user(name)  Drop table var err error _, err =toy.Model(\u0026amp;User{}).Debug().DropTable() // DROP TABLE user  insert user := \u0026amp;User{ Name: \u0026#34;bigpigeon\u0026#34;, Age: 18, Sex: \u0026#34;male\u0026#34;, } _, err = toy.Model(\u0026amp;User{}).Debug().Insert(\u0026amp;user) // INSERT INTO user(created_at,updated_at,name,age,sex) VALUES(?,?,?,?,?) , args:[]interface {}{time.Time{wall:0xbe8df5112e7f07c8, ext:210013499, loc:(*time.Location)(0x141af80)}, time.Time{wall:0xbe8df5112e7f1768, ext:210017044, loc:(*time.Location)(0x141af80)}, \u0026#34;bigpigeon\u0026#34;, 18, \u0026#34;male\u0026#34;} // print user format with json /* { \u0026#34;ID\u0026#34;: 1, \u0026#34;CreatedAt\u0026#34;: \u0026#34;2018-01-11T20:47:00.780077+08:00\u0026#34;, \u0026#34;UpdatedAt\u0026#34;: \u0026#34;2018-01-11T20:47:00.780081+08:00\u0026#34;, \u0026#34;DeletedAt\u0026#34;: null, \u0026#34;Name\u0026#34;: \u0026#34;bigpigeon\u0026#34;, \u0026#34;Age\u0026#34;: 18, \u0026#34;Sex\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;Detail\u0026#34;: null, \u0026#34;Friends\u0026#34;: null, \u0026#34;Blog\u0026#34;: null }*/  Save operation will replace data when old primary key exist\nsave users := []User{ { ModelDefault: toyorm.ModelDefault{ID: 1}, Name: \u0026#34;bigpigeon\u0026#34;, Age: 18, Sex: \u0026#34;male\u0026#34;, }, { Name: \u0026#34;fatpigeon\u0026#34;, Age: 27, Sex: \u0026#34;male\u0026#34;, }, } _, err = toy.Model(\u0026amp;User{}).Debug().Save(\u0026amp;user) // SELECT id,created_at FROM user WHERE id IN (?), args:[]interface {}{0x1} // REPLACE INTO user(id,created_at,updated_at,name,age,sex) VALUES(?,?,?,?,?,?) , args:[]interface {}{0x1, time.Time{wall:0x0, ext:63651278036, loc:(*time.Location)(nil)}, time.Time{wall:0xbe8dfb5511465918, ext:302600558, loc:(*time.Location)(0x141af80)}, \u0026#34;bigpigeon\u0026#34;, 18, \u0026#34;male\u0026#34;} // INSERT INTO user(created_at,updated_at,name,age,sex) VALUES(?,?,?,?,?) , args:[]interface {}{time.Time{wall:0xbe8dfb551131b7d8, ext:301251230, loc:(*time.Location)(0x141af80)}, time.Time{wall:0xbe8dfb5511465918, ext:302600558, loc:(*time.Location)(0x141af80)}, \u0026#34;fatpigeon\u0026#34;, 27, \u0026#34;male\u0026#34;}  update toy.Model(\u0026amp;User{}).Debug().Update(\u0026amp;User{ Age: 4, }) // UPDATE user SET updated_at=?,age=? WHERE deleted_at IS NULL, args:[]interface {}{time.Time{wall:0xbe8df4eb81b6c050, ext:233425327, loc:(*time.Location)(0x141af80)}, 4}  find one var user User _, err = toy.Model(\u0026amp;User{}).Debug().Find(\u0026amp;user} // SELECT id,created_at,updated_at,deleted_at,name,age,sex FROM user WHERE deleted_at IS NULL LIMIT 1, args:[]interface {}(nil) // print user format with json /* { \u0026#34;ID\u0026#34;: 1, \u0026#34;CreatedAt\u0026#34;: \u0026#34;2018-01-11T12:47:01Z\u0026#34;, \u0026#34;UpdatedAt\u0026#34;: \u0026#34;2018-01-11T12:47:01Z\u0026#34;, \u0026#34;DeletedAt\u0026#34;: null, \u0026#34;Name\u0026#34;: \u0026#34;bigpigeon\u0026#34;, \u0026#34;Age\u0026#34;: 4, \u0026#34;Sex\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;Detail\u0026#34;: null, \u0026#34;Friends\u0026#34;: null, \u0026#34;Blog\u0026#34;: null }*/  find slice var users []User _, err = brick.Debug().Find(\u0026amp;users) fmt.Printf(\u0026#34;find users %s\\n\u0026#34;, JsonEncode(\u0026amp;users)) // SELECT id,created_at,updated_at,deleted_at,name,age,sex FROM user WHERE deleted_at IS NULL, args:[]interface {}(nil)  delete with primary key _, err = brick.Debug().Delete(\u0026amp;user) // UPDATE user SET deleted_at=? WHERE id IN (?), args:[]interface {}{(*time.Time)(0xc4200f0520), 0x1}  delete with condition _, err = brick.Debug().Where(toyorm.ExprEqual, Offsetof(User{}.Name), \u0026#34;bigpigeon\u0026#34;).DeleteWithConditions() // UPDATE user SET deleted_at=? WHERE name = ?, args:[]interface {}{(*time.Time)(0xc4200dbfa0), \u0026#34;bigpigeon\u0026#34;}  "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/5_collection/",
	"title": "collection",
	"tags": [],
	"description": "",
	"content": "TODO\n"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/toy_doctor/",
	"title": "toy-doctor",
	"tags": [],
	"description": "",
	"content": " simple parameter check for toyorm\nExample some code in main.go\npackage main import ( \u0026#34;github.com/bigpigeon/toyorm\u0026#34; . \u0026#34;unsafe\u0026#34; ) type Detail struct { ID uint32 `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` ProductID uint32 `toyorm:\u0026#34;index\u0026#34;` Name string } type Product struct { toyorm.ModelDefault Name string `toyorm:\u0026#34;index\u0026#34;` Detail *Detail } func main() { toy, err := toyorm.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;\u0026#34;) if err != nil { panic(err) } brick := toy.Model(\u0026amp;Product{}) // to preload detail \tbrick = brick.OrderBy(Offsetof(Product{}.CreatedAt)).Preload(Offsetof(Product{}.Detail)).Enter() var tab []Product result, err := brick.Find(\u0026amp;tab) if err != nil { panic(err) } if err := result.Err();err != nil { // sql error record it \t} // have error \tbrick = brick.OrderBy(Offsetof(Detail{}.Name)) result, err = brick.Find(\u0026amp;tab) if err != nil { panic(err) } if err := result.Err();err != nil { // sql error record it \t} } use toy-doctor to check it\u0026rsquo;s error\ntoy-doctor main.go // Output: // main.go:37:33 type must same as main.go:20:6  generate coverprofile\ntoy-doctor -coverprofile=a.out main.go // view corverage in browser go tool cover -html=a.out  "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/4_bind_field/",
	"title": "Bind Field",
	"tags": [],
	"description": "",
	"content": "use bind fields method to rule which field in sql operation\nif bind fields, skill IgnoreMode\nBindDefaultFields work on all Mode\n{ var p Product result, err := brick.BindDefaultFields(Offsetof(p.Price), Offsetof(p.UpdatedAt)).Update(\u0026amp;Product{ Price: 0, }) // UPDATE `product` SET price=?,updated_at=? WHERE deleted_at IS NULL args:[0,\u0026#34;2018-05-14T12:16:21.731031534+08:00\u0026#34;]  // process error  ... } var products []Product result, err = brick.Find(\u0026amp;products) // process error ... for _, p := range products { fmt.Printf(\u0026#34;product name %s, price %v\\n\u0026#34;, p.Name, p.Price) }"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/1_condition/",
	"title": "Condition",
	"tags": [],
	"description": "where usage",
	"content": " Condition work on Update/Find/Delete operation\nwhere will clean old conditions and make new one\nbrick.Where(\u0026lt;expr\u0026gt;, \u0026lt;Key\u0026gt;, [value])  whereGroup add multiple condition with same expr\nbrick.WhereGroup(\u0026lt;expr\u0026gt;, \u0026lt;group\u0026gt;)  conditions will copy conditions and clean old conditions\nbrick.Conditions(\u0026lt;toyorm.Search\u0026gt;)  or \u0026amp; and condition will use or/and to link new condition when current condition is not nil\nbrick.Or().Condition(\u0026lt;expr\u0026gt;, \u0026lt;Key\u0026gt;, [value]) brick.Or().ConditionGroup(\u0026lt;expr\u0026gt;, \u0026lt;group\u0026gt;) brick.And().Condition(\u0026lt;expr\u0026gt;, \u0026lt;Key\u0026gt;, [value]) brick.And().ConditionGroup(\u0026lt;expr\u0026gt;, \u0026lt;group\u0026gt;)  or \u0026amp; and conditions will use or/and to link new conditions\nbrick.Or().Conditions(\u0026lt;toyorm.Search\u0026gt;) brick.And().Conditions(\u0026lt;toyorm.Search\u0026gt;)  expr map    SearchExpr to sql example     ExprAnd AND brick.WhereGroup(ExprAnd, Product{Name:\u0026ldquo;food one\u0026rdquo;, Count: 4}) // WHERE name = \u0026ldquo;food one\u0026rdquo; AND Count = 4   ExprOr OR brick.WhereGroup(ExprOr, Product{Name:\u0026ldquo;food one\u0026rdquo;, Count: 4}) // WHERE name = \u0026ldquo;food one\u0026rdquo; OR Count = \u0026ldquo;4\u0026rdquo;   ExprEqual = brick.Where(ExprEqual, OffsetOf(Product{}.Name), \u0026ldquo;food one\u0026rdquo;) // WHERE name = \u0026ldquo;find one\u0026rdquo;   ExprNotEqual \u0026lt;\u0026gt; brick.Where(ExprNotEqual, OffsetOf(Product{}.Name), \u0026ldquo;food one\u0026rdquo;) // WHERE name \u0026lt;\u0026gt; \u0026ldquo;find one\u0026rdquo;   ExprGreater \u0026gt; brick.Where(ExprGreater, OffsetOf(Product{}.Count), 3) // WHERE count \u0026gt; 3   ExprGreaterEqual \u0026gt;= brick.Where(ExprGreaterEqual, OffsetOf(Product{}.Count), 3) // WHERE count \u0026gt;= 3   ExprLess \u0026lt; brick.Where(ExprLess, OffsetOf(Product{}.Count), 3) // WHERE count \u0026lt; 3   ExprLessEqual \u0026lt;= brick.Where(ExprLessEqual, OffsetOf(Product{}.Count), 3) // WHERE count \u0026lt;= 3   ExprBetween Between brick.Where(ExprBetween, OffsetOf(Product{}.Count), [2]int{2,3}) // WHERE count BETWEEN 2 AND 3   ExprNotBetween NOT Between brick.Where(ExprNotBetween, OffsetOf(Product{}.Count), [2]int{2,3}) // WHERE count NOT BETWEEN 2 AND 3   ExprIn IN brick.Where(ExprIn, OffsetOf(Product{}.Count), []int{1, 2, 3}) // WHERE count IN (1,2,3)   ExprNotIn NOT IN brick.Where(ExprNotIn, OffsetOf(Product{}.Count), []int{1, 2, 3}) // WHERE count NOT IN (1,2,3)   ExprLike LIKE brick.Where(ExprLike, OffsetOf(Product{}.Name), \u0026ldquo;one\u0026rdquo;) // WHERE name LIKE \u0026ldquo;one\u0026rdquo;   ExprNotLike NOT LIKE brick.Where(ExprNotLike, OffsetOf(Product{}.Name), \u0026ldquo;one\u0026rdquo;) // WHERE name NOT LIKE \u0026ldquo;one\u0026rdquo;   ExprNull IS NULL brick.Where(ExprNull, OffsetOf(Product{}.DeletedAt)) // WHERE DeletedAt IS NULL   ExprNotNull IS NOT NULL brick.Where(ExprNotNull, OffsetOf(Product{}.DeletedAt)) // WHERE DeletedAt IS NOT NULL    limit \u0026amp; offset\nbrick := brick.Offset(2).Limit(2) // LIMIT 2 OFFSET 2 order by\nbrick = brick.OrderBy(Offsetof(Product{}.Name)) // ORDER BY name order by desc\nbrick = brick.OrderBy(brick.ToDesc(Offsetof(Product{}.Name))) // ORDER BY name DESC group by\n// define group by struct type ProductGroup struct { Tag string KindCount int `toyorm:\u0026#34;column:COUNT(*)\u0026#34;` } // implement toyorm.tabler for custom table name func (p ProductGroup) TableName() string { return toyorm.ModelName(reflect.TypeOf(Product{})) } ... var tab ProductGroup brick := toy.Model(\u0026amp;tab).Debug().GroupBy(Offsetof(tab.Tag)) var data []ProductGroup brick.Find(\u0026amp;data) // SELECT tag,COUNT(*) FROM `product` GROUP BY tag "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/11_field_selector/",
	"title": "Field Selector",
	"tags": [],
	"description": "",
	"content": "toyorm support multiple way to get model fieldï¼Œfrom struct, field name or field offset\nyou can use any kind to access it e.g\ninsert // use struct // insert with struct product := Product{ Name: \u0026#34;sth\u0026#34;, Price: 22, } brick.Insert(\u0026amp;product) // or insert with name map product := map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;sth\u0026#34;, \u0026#34;Price\u0026#34;: 22, } brick.Insert(\u0026amp;product) // or insert with offsetof map, in this method, you need import \u0026#34;unsafe\u0026#34; to get it\u0026#39;s Offsetof function product := map[uintptr]interface{}{ Offsetof(Product{}.Name): \u0026#34;sth\u0026#34;, Offsetof(Product{}.Price): 22, } brick.Insert(\u0026amp;product)  where // select field with name string brick = brick.Where(\u0026#34;\u0026gt;\u0026#34;, \u0026#34;Price\u0026#34;, 22) // select field with with offsetof, you need import \u0026#34;unsafe\u0026#34; to get it\u0026#39;s Offsetof function brick = brick.Where(\u0026#34;\u0026gt;\u0026#34;, Offsetof(Product{}.Price), 22)  data operation support field selector\n   operation \\ selector OffsetOf Name string map[OffsetOf]interface{} map[string]interface{} struct     Update no no yes yes yes   Insert no no yes yes yes   Save no no yes yes yes   Where \u0026amp; Conditions yes yes no no no   WhereGroup \u0026amp; ConditionGroup no no yes yes yes   BindFields yes yes no no no   Preload \u0026amp; Custom Preload yes yes no no no   OrderBy yes yes no no no   Find no no no no yes    "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/3_ignore_mode/",
	"title": "Ignore Zero Value",
	"tags": [],
	"description": "",
	"content": "when I Update or Search with struct that have some zero value, did I update it ?\nuse IgnoreMode to differentiate what zero value should update\nbrick = brick.IgnoreMode(toyorm.Mode(\u0026#34;Update\u0026#34;), toyorm.IgnoreZero ^ toyorm.IgnoreZeroLen) // ignore all zeor value but excloud zero len slice // now field = []int(nil) will ignore when update // but field = []int{} will update when update // now field = map[int]int(nil) will ignore when update // but field = map[int]int{} will update when update In default\n   Operation Mode affect     Insert IgnoreNo brick.Insert()   Replace IgnoreNo brick.Replace()   Condition IgnoreZero brick.WhereGroup(ExprAnd/ExprOr, )   Update IgnoreZero brick.Update()    All of IgnoreMode\n   mode effective     IgnoreFalse ignore field type is bool and value is false   IgnoreZeroInt ignore field type is int/uint/uintptr(incloud their 16,32,64 bit type) and value is 0   IgnoreZeroFloat ignore field type is float32/float64 and value is 0.0   IgnoreZeroComplex ignore field type is complex64/complex128 and value is 0 + 0i   IgnoreNilString ignore field type is string and value is \u0026ldquo;\u0026rdquo;   IgnoreNilPoint ignore field type is point/map/slice and value is nil   IgnoreZeroLen ignore field type is map/array/slice and len = 0   IgnoreNullStruct ignore field type is struct and value is zero value struct e.g type A struct{A string,B int}, A{\u0026ldquo;\u0026rdquo;, 0} will be ignore   IgnoreNil ignore with IgnoreNilPoint and IgnoreZeroLen   IgnoreZero ignore all of the above    "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/9_join/",
	"title": "Join",
	"tags": [],
	"description": "",
	"content": " Join association query can provide all record in one query\nModel Define use join tag to association related field , join tag value must same as container field name\ntype Extra map[string]interface{} func (e *Extra) Scan(value interface{}) error { switch v := value.(type) { case string: return json.Unmarshal([]byte(v), e) case []byte: return json.Unmarshal(v, e) default: return errors.New(\u0026#34;not support type\u0026#34;) } } func (e Extra) Value() (driver.Value, error) { return json.Marshal(e) } type Color struct { Name string `toyorm:\u0026#34;primary key;join:ColorDetail\u0026#34;` Code int32 } type Comment struct { toyorm.ModelDefault ProductDetailProductID uint32 `toyorm:\u0026#34;index\u0026#34;` Data string `toyorm:\u0026#34;type:VARCHAR(1024)\u0026#34;` } type ProductDetail struct { ProductID uint32 `toyorm:\u0026#34;primary key;join:Detail\u0026#34;` Title string CustomPage string `toyorm:\u0026#34;type:text\u0026#34;` Extra Extra `toyorm:\u0026#34;type:VARCHAR(2048)\u0026#34;` Color string `toyorm:\u0026#34;join:ColorDetail\u0026#34;` ColorJoin Color `toyorm:\u0026#34;alias:ColorDetail\u0026#34;` Comment []Comment } type Product struct { ID uint32 `toyorm:\u0026#34;primary key;auto_increment;join:Detail\u0026#34;` CreatedAt time.Time `toyorm:\u0026#34;NULL\u0026#34;` DeletedAt *time.Time `toyorm:\u0026#34;NULL\u0026#34;` Name string Count int Price float64 Detail *ProductDetail } Join in Find Swap on Join just like Enter on Preload, can back to previous data\nbrick := toy.Model(\u0026amp;tab).Debug(). Join(Offsetof(tab.Detail)). Join(Offsetof(detailTab.ColorJoin)).Swap().Swap() var scanData []Product result, err = brick.Find(\u0026amp;scanData) // SELECT m.id,m.created_at,m.deleted_at,m.name,m.count,m.price,m_0.product_id,m_0.title,m_0.custom_page,m_0.extra,m_0.color,m_0_0.name,m_0_0.code FROM `product` as `m` JOIN `product_detail` AS `m_0` ON m.id = m_0.product_id JOIN `color` AS `m_0_0` ON m_0.color = m_0_0.name WHERE m.deleted_at IS NULL use Join to switch current model and add conditions\n// where Product.Name = \u0026#34;clean stick\u0026#34; or Color.Name = \u0026#34;black\u0026#34; brick := toy.Model(\u0026amp;tab).Debug().Where(\u0026#34;=\u0026#34;, Offsetof(tab.Name), \u0026#34;clean stick\u0026#34;). Join(Offsetof(tab.Detail)). Join(Offsetof(detailTab.ColorJoin)).Or().Condition(\u0026#34;=\u0026#34;, Offsetof(colorTab.Name), \u0026#34;black\u0026#34;). Swap().Swap() var scanData []Product result, err = brick.Find(\u0026amp;scanData) // SELECT m.id,m.created_at,m.deleted_at,m.name,m.count,m.price,m_0.product_id,m_0.title,m_0.custom_page,m_0.extra,m_0.color,m_0_0.name,m_0_0.code FROM `product` as `m` JOIN `product_detail` AS `m_0` ON m.id = m_0.product_id JOIN `color` AS `m_0_0` ON m_0.color = m_0_0.name WHERE m.deleted_at IS NULL AND (m.name = ? OR m_0_0.name = ?) args:[\u0026#34;clean stick\u0026#34;,\u0026#34;black\u0026#34;] set order just like add conditions\n// where Product.Name = \u0026#34;clean stick\u0026#34; or Color.Name = \u0026#34;black\u0026#34; brick := toy.Model(\u0026amp;tab).Debug(). Join(Offsetof(tab.Detail)). Join(Offsetof(detailTab.ColorJoin)).OrderBy(Offsetof(colorTab.Name)). Swap().Swap() var scanData []Product result, err = brick.Find(\u0026amp;scanData) // SELECT m.id,m.created_at,m.deleted_at,m.name,m.count,m.price,m_0.product_id,m_0.title,m_0.custom_page,m_0.extra,m_0.color,m_0_0.name,m_0_0.code FROM `product` as `m` JOIN `product_detail` AS `m_0` ON m.id = m_0.product_id JOIN `color` AS `m_0_0` ON m_0.color = m_0_0.name WHERE m.deleted_at IS NULL ORDER BY m_0_0.name also can set GroupBy but here not example\nPreload On Join Preload method also work on Join mode\nbrick := toy.Model(\u0026amp;tab).Debug(). Join(Offsetof(tab.Detail)).Preload(Offsetof(detailTab.Comment)).Enter(). Join(Offsetof(detailTab.ColorJoin)).Swap().Swap() var scanData []Product result, err = brick.Find(\u0026amp;scanData) // SELECT m.id,m.created_at,m.deleted_at,m.name,m.count,m.price,m_0.product_id,m_0.title,m_0.custom_page,m_0.extra,m_0.color,m_0_0.name,m_0_0.code FROM `product` as `m` JOIN `product_detail` AS `m_0` ON m.id = m_0.product_id JOIN `color` AS `m_0_0` ON m_0.color = m_0_0.name WHERE m.deleted_at IS NULL // SELECT id,created_at,updated_at,deleted_at,product_detail_product_id,data FROM `comment` WHERE deleted_at IS NULL AND product_detail_product_id IN (?,?,?) args:[1,2,3]"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/8_preload/",
	"title": "Preload",
	"tags": [],
	"description": "",
	"content": " preload need have relation field and container field(ManyToMany just need container field)\nrelations field is used to link the main record and sub record\nrelation field can be Foreign key, but not recommend\ncontainer field is used to save sub record, it does not belong to a table field\nOne to one relation field at sub model\nrelation field name must be main model type name + main model primary key name\ntype User struct { toyorm.ModelDefault // container field  Detail *UserDetail } type UserDetail struct { ID int `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` // relation field  UserID uint `toyorm:\u0026#34;index\u0026#34;` MainPage string `toyorm:\u0026#34;type:Text\u0026#34;` } // load preload brick = toy.Model(\u0026amp;User{}).Debug().Preload(OffsetOf(User.Detail)).Enter() Belong to relation field at main model\nrelation field name must be container field name + sub model primary key name\ntype User struct { toyorm.ModelDefault // container field  Detail *UserDetail // relation field  DetailID int `toyorm:\u0026#34;index\u0026#34;` } type UserDetail struct { ID int `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` MainPage string `toyorm:\u0026#34;type:Text\u0026#34;` } One to many relation field at sub model\nrelation field name must be main model type name + main model primary key name\ntype User struct { toyorm.ModelDefault // container field  Blog []Blog } type Blog struct { toyorm.ModelDefault // relation field  UserID uint `toyorm:\u0026#34;index\u0026#34;` Title string `toyorm:\u0026#34;index\u0026#34;` Content string } Many to many many to many not need to specified the relation field,it relation field at middle model\ntype User struct { toyorm.ModelDefault // container field Friends []*User }  Load preload when you finish model definition, it time to load preload\n// create a main brick brick = toy.Model(\u0026amp;User{}) // create a sub brick subBrick := brick.Preload(OffsetOf(User.Blog)) // you can editing any attribute what you want, just like editing it on main model subBrick = subBrick.Where(ExprEqual, OffsetOf(Blog.Title), \u0026#34;my blog\u0026#34;) // finished change ,use Enter() go back the main brick brick = subBrick.Enter() if you not like relation field name rule,use custom module to create it\n// one to one custom brick.CustomOneToOnePreload(\u0026lt;main container\u0026gt;, \u0026lt;sub relation\u0026gt;, [sub model struct]) // belong to custom brick.CustomBelongToPreload(\u0026lt;main container\u0026gt;, \u0026lt;main relation\u0026gt;, [sub model struct]) // one to many brick.CustomOneToManyPreload(\u0026lt;main container\u0026gt;, \u0026lt;sub relation\u0026gt;, [sub model struct]) // many to many brick.CustomManyToManyPreload(\u0026lt;middle model struct\u0026gt;, \u0026lt;main container\u0026gt;, \u0026lt;main relation\u0026gt;, \u0026lt;sub relation\u0026gt;, [sub model struct]) or use tag declaration\ntype UserDetail struct { ID int `toyorm:\u0026#34;primary key;auto_increment\u0026#34;` MainID uint32 `toyorm:\u0026#34;index;one to one:Detail\u0026#34;` // declaration the container field  MainPage string `toyorm:\u0026#34;type:Text\u0026#34;` Extra Extra `toyorm:\u0026#34;type:VARCHAR(1024)\u0026#34;` } type Blog struct { toyorm.ModelDefault MainID uint32 `toyorm:\u0026#34;index;one to many:Blog\u0026#34;` // declaration the container field  Title string `toyorm:\u0026#34;index\u0026#34;` Content string } type User struct { toyorm.ModelDefault Name string `toyorm:\u0026#34;unique index\u0026#34;` Age int Sex string Detail *UserDetail Friends []*User Blog []Blog } // now custom relation field is MainID brick = brick.Preload(Offsetof(User{}.Blog)).Enter() brick = brick.Preload(Offsetof(User{}.Detail)).Enter()"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/10_result/",
	"title": "Result",
	"tags": [],
	"description": "",
	"content": "use Report to view sql action\nreport format\ninsert operation report\nuser := User{ Detail: \u0026amp;UserDetail{ MainPage: \u0026#34;some html code with you page\u0026#34;, Extra: Extra{\u0026#34;title\u0026#34;: \u0026#34;my blog\u0026#34;}, }, Blog: []Blog{ {Title: \u0026#34;how to write a blog\u0026#34;, Content: \u0026#34;first ...\u0026#34;}, {Title: \u0026#34;blog introduction\u0026#34;, Content: \u0026#34;...\u0026#34;}, }, Friends: []*User{ { Detail: \u0026amp;UserDetail{ MainPage: \u0026#34;some html code with you page\u0026#34;, Extra: Extra{}, }, Blog: []Blog{ {Title: \u0026#34;some python tech\u0026#34;, Content: \u0026#34;first ...\u0026#34;}, {Title: \u0026#34;my eleme_union_meal usage\u0026#34;, Content: \u0026#34;...\u0026#34;}, }, Name: \u0026#34;fatpigeon\u0026#34;, Age: 18, Sex: \u0026#34;male\u0026#34;, }, }, Name: \u0026#34;bigpigeon\u0026#34;, Age: 18, Sex: \u0026#34;male\u0026#34;, } result, err = brick.Save(\u0026amp;user) // error process ... fmt.Printf(\u0026#34;report:\\n%s\\n\u0026#34;, result.Report()) /* // [0, ] means affected the 0 element // [0-0, ] means affected the 0 element the 0 sub element report: [0, ] INSERT INTO user(created_at,updated_at,deleted_at,name,age,sex) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.012285+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.012285+08:00\u0026#34;,null,\u0026#34;bigpigeon\u0026#34;,18,\u0026#34;male\u0026#34;] preload Detail [0-, ] INSERT INTO user_detail(user_id,main_page,extra) VALUES(?,?,?) args:[1,\u0026#34;some html code with you page\u0026#34;,{\u0026#34;title\u0026#34;:\u0026#34;my blog\u0026#34;}] preload Blog [0-0, ] INSERT INTO blog(created_at,updated_at,deleted_at,user_id,title,content) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.013968+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.013968+08:00\u0026#34;,null,1,\u0026#34;how to write a blog\u0026#34;,\u0026#34;first ...\u0026#34;] [0-1, ] INSERT INTO blog(created_at,updated_at,deleted_at,user_id,title,content) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.013968+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.013968+08:00\u0026#34;,null,1,\u0026#34;blog introduction\u0026#34;,\u0026#34;...\u0026#34;] preload Friends [0-0, ] INSERT INTO user(created_at,updated_at,deleted_at,name,age,sex) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.015207+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.015207+08:00\u0026#34;,null,\u0026#34;fatpigeon\u0026#34;,18,\u0026#34;male\u0026#34;] preload Detail [0-0-, ] INSERT INTO user_detail(user_id,main_page,extra) VALUES(?,?,?) args:[2,\u0026#34;some html code with you page\u0026#34;,{}] preload Blog [0-0-0, ] INSERT INTO blog(created_at,updated_at,deleted_at,user_id,title,content) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.016389+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.016389+08:00\u0026#34;,null,2,\u0026#34;some python tech\u0026#34;,\u0026#34;first ...\u0026#34;] [0-0-1, ] INSERT INTO blog(created_at,updated_at,deleted_at,user_id,title,content) VALUES(?,?,?,?,?,?) args:[\u0026#34;2018-02-28T17:31:20.016389+08:00\u0026#34;,\u0026#34;2018-02-28T17:31:20.016389+08:00\u0026#34;,null,2,\u0026#34;my eleme_union_meal usage\u0026#34;,\u0026#34;...\u0026#34;] */ find operation report\nbrick := brick.Preload(Offsetof(User{}.Friends)). Preload(Offsetof(User{}.Detail)).Enter(). Preload(Offsetof(User{}.Blog)).Enter(). Enter() var users []User result, err = brick.Find(\u0026amp;users) // some error process ... // print the report fmt.Printf(\u0026#34;report:\\n%s\\n\u0026#34;, result.Report()) // report log /* report: [0, 1, ] SELECT id,created_at,updated_at,deleted_at,name,age,sex FROM user WHERE deleted_at IS NULL args:null preload Detail [0-, 1-, ] SELECT id,user_id,main_page,extra FROM user_detail WHERE user_id IN (?,?) args:[2,1] preload Blog [0-0, 0-1, 1-0, 1-1, ] SELECT id,created_at,updated_at,deleted_at,user_id,title,content FROM blog WHERE deleted_at IS NULL AND user_id IN (?,?) args:[1,2] preload Friends [0-0, ] SELECT id,created_at,updated_at,deleted_at,name,age,sex FROM user WHERE deleted_at IS NULL AND id IN (?) args:[2] preload Detail [0-0-, ] SELECT id,user_id,main_page,extra FROM user_detail WHERE user_id IN (?) args:[2] preload Blog [0-0-0, 0-0-1, ] SELECT id,created_at,updated_at,deleted_at,user_id,title,content FROM blog WHERE deleted_at IS NULL AND user_id IN (?) args:[2] */ use Err to view sql action error\nvar users []struct { ID uint32 Age bool Detail *UserDetail Blog []Blog } result, err = brick.Find(\u0026amp;users) if err != nil { panic(err) } if err := result.Err(); err != nil { fmt.Printf(\u0026#34;error:\\n%s\\n\u0026#34;, err) } /* error: SELECT id,age FROM user WHERE deleted_at IS NULL args:null errors( [0]sql: Scan error on column index 1: sql/driver: couldn\u0026#39;t convert \u0026#34;18\u0026#34; into type bool [1]sql: Scan error on column index 1: sql/driver: couldn\u0026#39;t convert \u0026#34;18\u0026#34; into type bool ) */"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/5_scope/",
	"title": "Scope",
	"tags": [],
	"description": "",
	"content": "use scope to make custom build\n// desc all order by fields brick.Scope(func(t *ToyBrick) *ToyBrick{ newOrderBy := make([]*ModelFields, len(t.orderBy)) for i, f := range t.orderBy { newOrderBy = append(newOrderBy, t.ToDesc(f)) } newt := *t newt.orderBy = newOrderBy return \u0026amp;newt })"
},
{
	"uri": "https://bigpigeon.org/toyorm/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/6_template/",
	"title": "Template",
	"tags": [],
	"description": "",
	"content": " use template exec to replace default exec\nnow template only support Insert/Save/Update/Find\nCustom insert data := Product{ Name: \u0026#34;bag\u0026#34;, Price: 9999, Count: 2, Tag: \u0026#34;container\u0026#34;, } result, err := brick.Template(\u0026#34;INSERT INTO $ModelName($Columns) Values($Values)\u0026#34;).Insert(\u0026amp;data) // INSERT INTO product(created_at,updated_at,deleted_at,name,price,count,tag) Values(?,?,?,?,?,?,?) args:[\u0026#34;2018-04-01T17:05:48.927499+08:00\u0026#34;,\u0026#34;2018-04-01T17:05:48.927499+08:00\u0026#34;,null,\u0026#34;bag\u0026#34;,9999,2,\u0026#34;container\u0026#34;] Custom find var data Product // if driver is mysql use \u0026#34;USE INDEX\u0026#34; replace \u0026#34;INDEXED BY\u0026#34; result, err := brick.Template(\u0026#34;SELECT $Columns FROM $ModelName INDEXED BY idx_product_name $Conditions\u0026#34;). Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Find(\u0026amp;data) // SELECT id,created_at,updated_at,deleted_at,name,price,count,tag FROM product INDEXED BY idx_product_name WHERE deleted_at IS NULL AND name = ? LIMIT 1 args:[\u0026#34;bag\u0026#34;] Custom update set count = count + 2\nresult, err := brick.Template(fmt.Sprintf(\u0026#34;UPDATE $ModelName SET $Values,$FN-Count = $0x%x + ? $Conditions\u0026#34;, Offsetof(Product{}.Count)), 2). Where(\u0026#34;=\u0026#34;, Offsetof(Product{}.Name), \u0026#34;bag\u0026#34;).Update(\u0026amp;Product{Price: 200}) // UPDATE product SET updated_at = ?,price = ?,count = count + ? WHERE deleted_at IS NULL AND name = ? args:[\u0026#34;2018-04-01T17:50:35.205377+08:00\u0026#34;,200,2,\u0026#34;bag\u0026#34;] Placeholder follower placeholder use in template example\ntwo \u0026ldquo;field replace\u0026rdquo; placeholder\n $FN- will convert struct field name to table field name e.g $FN-Name =\u0026gt; name $0x will convert struct field offset to table field name e.g $0x58 =\u0026gt; Count     action \\ placeholder $ModelName $Columns $Values $Conditions     Find product id,data,\u0026hellip; - WHERE \u0026hellip; ORDER BY \u0026hellip; GROUP BY \u0026hellip; LIMIT \u0026hellip; OFFSET \u0026hellip;   Insert product id,data,\u0026hellip; ?,?,\u0026hellip; WHERE \u0026hellip; ORDER BY \u0026hellip; GROUP BY \u0026hellip; LIMIT \u0026hellip; OFFSET \u0026hellip;   Save product id,data,\u0026hellip; ?,?,\u0026hellip; WHERE \u0026hellip; ORDER BY \u0026hellip; GROUP BY \u0026hellip; LIMIT \u0026hellip; OFFSET \u0026hellip;   Update product id,data,\u0026hellip; id = ?,data = ?,\u0026hellip; WHERE \u0026hellip; ORDER BY \u0026hellip; GROUP BY \u0026hellip; LIMIT \u0026hellip; OFFSET \u0026hellip;    "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/7_thread_safe/",
	"title": "Thread Safe",
	"tags": [],
	"description": "",
	"content": "Thread safe if you comply with the following agreement\n make sure ToyBrick object is read only, if you want to change it, create a new one\n do not use append to change ToyBrick\u0026rsquo;s slice data,use make and copy to clone new slice\n  "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/",
	"title": "Toyorm",
	"tags": [],
	"description": "powerful toyorm",
	"content": " Toyorm  powerful orm for golang\n Overview  Table Migrate (CreateTable/DropTable) Data Operation (Insert/Save/Update/Find/Delete) Preload Operation(BelongTo/OneToOne/OneToMany/ManyToMany mode) Join Query Transactions Ignore Mode (ignore specified zero/nil field) Bind Fields (when Bind Fields, Only operation Bind Fields in Table) Sofe Delete (Update DeletedAt Fields replace real delete operation) Scope (Custom sql build) Thread safe if comply with the agreement Sql Template (custom your sql syntax) Result And Error (record sql operation log and error) Collection (multiple database operation) toy-doctor(check FieldSelection args)  Go version version \u0026gt; 1.9\nSupport database  sqlite3  mysql  postgresql  "
},
{
	"uri": "https://bigpigeon.org/toyorm/en/4_toy_brick/2_transaction/",
	"title": "Transaction",
	"tags": [],
	"description": "transaction",
	"content": "start a transaction\nbrick = brick.Begin() rollback all sql action\nerr = brick.Rollback() commit all sql action\nerr = brick.Commit()"
}]