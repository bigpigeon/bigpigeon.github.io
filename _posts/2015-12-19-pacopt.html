---
layout: post
title:  "pac脚本优化"
date:   2015-12-19 22:00:00
categories: pac javascript  
excerpt: 降低pac脚本的时间复杂度
---
{% markdown %}
最近发现lantern和shadowsocks client自生成pac都一定的性能问题，在url数目上升到一定程度的时候加载速度明显慢了很多.

于是我翻看了它们的实现

- lantern
  - 把所有需要代理的domain组合成一个RegExp，然后在FindProxyForURL时对host做RegExp.exec的操作来判断是否需要代理
- shadownsocks
  -   把domain做成一个{domain:1,...}的字典，然后在FindProxyForURL时对host做domains.hasOwnProperty判断是否在字典内，若不在，则去掉最前面的'.'和之前的内容 继续做domains.hasOwnProperty判断

可以看出lantern的pac会严重影响网页的加载速度，shadowsocks的稍微好点，但在遇到不需要代理的网页时则会消耗更多无谓的判断

于是我自己实现一个pac优化FindProxyForURL匹配速度

我的思路是:

- 把所有需要代理的url以 '.' 分割成节点
- 然后存入一个dict 格式如下

```javascript
{
  "com": {
    "google": true,
    "blogspot": {
      "www": true  
    }
  }
}
```

- 在FindProxyForURL中把host也split成list与这个dict match一下
- 贴上源码

```javascript
var domains = [
    "google.com",
    "www.blogspot.com",
    ...
];
var domain_dict = {};
for(var i = 0; i < domains.length; i++){
    if(domains[i].endsWith(".")){
        domains[i] = domains[i].slice(0, -1)
    }
    var url_list = domains[i].split('.');

    var domain_node = domain_dict;
    for(var j = url_list.length; j > 0; j--){
        var node_name = url_list[j-1];
        if (!domain_node.hasOwnProperty(node_name)){
            if (j === 1){
                domain_node[node_name] = true;
                break;
            } else {
                domain_node[node_name] = {};
            }
        } else if(domain_node[node_name] === true) {
            break;
        }
        domain_node = domain_node[node_name];
    }
}

var proxy = "SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT";

var direct = 'DIRECT;';

function FindProxyForURL(url, host) {
    if( host == "localhost" ||
        host == "127.0.0.1") {
        return direct;
    }
    var host_list = host.split('.')
    var domain_node = domain_dict
    for(var i = host_list.length; i > 0; i--){
        var node_name = host_list[i-1]
        if (domain_node.hasOwnProperty(node_name)){
            if(domain_node[node_name] === true){
                return proxy;
            } else {
                domain_node = domain_node[node_name]
            }

        }
        else {
            return direct;
        }
    }
    return direct;
}
```

- 以下是我在nodejs下的性能测试结果 [测试js下载地址](/static/testdata/pac_benchmark.zip)

{% endmarkdown  %}
{% markdown %}
> node benchmark.js 10000
{% endmarkdown %}
<div id="bench-chart-10000"></div>
{% markdown %}
> node benchmark.js 100000
{% endmarkdown %}
<div id="bench-chart-100000"></div>
{% markdown %}
> node benchmark.js 1000000
{% endmarkdown %}
<div id="bench-chart-1000000"></div>

<script type="text/javascript">
function makechart(id, data) {
  c3.generate({
    bindto: id,
    data: {
      columns: data,
      type: 'bar'
    },
    axis: {
      y: {
        tick: {
          format: function (d) { return d + "ms"; }
        },
        label: 'time'
      },
      x: {
        type: 'category',
        categories: ['proxy_2_node', 'noproxy_2_node', 'proxy_3_node', 'noproxy_3_node', 'proxy_4_node', 'noproxy_4_node']
      }
    },

    bar: {
      width: {
          ratio: 0.5 // this makes bar width 50% of length between ticks
      }
    }
  });
}
makechart(
  '#bench-chart-10000', 
  [
    ['shadowsocks', 3, 2, 6, 3, 5, 4],
    ['lantern', 4, 32, 2, 39, 18, 47],
    ['bigpigeon_pac', 3, 3, 11, 3, 3, 3]
  ])
makechart(
  '#bench-chart-100000', 
  [
    ['shadowsocks', 24, 22, 37, 37, 47, 51],
    ['lantern', 29, 279, 27, 373, 163, 441],
    ['bigpigeon_pac', 27, 23, 29, 24, 29, 24]
  ])
makechart(
  '#bench-chart-1000000', 
  [
    ['shadowsocks', 136, 130, 287, 309, 401, 460],
    ['lantern', 222, 2776, 258, 3698, 1631, 4420],
    ['bigpigeon_pac', 224, 220, 285, 218, 287, 220]
  ])
</script>

